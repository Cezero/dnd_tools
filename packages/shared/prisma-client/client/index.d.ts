
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model ClassFeature
 * 
 */
export type ClassFeature = $Result.DefaultSelection<Prisma.$ClassFeaturePayload>
/**
 * Model ClassSpellLevel
 * 
 */
export type ClassSpellLevel = $Result.DefaultSelection<Prisma.$ClassSpellLevelPayload>
/**
 * Model ClassLevelAttribute
 * 
 */
export type ClassLevelAttribute = $Result.DefaultSelection<Prisma.$ClassLevelAttributePayload>
/**
 * Model ClassSkillMap
 * 
 */
export type ClassSkillMap = $Result.DefaultSelection<Prisma.$ClassSkillMapPayload>
/**
 * Model ClassSourceMap
 * 
 */
export type ClassSourceMap = $Result.DefaultSelection<Prisma.$ClassSourceMapPayload>
/**
 * Model SpellLevelMap
 * 
 */
export type SpellLevelMap = $Result.DefaultSelection<Prisma.$SpellLevelMapPayload>
/**
 * Model Spell
 * 
 */
export type Spell = $Result.DefaultSelection<Prisma.$SpellPayload>
/**
 * Model SpellDescriptorMap
 * 
 */
export type SpellDescriptorMap = $Result.DefaultSelection<Prisma.$SpellDescriptorMapPayload>
/**
 * Model SpellSchoolMap
 * 
 */
export type SpellSchoolMap = $Result.DefaultSelection<Prisma.$SpellSchoolMapPayload>
/**
 * Model SpellSourceMap
 * 
 */
export type SpellSourceMap = $Result.DefaultSelection<Prisma.$SpellSourceMapPayload>
/**
 * Model SpellSubschoolMap
 * 
 */
export type SpellSubschoolMap = $Result.DefaultSelection<Prisma.$SpellSubschoolMapPayload>
/**
 * Model SpellComponentMap
 * 
 */
export type SpellComponentMap = $Result.DefaultSelection<Prisma.$SpellComponentMapPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model Feat
 * 
 */
export type Feat = $Result.DefaultSelection<Prisma.$FeatPayload>
/**
 * Model FeatBenefitMap
 * 
 */
export type FeatBenefitMap = $Result.DefaultSelection<Prisma.$FeatBenefitMapPayload>
/**
 * Model FeatPrerequisiteMap
 * 
 */
export type FeatPrerequisiteMap = $Result.DefaultSelection<Prisma.$FeatPrerequisiteMapPayload>
/**
 * Model Race
 * 
 */
export type Race = $Result.DefaultSelection<Prisma.$RacePayload>
/**
 * Model RaceTrait
 * 
 */
export type RaceTrait = $Result.DefaultSelection<Prisma.$RaceTraitPayload>
/**
 * Model RaceTraitMap
 * 
 */
export type RaceTraitMap = $Result.DefaultSelection<Prisma.$RaceTraitMapPayload>
/**
 * Model RaceAbilityAdjustment
 * 
 */
export type RaceAbilityAdjustment = $Result.DefaultSelection<Prisma.$RaceAbilityAdjustmentPayload>
/**
 * Model RaceLanguageMap
 * 
 */
export type RaceLanguageMap = $Result.DefaultSelection<Prisma.$RaceLanguageMapPayload>
/**
 * Model RaceSourceMap
 * 
 */
export type RaceSourceMap = $Result.DefaultSelection<Prisma.$RaceSourceMapPayload>
/**
 * Model Armor
 * 
 */
export type Armor = $Result.DefaultSelection<Prisma.$ArmorPayload>
/**
 * Model Weapon
 * 
 */
export type Weapon = $Result.DefaultSelection<Prisma.$WeaponPayload>
/**
 * Model SourceBook
 * 
 */
export type SourceBook = $Result.DefaultSelection<Prisma.$SourceBookPayload>
/**
 * Model ReferenceTable
 * 
 */
export type ReferenceTable = $Result.DefaultSelection<Prisma.$ReferenceTablePayload>
/**
 * Model ReferenceTableColumn
 * 
 */
export type ReferenceTableColumn = $Result.DefaultSelection<Prisma.$ReferenceTableColumnPayload>
/**
 * Model ReferenceTableRow
 * 
 */
export type ReferenceTableRow = $Result.DefaultSelection<Prisma.$ReferenceTableRowPayload>
/**
 * Model ReferenceTableCell
 * 
 */
export type ReferenceTableCell = $Result.DefaultSelection<Prisma.$ReferenceTableCellPayload>
/**
 * Model UserCharacter
 * 
 */
export type UserCharacter = $Result.DefaultSelection<Prisma.$UserCharacterPayload>
/**
 * Model UserCharacterAttribute
 * 
 */
export type UserCharacterAttribute = $Result.DefaultSelection<Prisma.$UserCharacterAttributePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Classes
 * const classes = await prisma.class.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Classes
   * const classes = await prisma.class.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classFeature`: Exposes CRUD operations for the **ClassFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassFeatures
    * const classFeatures = await prisma.classFeature.findMany()
    * ```
    */
  get classFeature(): Prisma.ClassFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classSpellLevel`: Exposes CRUD operations for the **ClassSpellLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSpellLevels
    * const classSpellLevels = await prisma.classSpellLevel.findMany()
    * ```
    */
  get classSpellLevel(): Prisma.ClassSpellLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classLevelAttribute`: Exposes CRUD operations for the **ClassLevelAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassLevelAttributes
    * const classLevelAttributes = await prisma.classLevelAttribute.findMany()
    * ```
    */
  get classLevelAttribute(): Prisma.ClassLevelAttributeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classSkillMap`: Exposes CRUD operations for the **ClassSkillMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSkillMaps
    * const classSkillMaps = await prisma.classSkillMap.findMany()
    * ```
    */
  get classSkillMap(): Prisma.ClassSkillMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classSourceMap`: Exposes CRUD operations for the **ClassSourceMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSourceMaps
    * const classSourceMaps = await prisma.classSourceMap.findMany()
    * ```
    */
  get classSourceMap(): Prisma.ClassSourceMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spellLevelMap`: Exposes CRUD operations for the **SpellLevelMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellLevelMaps
    * const spellLevelMaps = await prisma.spellLevelMap.findMany()
    * ```
    */
  get spellLevelMap(): Prisma.SpellLevelMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spell`: Exposes CRUD operations for the **Spell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spells
    * const spells = await prisma.spell.findMany()
    * ```
    */
  get spell(): Prisma.SpellDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spellDescriptorMap`: Exposes CRUD operations for the **SpellDescriptorMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellDescriptorMaps
    * const spellDescriptorMaps = await prisma.spellDescriptorMap.findMany()
    * ```
    */
  get spellDescriptorMap(): Prisma.SpellDescriptorMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spellSchoolMap`: Exposes CRUD operations for the **SpellSchoolMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellSchoolMaps
    * const spellSchoolMaps = await prisma.spellSchoolMap.findMany()
    * ```
    */
  get spellSchoolMap(): Prisma.SpellSchoolMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spellSourceMap`: Exposes CRUD operations for the **SpellSourceMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellSourceMaps
    * const spellSourceMaps = await prisma.spellSourceMap.findMany()
    * ```
    */
  get spellSourceMap(): Prisma.SpellSourceMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spellSubschoolMap`: Exposes CRUD operations for the **SpellSubschoolMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellSubschoolMaps
    * const spellSubschoolMaps = await prisma.spellSubschoolMap.findMany()
    * ```
    */
  get spellSubschoolMap(): Prisma.SpellSubschoolMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spellComponentMap`: Exposes CRUD operations for the **SpellComponentMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellComponentMaps
    * const spellComponentMaps = await prisma.spellComponentMap.findMany()
    * ```
    */
  get spellComponentMap(): Prisma.SpellComponentMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feat`: Exposes CRUD operations for the **Feat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feats
    * const feats = await prisma.feat.findMany()
    * ```
    */
  get feat(): Prisma.FeatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featBenefitMap`: Exposes CRUD operations for the **FeatBenefitMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatBenefitMaps
    * const featBenefitMaps = await prisma.featBenefitMap.findMany()
    * ```
    */
  get featBenefitMap(): Prisma.FeatBenefitMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featPrerequisiteMap`: Exposes CRUD operations for the **FeatPrerequisiteMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatPrerequisiteMaps
    * const featPrerequisiteMaps = await prisma.featPrerequisiteMap.findMany()
    * ```
    */
  get featPrerequisiteMap(): Prisma.FeatPrerequisiteMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.race`: Exposes CRUD operations for the **Race** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Races
    * const races = await prisma.race.findMany()
    * ```
    */
  get race(): Prisma.RaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raceTrait`: Exposes CRUD operations for the **RaceTrait** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceTraits
    * const raceTraits = await prisma.raceTrait.findMany()
    * ```
    */
  get raceTrait(): Prisma.RaceTraitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raceTraitMap`: Exposes CRUD operations for the **RaceTraitMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceTraitMaps
    * const raceTraitMaps = await prisma.raceTraitMap.findMany()
    * ```
    */
  get raceTraitMap(): Prisma.RaceTraitMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raceAbilityAdjustment`: Exposes CRUD operations for the **RaceAbilityAdjustment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceAbilityAdjustments
    * const raceAbilityAdjustments = await prisma.raceAbilityAdjustment.findMany()
    * ```
    */
  get raceAbilityAdjustment(): Prisma.RaceAbilityAdjustmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raceLanguageMap`: Exposes CRUD operations for the **RaceLanguageMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceLanguageMaps
    * const raceLanguageMaps = await prisma.raceLanguageMap.findMany()
    * ```
    */
  get raceLanguageMap(): Prisma.RaceLanguageMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raceSourceMap`: Exposes CRUD operations for the **RaceSourceMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceSourceMaps
    * const raceSourceMaps = await prisma.raceSourceMap.findMany()
    * ```
    */
  get raceSourceMap(): Prisma.RaceSourceMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.armor`: Exposes CRUD operations for the **Armor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Armors
    * const armors = await prisma.armor.findMany()
    * ```
    */
  get armor(): Prisma.ArmorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weapon`: Exposes CRUD operations for the **Weapon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weapons
    * const weapons = await prisma.weapon.findMany()
    * ```
    */
  get weapon(): Prisma.WeaponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sourceBook`: Exposes CRUD operations for the **SourceBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SourceBooks
    * const sourceBooks = await prisma.sourceBook.findMany()
    * ```
    */
  get sourceBook(): Prisma.SourceBookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referenceTable`: Exposes CRUD operations for the **ReferenceTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferenceTables
    * const referenceTables = await prisma.referenceTable.findMany()
    * ```
    */
  get referenceTable(): Prisma.ReferenceTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referenceTableColumn`: Exposes CRUD operations for the **ReferenceTableColumn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferenceTableColumns
    * const referenceTableColumns = await prisma.referenceTableColumn.findMany()
    * ```
    */
  get referenceTableColumn(): Prisma.ReferenceTableColumnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referenceTableRow`: Exposes CRUD operations for the **ReferenceTableRow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferenceTableRows
    * const referenceTableRows = await prisma.referenceTableRow.findMany()
    * ```
    */
  get referenceTableRow(): Prisma.ReferenceTableRowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referenceTableCell`: Exposes CRUD operations for the **ReferenceTableCell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferenceTableCells
    * const referenceTableCells = await prisma.referenceTableCell.findMany()
    * ```
    */
  get referenceTableCell(): Prisma.ReferenceTableCellDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCharacter`: Exposes CRUD operations for the **UserCharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCharacters
    * const userCharacters = await prisma.userCharacter.findMany()
    * ```
    */
  get userCharacter(): Prisma.UserCharacterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCharacterAttribute`: Exposes CRUD operations for the **UserCharacterAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCharacterAttributes
    * const userCharacterAttributes = await prisma.userCharacterAttribute.findMany()
    * ```
    */
  get userCharacterAttribute(): Prisma.UserCharacterAttributeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Class: 'Class',
    ClassFeature: 'ClassFeature',
    ClassSpellLevel: 'ClassSpellLevel',
    ClassLevelAttribute: 'ClassLevelAttribute',
    ClassSkillMap: 'ClassSkillMap',
    ClassSourceMap: 'ClassSourceMap',
    SpellLevelMap: 'SpellLevelMap',
    Spell: 'Spell',
    SpellDescriptorMap: 'SpellDescriptorMap',
    SpellSchoolMap: 'SpellSchoolMap',
    SpellSourceMap: 'SpellSourceMap',
    SpellSubschoolMap: 'SpellSubschoolMap',
    SpellComponentMap: 'SpellComponentMap',
    Skill: 'Skill',
    Feat: 'Feat',
    FeatBenefitMap: 'FeatBenefitMap',
    FeatPrerequisiteMap: 'FeatPrerequisiteMap',
    Race: 'Race',
    RaceTrait: 'RaceTrait',
    RaceTraitMap: 'RaceTraitMap',
    RaceAbilityAdjustment: 'RaceAbilityAdjustment',
    RaceLanguageMap: 'RaceLanguageMap',
    RaceSourceMap: 'RaceSourceMap',
    Armor: 'Armor',
    Weapon: 'Weapon',
    SourceBook: 'SourceBook',
    ReferenceTable: 'ReferenceTable',
    ReferenceTableColumn: 'ReferenceTableColumn',
    ReferenceTableRow: 'ReferenceTableRow',
    ReferenceTableCell: 'ReferenceTableCell',
    UserCharacter: 'UserCharacter',
    UserCharacterAttribute: 'UserCharacterAttribute',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "class" | "classFeature" | "classSpellLevel" | "classLevelAttribute" | "classSkillMap" | "classSourceMap" | "spellLevelMap" | "spell" | "spellDescriptorMap" | "spellSchoolMap" | "spellSourceMap" | "spellSubschoolMap" | "spellComponentMap" | "skill" | "feat" | "featBenefitMap" | "featPrerequisiteMap" | "race" | "raceTrait" | "raceTraitMap" | "raceAbilityAdjustment" | "raceLanguageMap" | "raceSourceMap" | "armor" | "weapon" | "sourceBook" | "referenceTable" | "referenceTableColumn" | "referenceTableRow" | "referenceTableCell" | "userCharacter" | "userCharacterAttribute" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      ClassFeature: {
        payload: Prisma.$ClassFeaturePayload<ExtArgs>
        fields: Prisma.ClassFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          findFirst: {
            args: Prisma.ClassFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          findMany: {
            args: Prisma.ClassFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>[]
          }
          create: {
            args: Prisma.ClassFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          createMany: {
            args: Prisma.ClassFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          update: {
            args: Prisma.ClassFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          deleteMany: {
            args: Prisma.ClassFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          aggregate: {
            args: Prisma.ClassFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassFeature>
          }
          groupBy: {
            args: Prisma.ClassFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<ClassFeatureCountAggregateOutputType> | number
          }
        }
      }
      ClassSpellLevel: {
        payload: Prisma.$ClassSpellLevelPayload<ExtArgs>
        fields: Prisma.ClassSpellLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassSpellLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSpellLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassSpellLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSpellLevelPayload>
          }
          findFirst: {
            args: Prisma.ClassSpellLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSpellLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassSpellLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSpellLevelPayload>
          }
          findMany: {
            args: Prisma.ClassSpellLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSpellLevelPayload>[]
          }
          create: {
            args: Prisma.ClassSpellLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSpellLevelPayload>
          }
          createMany: {
            args: Prisma.ClassSpellLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassSpellLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSpellLevelPayload>
          }
          update: {
            args: Prisma.ClassSpellLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSpellLevelPayload>
          }
          deleteMany: {
            args: Prisma.ClassSpellLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassSpellLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassSpellLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSpellLevelPayload>
          }
          aggregate: {
            args: Prisma.ClassSpellLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassSpellLevel>
          }
          groupBy: {
            args: Prisma.ClassSpellLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassSpellLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassSpellLevelCountArgs<ExtArgs>
            result: $Utils.Optional<ClassSpellLevelCountAggregateOutputType> | number
          }
        }
      }
      ClassLevelAttribute: {
        payload: Prisma.$ClassLevelAttributePayload<ExtArgs>
        fields: Prisma.ClassLevelAttributeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassLevelAttributeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassLevelAttributePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassLevelAttributeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassLevelAttributePayload>
          }
          findFirst: {
            args: Prisma.ClassLevelAttributeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassLevelAttributePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassLevelAttributeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassLevelAttributePayload>
          }
          findMany: {
            args: Prisma.ClassLevelAttributeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassLevelAttributePayload>[]
          }
          create: {
            args: Prisma.ClassLevelAttributeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassLevelAttributePayload>
          }
          createMany: {
            args: Prisma.ClassLevelAttributeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassLevelAttributeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassLevelAttributePayload>
          }
          update: {
            args: Prisma.ClassLevelAttributeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassLevelAttributePayload>
          }
          deleteMany: {
            args: Prisma.ClassLevelAttributeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassLevelAttributeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassLevelAttributeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassLevelAttributePayload>
          }
          aggregate: {
            args: Prisma.ClassLevelAttributeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassLevelAttribute>
          }
          groupBy: {
            args: Prisma.ClassLevelAttributeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassLevelAttributeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassLevelAttributeCountArgs<ExtArgs>
            result: $Utils.Optional<ClassLevelAttributeCountAggregateOutputType> | number
          }
        }
      }
      ClassSkillMap: {
        payload: Prisma.$ClassSkillMapPayload<ExtArgs>
        fields: Prisma.ClassSkillMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassSkillMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSkillMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassSkillMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSkillMapPayload>
          }
          findFirst: {
            args: Prisma.ClassSkillMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSkillMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassSkillMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSkillMapPayload>
          }
          findMany: {
            args: Prisma.ClassSkillMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSkillMapPayload>[]
          }
          create: {
            args: Prisma.ClassSkillMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSkillMapPayload>
          }
          createMany: {
            args: Prisma.ClassSkillMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassSkillMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSkillMapPayload>
          }
          update: {
            args: Prisma.ClassSkillMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSkillMapPayload>
          }
          deleteMany: {
            args: Prisma.ClassSkillMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassSkillMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassSkillMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSkillMapPayload>
          }
          aggregate: {
            args: Prisma.ClassSkillMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassSkillMap>
          }
          groupBy: {
            args: Prisma.ClassSkillMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassSkillMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassSkillMapCountArgs<ExtArgs>
            result: $Utils.Optional<ClassSkillMapCountAggregateOutputType> | number
          }
        }
      }
      ClassSourceMap: {
        payload: Prisma.$ClassSourceMapPayload<ExtArgs>
        fields: Prisma.ClassSourceMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassSourceMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSourceMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassSourceMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSourceMapPayload>
          }
          findFirst: {
            args: Prisma.ClassSourceMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSourceMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassSourceMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSourceMapPayload>
          }
          findMany: {
            args: Prisma.ClassSourceMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSourceMapPayload>[]
          }
          create: {
            args: Prisma.ClassSourceMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSourceMapPayload>
          }
          createMany: {
            args: Prisma.ClassSourceMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassSourceMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSourceMapPayload>
          }
          update: {
            args: Prisma.ClassSourceMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSourceMapPayload>
          }
          deleteMany: {
            args: Prisma.ClassSourceMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassSourceMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassSourceMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSourceMapPayload>
          }
          aggregate: {
            args: Prisma.ClassSourceMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassSourceMap>
          }
          groupBy: {
            args: Prisma.ClassSourceMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassSourceMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassSourceMapCountArgs<ExtArgs>
            result: $Utils.Optional<ClassSourceMapCountAggregateOutputType> | number
          }
        }
      }
      SpellLevelMap: {
        payload: Prisma.$SpellLevelMapPayload<ExtArgs>
        fields: Prisma.SpellLevelMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellLevelMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellLevelMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellLevelMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellLevelMapPayload>
          }
          findFirst: {
            args: Prisma.SpellLevelMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellLevelMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellLevelMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellLevelMapPayload>
          }
          findMany: {
            args: Prisma.SpellLevelMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellLevelMapPayload>[]
          }
          create: {
            args: Prisma.SpellLevelMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellLevelMapPayload>
          }
          createMany: {
            args: Prisma.SpellLevelMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpellLevelMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellLevelMapPayload>
          }
          update: {
            args: Prisma.SpellLevelMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellLevelMapPayload>
          }
          deleteMany: {
            args: Prisma.SpellLevelMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellLevelMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpellLevelMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellLevelMapPayload>
          }
          aggregate: {
            args: Prisma.SpellLevelMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpellLevelMap>
          }
          groupBy: {
            args: Prisma.SpellLevelMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellLevelMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellLevelMapCountArgs<ExtArgs>
            result: $Utils.Optional<SpellLevelMapCountAggregateOutputType> | number
          }
        }
      }
      Spell: {
        payload: Prisma.$SpellPayload<ExtArgs>
        fields: Prisma.SpellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          findFirst: {
            args: Prisma.SpellFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          findMany: {
            args: Prisma.SpellFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>[]
          }
          create: {
            args: Prisma.SpellCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          createMany: {
            args: Prisma.SpellCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpellDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          update: {
            args: Prisma.SpellUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          deleteMany: {
            args: Prisma.SpellDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpellUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          aggregate: {
            args: Prisma.SpellAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpell>
          }
          groupBy: {
            args: Prisma.SpellGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellCountArgs<ExtArgs>
            result: $Utils.Optional<SpellCountAggregateOutputType> | number
          }
        }
      }
      SpellDescriptorMap: {
        payload: Prisma.$SpellDescriptorMapPayload<ExtArgs>
        fields: Prisma.SpellDescriptorMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellDescriptorMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellDescriptorMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellDescriptorMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellDescriptorMapPayload>
          }
          findFirst: {
            args: Prisma.SpellDescriptorMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellDescriptorMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellDescriptorMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellDescriptorMapPayload>
          }
          findMany: {
            args: Prisma.SpellDescriptorMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellDescriptorMapPayload>[]
          }
          create: {
            args: Prisma.SpellDescriptorMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellDescriptorMapPayload>
          }
          createMany: {
            args: Prisma.SpellDescriptorMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpellDescriptorMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellDescriptorMapPayload>
          }
          update: {
            args: Prisma.SpellDescriptorMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellDescriptorMapPayload>
          }
          deleteMany: {
            args: Prisma.SpellDescriptorMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellDescriptorMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpellDescriptorMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellDescriptorMapPayload>
          }
          aggregate: {
            args: Prisma.SpellDescriptorMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpellDescriptorMap>
          }
          groupBy: {
            args: Prisma.SpellDescriptorMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellDescriptorMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellDescriptorMapCountArgs<ExtArgs>
            result: $Utils.Optional<SpellDescriptorMapCountAggregateOutputType> | number
          }
        }
      }
      SpellSchoolMap: {
        payload: Prisma.$SpellSchoolMapPayload<ExtArgs>
        fields: Prisma.SpellSchoolMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellSchoolMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellSchoolMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolMapPayload>
          }
          findFirst: {
            args: Prisma.SpellSchoolMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellSchoolMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolMapPayload>
          }
          findMany: {
            args: Prisma.SpellSchoolMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolMapPayload>[]
          }
          create: {
            args: Prisma.SpellSchoolMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolMapPayload>
          }
          createMany: {
            args: Prisma.SpellSchoolMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpellSchoolMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolMapPayload>
          }
          update: {
            args: Prisma.SpellSchoolMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolMapPayload>
          }
          deleteMany: {
            args: Prisma.SpellSchoolMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellSchoolMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpellSchoolMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolMapPayload>
          }
          aggregate: {
            args: Prisma.SpellSchoolMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpellSchoolMap>
          }
          groupBy: {
            args: Prisma.SpellSchoolMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellSchoolMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellSchoolMapCountArgs<ExtArgs>
            result: $Utils.Optional<SpellSchoolMapCountAggregateOutputType> | number
          }
        }
      }
      SpellSourceMap: {
        payload: Prisma.$SpellSourceMapPayload<ExtArgs>
        fields: Prisma.SpellSourceMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellSourceMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSourceMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellSourceMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSourceMapPayload>
          }
          findFirst: {
            args: Prisma.SpellSourceMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSourceMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellSourceMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSourceMapPayload>
          }
          findMany: {
            args: Prisma.SpellSourceMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSourceMapPayload>[]
          }
          create: {
            args: Prisma.SpellSourceMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSourceMapPayload>
          }
          createMany: {
            args: Prisma.SpellSourceMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpellSourceMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSourceMapPayload>
          }
          update: {
            args: Prisma.SpellSourceMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSourceMapPayload>
          }
          deleteMany: {
            args: Prisma.SpellSourceMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellSourceMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpellSourceMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSourceMapPayload>
          }
          aggregate: {
            args: Prisma.SpellSourceMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpellSourceMap>
          }
          groupBy: {
            args: Prisma.SpellSourceMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellSourceMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellSourceMapCountArgs<ExtArgs>
            result: $Utils.Optional<SpellSourceMapCountAggregateOutputType> | number
          }
        }
      }
      SpellSubschoolMap: {
        payload: Prisma.$SpellSubschoolMapPayload<ExtArgs>
        fields: Prisma.SpellSubschoolMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellSubschoolMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSubschoolMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellSubschoolMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSubschoolMapPayload>
          }
          findFirst: {
            args: Prisma.SpellSubschoolMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSubschoolMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellSubschoolMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSubschoolMapPayload>
          }
          findMany: {
            args: Prisma.SpellSubschoolMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSubschoolMapPayload>[]
          }
          create: {
            args: Prisma.SpellSubschoolMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSubschoolMapPayload>
          }
          createMany: {
            args: Prisma.SpellSubschoolMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpellSubschoolMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSubschoolMapPayload>
          }
          update: {
            args: Prisma.SpellSubschoolMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSubschoolMapPayload>
          }
          deleteMany: {
            args: Prisma.SpellSubschoolMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellSubschoolMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpellSubschoolMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellSubschoolMapPayload>
          }
          aggregate: {
            args: Prisma.SpellSubschoolMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpellSubschoolMap>
          }
          groupBy: {
            args: Prisma.SpellSubschoolMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellSubschoolMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellSubschoolMapCountArgs<ExtArgs>
            result: $Utils.Optional<SpellSubschoolMapCountAggregateOutputType> | number
          }
        }
      }
      SpellComponentMap: {
        payload: Prisma.$SpellComponentMapPayload<ExtArgs>
        fields: Prisma.SpellComponentMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellComponentMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellComponentMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellComponentMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellComponentMapPayload>
          }
          findFirst: {
            args: Prisma.SpellComponentMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellComponentMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellComponentMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellComponentMapPayload>
          }
          findMany: {
            args: Prisma.SpellComponentMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellComponentMapPayload>[]
          }
          create: {
            args: Prisma.SpellComponentMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellComponentMapPayload>
          }
          createMany: {
            args: Prisma.SpellComponentMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpellComponentMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellComponentMapPayload>
          }
          update: {
            args: Prisma.SpellComponentMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellComponentMapPayload>
          }
          deleteMany: {
            args: Prisma.SpellComponentMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellComponentMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpellComponentMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellComponentMapPayload>
          }
          aggregate: {
            args: Prisma.SpellComponentMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpellComponentMap>
          }
          groupBy: {
            args: Prisma.SpellComponentMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellComponentMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellComponentMapCountArgs<ExtArgs>
            result: $Utils.Optional<SpellComponentMapCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      Feat: {
        payload: Prisma.$FeatPayload<ExtArgs>
        fields: Prisma.FeatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          findFirst: {
            args: Prisma.FeatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          findMany: {
            args: Prisma.FeatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>[]
          }
          create: {
            args: Prisma.FeatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          createMany: {
            args: Prisma.FeatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FeatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          update: {
            args: Prisma.FeatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          deleteMany: {
            args: Prisma.FeatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          aggregate: {
            args: Prisma.FeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeat>
          }
          groupBy: {
            args: Prisma.FeatGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatCountArgs<ExtArgs>
            result: $Utils.Optional<FeatCountAggregateOutputType> | number
          }
        }
      }
      FeatBenefitMap: {
        payload: Prisma.$FeatBenefitMapPayload<ExtArgs>
        fields: Prisma.FeatBenefitMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatBenefitMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatBenefitMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatBenefitMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatBenefitMapPayload>
          }
          findFirst: {
            args: Prisma.FeatBenefitMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatBenefitMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatBenefitMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatBenefitMapPayload>
          }
          findMany: {
            args: Prisma.FeatBenefitMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatBenefitMapPayload>[]
          }
          create: {
            args: Prisma.FeatBenefitMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatBenefitMapPayload>
          }
          createMany: {
            args: Prisma.FeatBenefitMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FeatBenefitMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatBenefitMapPayload>
          }
          update: {
            args: Prisma.FeatBenefitMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatBenefitMapPayload>
          }
          deleteMany: {
            args: Prisma.FeatBenefitMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatBenefitMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeatBenefitMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatBenefitMapPayload>
          }
          aggregate: {
            args: Prisma.FeatBenefitMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatBenefitMap>
          }
          groupBy: {
            args: Prisma.FeatBenefitMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatBenefitMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatBenefitMapCountArgs<ExtArgs>
            result: $Utils.Optional<FeatBenefitMapCountAggregateOutputType> | number
          }
        }
      }
      FeatPrerequisiteMap: {
        payload: Prisma.$FeatPrerequisiteMapPayload<ExtArgs>
        fields: Prisma.FeatPrerequisiteMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatPrerequisiteMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPrerequisiteMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatPrerequisiteMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPrerequisiteMapPayload>
          }
          findFirst: {
            args: Prisma.FeatPrerequisiteMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPrerequisiteMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatPrerequisiteMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPrerequisiteMapPayload>
          }
          findMany: {
            args: Prisma.FeatPrerequisiteMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPrerequisiteMapPayload>[]
          }
          create: {
            args: Prisma.FeatPrerequisiteMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPrerequisiteMapPayload>
          }
          createMany: {
            args: Prisma.FeatPrerequisiteMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FeatPrerequisiteMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPrerequisiteMapPayload>
          }
          update: {
            args: Prisma.FeatPrerequisiteMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPrerequisiteMapPayload>
          }
          deleteMany: {
            args: Prisma.FeatPrerequisiteMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatPrerequisiteMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeatPrerequisiteMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPrerequisiteMapPayload>
          }
          aggregate: {
            args: Prisma.FeatPrerequisiteMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatPrerequisiteMap>
          }
          groupBy: {
            args: Prisma.FeatPrerequisiteMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatPrerequisiteMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatPrerequisiteMapCountArgs<ExtArgs>
            result: $Utils.Optional<FeatPrerequisiteMapCountAggregateOutputType> | number
          }
        }
      }
      Race: {
        payload: Prisma.$RacePayload<ExtArgs>
        fields: Prisma.RaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findFirst: {
            args: Prisma.RaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findMany: {
            args: Prisma.RaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          create: {
            args: Prisma.RaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          createMany: {
            args: Prisma.RaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          update: {
            args: Prisma.RaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          deleteMany: {
            args: Prisma.RaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          aggregate: {
            args: Prisma.RaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRace>
          }
          groupBy: {
            args: Prisma.RaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceCountArgs<ExtArgs>
            result: $Utils.Optional<RaceCountAggregateOutputType> | number
          }
        }
      }
      RaceTrait: {
        payload: Prisma.$RaceTraitPayload<ExtArgs>
        fields: Prisma.RaceTraitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceTraitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceTraitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          findFirst: {
            args: Prisma.RaceTraitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceTraitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          findMany: {
            args: Prisma.RaceTraitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>[]
          }
          create: {
            args: Prisma.RaceTraitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          createMany: {
            args: Prisma.RaceTraitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RaceTraitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          update: {
            args: Prisma.RaceTraitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          deleteMany: {
            args: Prisma.RaceTraitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceTraitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RaceTraitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          aggregate: {
            args: Prisma.RaceTraitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaceTrait>
          }
          groupBy: {
            args: Prisma.RaceTraitGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceTraitGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceTraitCountArgs<ExtArgs>
            result: $Utils.Optional<RaceTraitCountAggregateOutputType> | number
          }
        }
      }
      RaceTraitMap: {
        payload: Prisma.$RaceTraitMapPayload<ExtArgs>
        fields: Prisma.RaceTraitMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceTraitMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceTraitMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitMapPayload>
          }
          findFirst: {
            args: Prisma.RaceTraitMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceTraitMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitMapPayload>
          }
          findMany: {
            args: Prisma.RaceTraitMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitMapPayload>[]
          }
          create: {
            args: Prisma.RaceTraitMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitMapPayload>
          }
          createMany: {
            args: Prisma.RaceTraitMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RaceTraitMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitMapPayload>
          }
          update: {
            args: Prisma.RaceTraitMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitMapPayload>
          }
          deleteMany: {
            args: Prisma.RaceTraitMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceTraitMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RaceTraitMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitMapPayload>
          }
          aggregate: {
            args: Prisma.RaceTraitMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaceTraitMap>
          }
          groupBy: {
            args: Prisma.RaceTraitMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceTraitMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceTraitMapCountArgs<ExtArgs>
            result: $Utils.Optional<RaceTraitMapCountAggregateOutputType> | number
          }
        }
      }
      RaceAbilityAdjustment: {
        payload: Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>
        fields: Prisma.RaceAbilityAdjustmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceAbilityAdjustmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceAbilityAdjustmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceAbilityAdjustmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceAbilityAdjustmentPayload>
          }
          findFirst: {
            args: Prisma.RaceAbilityAdjustmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceAbilityAdjustmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceAbilityAdjustmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceAbilityAdjustmentPayload>
          }
          findMany: {
            args: Prisma.RaceAbilityAdjustmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceAbilityAdjustmentPayload>[]
          }
          create: {
            args: Prisma.RaceAbilityAdjustmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceAbilityAdjustmentPayload>
          }
          createMany: {
            args: Prisma.RaceAbilityAdjustmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RaceAbilityAdjustmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceAbilityAdjustmentPayload>
          }
          update: {
            args: Prisma.RaceAbilityAdjustmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceAbilityAdjustmentPayload>
          }
          deleteMany: {
            args: Prisma.RaceAbilityAdjustmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceAbilityAdjustmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RaceAbilityAdjustmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceAbilityAdjustmentPayload>
          }
          aggregate: {
            args: Prisma.RaceAbilityAdjustmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaceAbilityAdjustment>
          }
          groupBy: {
            args: Prisma.RaceAbilityAdjustmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceAbilityAdjustmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceAbilityAdjustmentCountArgs<ExtArgs>
            result: $Utils.Optional<RaceAbilityAdjustmentCountAggregateOutputType> | number
          }
        }
      }
      RaceLanguageMap: {
        payload: Prisma.$RaceLanguageMapPayload<ExtArgs>
        fields: Prisma.RaceLanguageMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceLanguageMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceLanguageMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceLanguageMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceLanguageMapPayload>
          }
          findFirst: {
            args: Prisma.RaceLanguageMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceLanguageMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceLanguageMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceLanguageMapPayload>
          }
          findMany: {
            args: Prisma.RaceLanguageMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceLanguageMapPayload>[]
          }
          create: {
            args: Prisma.RaceLanguageMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceLanguageMapPayload>
          }
          createMany: {
            args: Prisma.RaceLanguageMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RaceLanguageMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceLanguageMapPayload>
          }
          update: {
            args: Prisma.RaceLanguageMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceLanguageMapPayload>
          }
          deleteMany: {
            args: Prisma.RaceLanguageMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceLanguageMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RaceLanguageMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceLanguageMapPayload>
          }
          aggregate: {
            args: Prisma.RaceLanguageMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaceLanguageMap>
          }
          groupBy: {
            args: Prisma.RaceLanguageMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceLanguageMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceLanguageMapCountArgs<ExtArgs>
            result: $Utils.Optional<RaceLanguageMapCountAggregateOutputType> | number
          }
        }
      }
      RaceSourceMap: {
        payload: Prisma.$RaceSourceMapPayload<ExtArgs>
        fields: Prisma.RaceSourceMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceSourceMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceSourceMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceSourceMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceSourceMapPayload>
          }
          findFirst: {
            args: Prisma.RaceSourceMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceSourceMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceSourceMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceSourceMapPayload>
          }
          findMany: {
            args: Prisma.RaceSourceMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceSourceMapPayload>[]
          }
          create: {
            args: Prisma.RaceSourceMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceSourceMapPayload>
          }
          createMany: {
            args: Prisma.RaceSourceMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RaceSourceMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceSourceMapPayload>
          }
          update: {
            args: Prisma.RaceSourceMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceSourceMapPayload>
          }
          deleteMany: {
            args: Prisma.RaceSourceMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceSourceMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RaceSourceMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceSourceMapPayload>
          }
          aggregate: {
            args: Prisma.RaceSourceMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaceSourceMap>
          }
          groupBy: {
            args: Prisma.RaceSourceMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceSourceMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceSourceMapCountArgs<ExtArgs>
            result: $Utils.Optional<RaceSourceMapCountAggregateOutputType> | number
          }
        }
      }
      Armor: {
        payload: Prisma.$ArmorPayload<ExtArgs>
        fields: Prisma.ArmorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArmorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArmorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          findFirst: {
            args: Prisma.ArmorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArmorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          findMany: {
            args: Prisma.ArmorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>[]
          }
          create: {
            args: Prisma.ArmorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          createMany: {
            args: Prisma.ArmorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ArmorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          update: {
            args: Prisma.ArmorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          deleteMany: {
            args: Prisma.ArmorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArmorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArmorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          aggregate: {
            args: Prisma.ArmorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArmor>
          }
          groupBy: {
            args: Prisma.ArmorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArmorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArmorCountArgs<ExtArgs>
            result: $Utils.Optional<ArmorCountAggregateOutputType> | number
          }
        }
      }
      Weapon: {
        payload: Prisma.$WeaponPayload<ExtArgs>
        fields: Prisma.WeaponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeaponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeaponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          findFirst: {
            args: Prisma.WeaponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeaponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          findMany: {
            args: Prisma.WeaponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>[]
          }
          create: {
            args: Prisma.WeaponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          createMany: {
            args: Prisma.WeaponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WeaponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          update: {
            args: Prisma.WeaponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          deleteMany: {
            args: Prisma.WeaponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeaponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeaponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          aggregate: {
            args: Prisma.WeaponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeapon>
          }
          groupBy: {
            args: Prisma.WeaponGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeaponGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeaponCountArgs<ExtArgs>
            result: $Utils.Optional<WeaponCountAggregateOutputType> | number
          }
        }
      }
      SourceBook: {
        payload: Prisma.$SourceBookPayload<ExtArgs>
        fields: Prisma.SourceBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceBookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceBookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceBookPayload>
          }
          findFirst: {
            args: Prisma.SourceBookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceBookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceBookPayload>
          }
          findMany: {
            args: Prisma.SourceBookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceBookPayload>[]
          }
          create: {
            args: Prisma.SourceBookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceBookPayload>
          }
          createMany: {
            args: Prisma.SourceBookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SourceBookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceBookPayload>
          }
          update: {
            args: Prisma.SourceBookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceBookPayload>
          }
          deleteMany: {
            args: Prisma.SourceBookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceBookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SourceBookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceBookPayload>
          }
          aggregate: {
            args: Prisma.SourceBookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSourceBook>
          }
          groupBy: {
            args: Prisma.SourceBookGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceBookCountArgs<ExtArgs>
            result: $Utils.Optional<SourceBookCountAggregateOutputType> | number
          }
        }
      }
      ReferenceTable: {
        payload: Prisma.$ReferenceTablePayload<ExtArgs>
        fields: Prisma.ReferenceTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferenceTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferenceTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTablePayload>
          }
          findFirst: {
            args: Prisma.ReferenceTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferenceTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTablePayload>
          }
          findMany: {
            args: Prisma.ReferenceTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTablePayload>[]
          }
          create: {
            args: Prisma.ReferenceTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTablePayload>
          }
          createMany: {
            args: Prisma.ReferenceTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReferenceTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTablePayload>
          }
          update: {
            args: Prisma.ReferenceTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTablePayload>
          }
          deleteMany: {
            args: Prisma.ReferenceTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferenceTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferenceTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTablePayload>
          }
          aggregate: {
            args: Prisma.ReferenceTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferenceTable>
          }
          groupBy: {
            args: Prisma.ReferenceTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferenceTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferenceTableCountArgs<ExtArgs>
            result: $Utils.Optional<ReferenceTableCountAggregateOutputType> | number
          }
        }
      }
      ReferenceTableColumn: {
        payload: Prisma.$ReferenceTableColumnPayload<ExtArgs>
        fields: Prisma.ReferenceTableColumnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferenceTableColumnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableColumnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferenceTableColumnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableColumnPayload>
          }
          findFirst: {
            args: Prisma.ReferenceTableColumnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableColumnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferenceTableColumnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableColumnPayload>
          }
          findMany: {
            args: Prisma.ReferenceTableColumnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableColumnPayload>[]
          }
          create: {
            args: Prisma.ReferenceTableColumnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableColumnPayload>
          }
          createMany: {
            args: Prisma.ReferenceTableColumnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReferenceTableColumnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableColumnPayload>
          }
          update: {
            args: Prisma.ReferenceTableColumnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableColumnPayload>
          }
          deleteMany: {
            args: Prisma.ReferenceTableColumnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferenceTableColumnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferenceTableColumnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableColumnPayload>
          }
          aggregate: {
            args: Prisma.ReferenceTableColumnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferenceTableColumn>
          }
          groupBy: {
            args: Prisma.ReferenceTableColumnGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferenceTableColumnGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferenceTableColumnCountArgs<ExtArgs>
            result: $Utils.Optional<ReferenceTableColumnCountAggregateOutputType> | number
          }
        }
      }
      ReferenceTableRow: {
        payload: Prisma.$ReferenceTableRowPayload<ExtArgs>
        fields: Prisma.ReferenceTableRowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferenceTableRowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableRowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferenceTableRowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableRowPayload>
          }
          findFirst: {
            args: Prisma.ReferenceTableRowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableRowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferenceTableRowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableRowPayload>
          }
          findMany: {
            args: Prisma.ReferenceTableRowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableRowPayload>[]
          }
          create: {
            args: Prisma.ReferenceTableRowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableRowPayload>
          }
          createMany: {
            args: Prisma.ReferenceTableRowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReferenceTableRowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableRowPayload>
          }
          update: {
            args: Prisma.ReferenceTableRowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableRowPayload>
          }
          deleteMany: {
            args: Prisma.ReferenceTableRowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferenceTableRowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferenceTableRowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableRowPayload>
          }
          aggregate: {
            args: Prisma.ReferenceTableRowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferenceTableRow>
          }
          groupBy: {
            args: Prisma.ReferenceTableRowGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferenceTableRowGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferenceTableRowCountArgs<ExtArgs>
            result: $Utils.Optional<ReferenceTableRowCountAggregateOutputType> | number
          }
        }
      }
      ReferenceTableCell: {
        payload: Prisma.$ReferenceTableCellPayload<ExtArgs>
        fields: Prisma.ReferenceTableCellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferenceTableCellFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableCellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferenceTableCellFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableCellPayload>
          }
          findFirst: {
            args: Prisma.ReferenceTableCellFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableCellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferenceTableCellFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableCellPayload>
          }
          findMany: {
            args: Prisma.ReferenceTableCellFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableCellPayload>[]
          }
          create: {
            args: Prisma.ReferenceTableCellCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableCellPayload>
          }
          createMany: {
            args: Prisma.ReferenceTableCellCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReferenceTableCellDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableCellPayload>
          }
          update: {
            args: Prisma.ReferenceTableCellUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableCellPayload>
          }
          deleteMany: {
            args: Prisma.ReferenceTableCellDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferenceTableCellUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferenceTableCellUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferenceTableCellPayload>
          }
          aggregate: {
            args: Prisma.ReferenceTableCellAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferenceTableCell>
          }
          groupBy: {
            args: Prisma.ReferenceTableCellGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferenceTableCellGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferenceTableCellCountArgs<ExtArgs>
            result: $Utils.Optional<ReferenceTableCellCountAggregateOutputType> | number
          }
        }
      }
      UserCharacter: {
        payload: Prisma.$UserCharacterPayload<ExtArgs>
        fields: Prisma.UserCharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterPayload>
          }
          findFirst: {
            args: Prisma.UserCharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterPayload>
          }
          findMany: {
            args: Prisma.UserCharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterPayload>[]
          }
          create: {
            args: Prisma.UserCharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterPayload>
          }
          createMany: {
            args: Prisma.UserCharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserCharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterPayload>
          }
          update: {
            args: Prisma.UserCharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterPayload>
          }
          deleteMany: {
            args: Prisma.UserCharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserCharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterPayload>
          }
          aggregate: {
            args: Prisma.UserCharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCharacter>
          }
          groupBy: {
            args: Prisma.UserCharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCharacterCountArgs<ExtArgs>
            result: $Utils.Optional<UserCharacterCountAggregateOutputType> | number
          }
        }
      }
      UserCharacterAttribute: {
        payload: Prisma.$UserCharacterAttributePayload<ExtArgs>
        fields: Prisma.UserCharacterAttributeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCharacterAttributeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterAttributePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCharacterAttributeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterAttributePayload>
          }
          findFirst: {
            args: Prisma.UserCharacterAttributeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterAttributePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCharacterAttributeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterAttributePayload>
          }
          findMany: {
            args: Prisma.UserCharacterAttributeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterAttributePayload>[]
          }
          create: {
            args: Prisma.UserCharacterAttributeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterAttributePayload>
          }
          createMany: {
            args: Prisma.UserCharacterAttributeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserCharacterAttributeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterAttributePayload>
          }
          update: {
            args: Prisma.UserCharacterAttributeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterAttributePayload>
          }
          deleteMany: {
            args: Prisma.UserCharacterAttributeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCharacterAttributeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserCharacterAttributeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCharacterAttributePayload>
          }
          aggregate: {
            args: Prisma.UserCharacterAttributeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCharacterAttribute>
          }
          groupBy: {
            args: Prisma.UserCharacterAttributeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCharacterAttributeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCharacterAttributeCountArgs<ExtArgs>
            result: $Utils.Optional<UserCharacterAttributeCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    class?: ClassOmit
    classFeature?: ClassFeatureOmit
    classSpellLevel?: ClassSpellLevelOmit
    classLevelAttribute?: ClassLevelAttributeOmit
    classSkillMap?: ClassSkillMapOmit
    classSourceMap?: ClassSourceMapOmit
    spellLevelMap?: SpellLevelMapOmit
    spell?: SpellOmit
    spellDescriptorMap?: SpellDescriptorMapOmit
    spellSchoolMap?: SpellSchoolMapOmit
    spellSourceMap?: SpellSourceMapOmit
    spellSubschoolMap?: SpellSubschoolMapOmit
    spellComponentMap?: SpellComponentMapOmit
    skill?: SkillOmit
    feat?: FeatOmit
    featBenefitMap?: FeatBenefitMapOmit
    featPrerequisiteMap?: FeatPrerequisiteMapOmit
    race?: RaceOmit
    raceTrait?: RaceTraitOmit
    raceTraitMap?: RaceTraitMapOmit
    raceAbilityAdjustment?: RaceAbilityAdjustmentOmit
    raceLanguageMap?: RaceLanguageMapOmit
    raceSourceMap?: RaceSourceMapOmit
    armor?: ArmorOmit
    weapon?: WeaponOmit
    sourceBook?: SourceBookOmit
    referenceTable?: ReferenceTableOmit
    referenceTableColumn?: ReferenceTableColumnOmit
    referenceTableRow?: ReferenceTableRowOmit
    referenceTableCell?: ReferenceTableCellOmit
    userCharacter?: UserCharacterOmit
    userCharacterAttribute?: UserCharacterAttributeOmit
    user?: UserOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    features: number
    attributes: number
    spellProgression: number
    skills: number
    sources: number
    spellLevels: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | ClassCountOutputTypeCountFeaturesArgs
    attributes?: boolean | ClassCountOutputTypeCountAttributesArgs
    spellProgression?: boolean | ClassCountOutputTypeCountSpellProgressionArgs
    skills?: boolean | ClassCountOutputTypeCountSkillsArgs
    sources?: boolean | ClassCountOutputTypeCountSourcesArgs
    spellLevels?: boolean | ClassCountOutputTypeCountSpellLevelsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassFeatureWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassLevelAttributeWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSpellProgressionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSpellLevelWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSkillMapWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSourceMapWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSpellLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellLevelMapWhereInput
  }


  /**
   * Count Type SpellCountOutputType
   */

  export type SpellCountOutputType = {
    descriptors: number
    levelMapping: number
    schools: number
    sources: number
    subschools: number
  }

  export type SpellCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    descriptors?: boolean | SpellCountOutputTypeCountDescriptorsArgs
    levelMapping?: boolean | SpellCountOutputTypeCountLevelMappingArgs
    schools?: boolean | SpellCountOutputTypeCountSchoolsArgs
    sources?: boolean | SpellCountOutputTypeCountSourcesArgs
    subschools?: boolean | SpellCountOutputTypeCountSubschoolsArgs
  }

  // Custom InputTypes
  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellCountOutputType
     */
    select?: SpellCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountDescriptorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellDescriptorMapWhereInput
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountLevelMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellLevelMapWhereInput
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellSchoolMapWhereInput
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellSourceMapWhereInput
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountSubschoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellSubschoolMapWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    classes: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | SkillCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSkillMapWhereInput
  }


  /**
   * Count Type FeatCountOutputType
   */

  export type FeatCountOutputType = {
    benefits: number
    prerequisitesMap: number
  }

  export type FeatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benefits?: boolean | FeatCountOutputTypeCountBenefitsArgs
    prerequisitesMap?: boolean | FeatCountOutputTypeCountPrerequisitesMapArgs
  }

  // Custom InputTypes
  /**
   * FeatCountOutputType without action
   */
  export type FeatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatCountOutputType
     */
    select?: FeatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeatCountOutputType without action
   */
  export type FeatCountOutputTypeCountBenefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatBenefitMapWhereInput
  }

  /**
   * FeatCountOutputType without action
   */
  export type FeatCountOutputTypeCountPrerequisitesMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatPrerequisiteMapWhereInput
  }


  /**
   * Count Type RaceCountOutputType
   */

  export type RaceCountOutputType = {
    abilityAdjustments: number
    languages: number
    sources: number
    traits: number
    UserCharacter: number
  }

  export type RaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilityAdjustments?: boolean | RaceCountOutputTypeCountAbilityAdjustmentsArgs
    languages?: boolean | RaceCountOutputTypeCountLanguagesArgs
    sources?: boolean | RaceCountOutputTypeCountSourcesArgs
    traits?: boolean | RaceCountOutputTypeCountTraitsArgs
    UserCharacter?: boolean | RaceCountOutputTypeCountUserCharacterArgs
  }

  // Custom InputTypes
  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceCountOutputType
     */
    select?: RaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountAbilityAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceAbilityAdjustmentWhereInput
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceLanguageMapWhereInput
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceSourceMapWhereInput
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceTraitMapWhereInput
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountUserCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCharacterWhereInput
  }


  /**
   * Count Type RaceTraitCountOutputType
   */

  export type RaceTraitCountOutputType = {
    raceLinks: number
  }

  export type RaceTraitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raceLinks?: boolean | RaceTraitCountOutputTypeCountRaceLinksArgs
  }

  // Custom InputTypes
  /**
   * RaceTraitCountOutputType without action
   */
  export type RaceTraitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitCountOutputType
     */
    select?: RaceTraitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaceTraitCountOutputType without action
   */
  export type RaceTraitCountOutputTypeCountRaceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceTraitMapWhereInput
  }


  /**
   * Count Type SourceBookCountOutputType
   */

  export type SourceBookCountOutputType = {
    classes: number
    races: number
    spells: number
  }

  export type SourceBookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | SourceBookCountOutputTypeCountClassesArgs
    races?: boolean | SourceBookCountOutputTypeCountRacesArgs
    spells?: boolean | SourceBookCountOutputTypeCountSpellsArgs
  }

  // Custom InputTypes
  /**
   * SourceBookCountOutputType without action
   */
  export type SourceBookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBookCountOutputType
     */
    select?: SourceBookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SourceBookCountOutputType without action
   */
  export type SourceBookCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSourceMapWhereInput
  }

  /**
   * SourceBookCountOutputType without action
   */
  export type SourceBookCountOutputTypeCountRacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceSourceMapWhereInput
  }

  /**
   * SourceBookCountOutputType without action
   */
  export type SourceBookCountOutputTypeCountSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellSourceMapWhereInput
  }


  /**
   * Count Type ReferenceTableCountOutputType
   */

  export type ReferenceTableCountOutputType = {
    columns: number
    rows: number
  }

  export type ReferenceTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    columns?: boolean | ReferenceTableCountOutputTypeCountColumnsArgs
    rows?: boolean | ReferenceTableCountOutputTypeCountRowsArgs
  }

  // Custom InputTypes
  /**
   * ReferenceTableCountOutputType without action
   */
  export type ReferenceTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCountOutputType
     */
    select?: ReferenceTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReferenceTableCountOutputType without action
   */
  export type ReferenceTableCountOutputTypeCountColumnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceTableColumnWhereInput
  }

  /**
   * ReferenceTableCountOutputType without action
   */
  export type ReferenceTableCountOutputTypeCountRowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceTableRowWhereInput
  }


  /**
   * Count Type ReferenceTableColumnCountOutputType
   */

  export type ReferenceTableColumnCountOutputType = {
    cells: number
  }

  export type ReferenceTableColumnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cells?: boolean | ReferenceTableColumnCountOutputTypeCountCellsArgs
  }

  // Custom InputTypes
  /**
   * ReferenceTableColumnCountOutputType without action
   */
  export type ReferenceTableColumnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumnCountOutputType
     */
    select?: ReferenceTableColumnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReferenceTableColumnCountOutputType without action
   */
  export type ReferenceTableColumnCountOutputTypeCountCellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceTableCellWhereInput
  }


  /**
   * Count Type ReferenceTableRowCountOutputType
   */

  export type ReferenceTableRowCountOutputType = {
    cells: number
  }

  export type ReferenceTableRowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cells?: boolean | ReferenceTableRowCountOutputTypeCountCellsArgs
  }

  // Custom InputTypes
  /**
   * ReferenceTableRowCountOutputType without action
   */
  export type ReferenceTableRowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRowCountOutputType
     */
    select?: ReferenceTableRowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReferenceTableRowCountOutputType without action
   */
  export type ReferenceTableRowCountOutputTypeCountCellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceTableCellWhereInput
  }


  /**
   * Count Type UserCharacterCountOutputType
   */

  export type UserCharacterCountOutputType = {
    attributes: number
  }

  export type UserCharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributes?: boolean | UserCharacterCountOutputTypeCountAttributesArgs
  }

  // Custom InputTypes
  /**
   * UserCharacterCountOutputType without action
   */
  export type UserCharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterCountOutputType
     */
    select?: UserCharacterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCharacterCountOutputType without action
   */
  export type UserCharacterCountOutputTypeCountAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCharacterAttributeWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    characters: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | UserCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCharacterWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    id: number | null
    editionId: number | null
    hitDie: number | null
    skillPoints: number | null
    castingAbilityId: number | null
  }

  export type ClassSumAggregateOutputType = {
    id: number | null
    editionId: number | null
    hitDie: number | null
    skillPoints: number | null
    castingAbilityId: number | null
  }

  export type ClassMinAggregateOutputType = {
    id: number | null
    name: string | null
    abbreviation: string | null
    editionId: number | null
    isPrestige: boolean | null
    isVisible: boolean | null
    canCastSpells: boolean | null
    hitDie: number | null
    description: string | null
    skillPoints: number | null
    castingAbilityId: number | null
  }

  export type ClassMaxAggregateOutputType = {
    id: number | null
    name: string | null
    abbreviation: string | null
    editionId: number | null
    isPrestige: boolean | null
    isVisible: boolean | null
    canCastSpells: boolean | null
    hitDie: number | null
    description: string | null
    skillPoints: number | null
    castingAbilityId: number | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    abbreviation: number
    editionId: number
    isPrestige: number
    isVisible: number
    canCastSpells: number
    hitDie: number
    description: number
    skillPoints: number
    castingAbilityId: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    id?: true
    editionId?: true
    hitDie?: true
    skillPoints?: true
    castingAbilityId?: true
  }

  export type ClassSumAggregateInputType = {
    id?: true
    editionId?: true
    hitDie?: true
    skillPoints?: true
    castingAbilityId?: true
  }

  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    editionId?: true
    isPrestige?: true
    isVisible?: true
    canCastSpells?: true
    hitDie?: true
    description?: true
    skillPoints?: true
    castingAbilityId?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    editionId?: true
    isPrestige?: true
    isVisible?: true
    canCastSpells?: true
    hitDie?: true
    description?: true
    skillPoints?: true
    castingAbilityId?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    editionId?: true
    isPrestige?: true
    isVisible?: true
    canCastSpells?: true
    hitDie?: true
    description?: true
    skillPoints?: true
    castingAbilityId?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: number
    name: string
    abbreviation: string
    editionId: number | null
    isPrestige: boolean
    isVisible: boolean
    canCastSpells: boolean
    hitDie: number
    description: string | null
    skillPoints: number
    castingAbilityId: number | null
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbreviation?: boolean
    editionId?: boolean
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: boolean
    description?: boolean
    skillPoints?: boolean
    castingAbilityId?: boolean
    features?: boolean | Class$featuresArgs<ExtArgs>
    attributes?: boolean | Class$attributesArgs<ExtArgs>
    spellProgression?: boolean | Class$spellProgressionArgs<ExtArgs>
    skills?: boolean | Class$skillsArgs<ExtArgs>
    sources?: boolean | Class$sourcesArgs<ExtArgs>
    spellLevels?: boolean | Class$spellLevelsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>



  export type ClassSelectScalar = {
    id?: boolean
    name?: boolean
    abbreviation?: boolean
    editionId?: boolean
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: boolean
    description?: boolean
    skillPoints?: boolean
    castingAbilityId?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbreviation" | "editionId" | "isPrestige" | "isVisible" | "canCastSpells" | "hitDie" | "description" | "skillPoints" | "castingAbilityId", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | Class$featuresArgs<ExtArgs>
    attributes?: boolean | Class$attributesArgs<ExtArgs>
    spellProgression?: boolean | Class$spellProgressionArgs<ExtArgs>
    skills?: boolean | Class$skillsArgs<ExtArgs>
    sources?: boolean | Class$sourcesArgs<ExtArgs>
    spellLevels?: boolean | Class$spellLevelsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      features: Prisma.$ClassFeaturePayload<ExtArgs>[]
      attributes: Prisma.$ClassLevelAttributePayload<ExtArgs>[]
      spellProgression: Prisma.$ClassSpellLevelPayload<ExtArgs>[]
      skills: Prisma.$ClassSkillMapPayload<ExtArgs>[]
      sources: Prisma.$ClassSourceMapPayload<ExtArgs>[]
      spellLevels: Prisma.$SpellLevelMapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      abbreviation: string
      editionId: number | null
      isPrestige: boolean
      isVisible: boolean
      canCastSpells: boolean
      hitDie: number
      description: string | null
      skillPoints: number
      castingAbilityId: number | null
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends Class$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Class$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attributes<T extends Class$attributesArgs<ExtArgs> = {}>(args?: Subset<T, Class$attributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassLevelAttributePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spellProgression<T extends Class$spellProgressionArgs<ExtArgs> = {}>(args?: Subset<T, Class$spellProgressionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSpellLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skills<T extends Class$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Class$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSkillMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sources<T extends Class$sourcesArgs<ExtArgs> = {}>(args?: Subset<T, Class$sourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSourceMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spellLevels<T extends Class$spellLevelsArgs<ExtArgs> = {}>(args?: Subset<T, Class$spellLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellLevelMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'Int'>
    readonly name: FieldRef<"Class", 'String'>
    readonly abbreviation: FieldRef<"Class", 'String'>
    readonly editionId: FieldRef<"Class", 'Int'>
    readonly isPrestige: FieldRef<"Class", 'Boolean'>
    readonly isVisible: FieldRef<"Class", 'Boolean'>
    readonly canCastSpells: FieldRef<"Class", 'Boolean'>
    readonly hitDie: FieldRef<"Class", 'Int'>
    readonly description: FieldRef<"Class", 'String'>
    readonly skillPoints: FieldRef<"Class", 'Int'>
    readonly castingAbilityId: FieldRef<"Class", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.features
   */
  export type Class$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    where?: ClassFeatureWhereInput
    orderBy?: ClassFeatureOrderByWithRelationInput | ClassFeatureOrderByWithRelationInput[]
    cursor?: ClassFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassFeatureScalarFieldEnum | ClassFeatureScalarFieldEnum[]
  }

  /**
   * Class.attributes
   */
  export type Class$attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassLevelAttribute
     */
    select?: ClassLevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassLevelAttribute
     */
    omit?: ClassLevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassLevelAttributeInclude<ExtArgs> | null
    where?: ClassLevelAttributeWhereInput
    orderBy?: ClassLevelAttributeOrderByWithRelationInput | ClassLevelAttributeOrderByWithRelationInput[]
    cursor?: ClassLevelAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassLevelAttributeScalarFieldEnum | ClassLevelAttributeScalarFieldEnum[]
  }

  /**
   * Class.spellProgression
   */
  export type Class$spellProgressionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSpellLevel
     */
    select?: ClassSpellLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSpellLevel
     */
    omit?: ClassSpellLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSpellLevelInclude<ExtArgs> | null
    where?: ClassSpellLevelWhereInput
    orderBy?: ClassSpellLevelOrderByWithRelationInput | ClassSpellLevelOrderByWithRelationInput[]
    cursor?: ClassSpellLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSpellLevelScalarFieldEnum | ClassSpellLevelScalarFieldEnum[]
  }

  /**
   * Class.skills
   */
  export type Class$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
    where?: ClassSkillMapWhereInput
    orderBy?: ClassSkillMapOrderByWithRelationInput | ClassSkillMapOrderByWithRelationInput[]
    cursor?: ClassSkillMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSkillMapScalarFieldEnum | ClassSkillMapScalarFieldEnum[]
  }

  /**
   * Class.sources
   */
  export type Class$sourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
    where?: ClassSourceMapWhereInput
    orderBy?: ClassSourceMapOrderByWithRelationInput | ClassSourceMapOrderByWithRelationInput[]
    cursor?: ClassSourceMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSourceMapScalarFieldEnum | ClassSourceMapScalarFieldEnum[]
  }

  /**
   * Class.spellLevels
   */
  export type Class$spellLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
    where?: SpellLevelMapWhereInput
    orderBy?: SpellLevelMapOrderByWithRelationInput | SpellLevelMapOrderByWithRelationInput[]
    cursor?: SpellLevelMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellLevelMapScalarFieldEnum | SpellLevelMapScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model ClassFeature
   */

  export type AggregateClassFeature = {
    _count: ClassFeatureCountAggregateOutputType | null
    _avg: ClassFeatureAvgAggregateOutputType | null
    _sum: ClassFeatureSumAggregateOutputType | null
    _min: ClassFeatureMinAggregateOutputType | null
    _max: ClassFeatureMaxAggregateOutputType | null
  }

  export type ClassFeatureAvgAggregateOutputType = {
    id: number | null
    classId: number | null
    level: number | null
  }

  export type ClassFeatureSumAggregateOutputType = {
    id: number | null
    classId: number | null
    level: number | null
  }

  export type ClassFeatureMinAggregateOutputType = {
    id: number | null
    classId: number | null
    name: string | null
    description: string | null
    level: number | null
  }

  export type ClassFeatureMaxAggregateOutputType = {
    id: number | null
    classId: number | null
    name: string | null
    description: string | null
    level: number | null
  }

  export type ClassFeatureCountAggregateOutputType = {
    id: number
    classId: number
    name: number
    description: number
    level: number
    _all: number
  }


  export type ClassFeatureAvgAggregateInputType = {
    id?: true
    classId?: true
    level?: true
  }

  export type ClassFeatureSumAggregateInputType = {
    id?: true
    classId?: true
    level?: true
  }

  export type ClassFeatureMinAggregateInputType = {
    id?: true
    classId?: true
    name?: true
    description?: true
    level?: true
  }

  export type ClassFeatureMaxAggregateInputType = {
    id?: true
    classId?: true
    name?: true
    description?: true
    level?: true
  }

  export type ClassFeatureCountAggregateInputType = {
    id?: true
    classId?: true
    name?: true
    description?: true
    level?: true
    _all?: true
  }

  export type ClassFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassFeature to aggregate.
     */
    where?: ClassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassFeatures to fetch.
     */
    orderBy?: ClassFeatureOrderByWithRelationInput | ClassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassFeatures
    **/
    _count?: true | ClassFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassFeatureMaxAggregateInputType
  }

  export type GetClassFeatureAggregateType<T extends ClassFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateClassFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassFeature[P]>
      : GetScalarType<T[P], AggregateClassFeature[P]>
  }




  export type ClassFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassFeatureWhereInput
    orderBy?: ClassFeatureOrderByWithAggregationInput | ClassFeatureOrderByWithAggregationInput[]
    by: ClassFeatureScalarFieldEnum[] | ClassFeatureScalarFieldEnum
    having?: ClassFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassFeatureCountAggregateInputType | true
    _avg?: ClassFeatureAvgAggregateInputType
    _sum?: ClassFeatureSumAggregateInputType
    _min?: ClassFeatureMinAggregateInputType
    _max?: ClassFeatureMaxAggregateInputType
  }

  export type ClassFeatureGroupByOutputType = {
    id: number
    classId: number
    name: string
    description: string | null
    level: number | null
    _count: ClassFeatureCountAggregateOutputType | null
    _avg: ClassFeatureAvgAggregateOutputType | null
    _sum: ClassFeatureSumAggregateOutputType | null
    _min: ClassFeatureMinAggregateOutputType | null
    _max: ClassFeatureMaxAggregateOutputType | null
  }

  type GetClassFeatureGroupByPayload<T extends ClassFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], ClassFeatureGroupByOutputType[P]>
        }
      >
    >


  export type ClassFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classFeature"]>



  export type ClassFeatureSelectScalar = {
    id?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
  }

  export type ClassFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "name" | "description" | "level", ExtArgs["result"]["classFeature"]>
  export type ClassFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $ClassFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassFeature"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classId: number
      name: string
      description: string | null
      level: number | null
    }, ExtArgs["result"]["classFeature"]>
    composites: {}
  }

  type ClassFeatureGetPayload<S extends boolean | null | undefined | ClassFeatureDefaultArgs> = $Result.GetResult<Prisma.$ClassFeaturePayload, S>

  type ClassFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassFeatureCountAggregateInputType | true
    }

  export interface ClassFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassFeature'], meta: { name: 'ClassFeature' } }
    /**
     * Find zero or one ClassFeature that matches the filter.
     * @param {ClassFeatureFindUniqueArgs} args - Arguments to find a ClassFeature
     * @example
     * // Get one ClassFeature
     * const classFeature = await prisma.classFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFeatureFindUniqueArgs>(args: SelectSubset<T, ClassFeatureFindUniqueArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFeatureFindUniqueOrThrowArgs} args - Arguments to find a ClassFeature
     * @example
     * // Get one ClassFeature
     * const classFeature = await prisma.classFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureFindFirstArgs} args - Arguments to find a ClassFeature
     * @example
     * // Get one ClassFeature
     * const classFeature = await prisma.classFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFeatureFindFirstArgs>(args?: SelectSubset<T, ClassFeatureFindFirstArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureFindFirstOrThrowArgs} args - Arguments to find a ClassFeature
     * @example
     * // Get one ClassFeature
     * const classFeature = await prisma.classFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassFeatures
     * const classFeatures = await prisma.classFeature.findMany()
     * 
     * // Get first 10 ClassFeatures
     * const classFeatures = await prisma.classFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classFeatureWithIdOnly = await prisma.classFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFeatureFindManyArgs>(args?: SelectSubset<T, ClassFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassFeature.
     * @param {ClassFeatureCreateArgs} args - Arguments to create a ClassFeature.
     * @example
     * // Create one ClassFeature
     * const ClassFeature = await prisma.classFeature.create({
     *   data: {
     *     // ... data to create a ClassFeature
     *   }
     * })
     * 
     */
    create<T extends ClassFeatureCreateArgs>(args: SelectSubset<T, ClassFeatureCreateArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassFeatures.
     * @param {ClassFeatureCreateManyArgs} args - Arguments to create many ClassFeatures.
     * @example
     * // Create many ClassFeatures
     * const classFeature = await prisma.classFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassFeatureCreateManyArgs>(args?: SelectSubset<T, ClassFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassFeature.
     * @param {ClassFeatureDeleteArgs} args - Arguments to delete one ClassFeature.
     * @example
     * // Delete one ClassFeature
     * const ClassFeature = await prisma.classFeature.delete({
     *   where: {
     *     // ... filter to delete one ClassFeature
     *   }
     * })
     * 
     */
    delete<T extends ClassFeatureDeleteArgs>(args: SelectSubset<T, ClassFeatureDeleteArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassFeature.
     * @param {ClassFeatureUpdateArgs} args - Arguments to update one ClassFeature.
     * @example
     * // Update one ClassFeature
     * const classFeature = await prisma.classFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassFeatureUpdateArgs>(args: SelectSubset<T, ClassFeatureUpdateArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassFeatures.
     * @param {ClassFeatureDeleteManyArgs} args - Arguments to filter ClassFeatures to delete.
     * @example
     * // Delete a few ClassFeatures
     * const { count } = await prisma.classFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassFeatureDeleteManyArgs>(args?: SelectSubset<T, ClassFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassFeatures
     * const classFeature = await prisma.classFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassFeatureUpdateManyArgs>(args: SelectSubset<T, ClassFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassFeature.
     * @param {ClassFeatureUpsertArgs} args - Arguments to update or create a ClassFeature.
     * @example
     * // Update or create a ClassFeature
     * const classFeature = await prisma.classFeature.upsert({
     *   create: {
     *     // ... data to create a ClassFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassFeature we want to update
     *   }
     * })
     */
    upsert<T extends ClassFeatureUpsertArgs>(args: SelectSubset<T, ClassFeatureUpsertArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureCountArgs} args - Arguments to filter ClassFeatures to count.
     * @example
     * // Count the number of ClassFeatures
     * const count = await prisma.classFeature.count({
     *   where: {
     *     // ... the filter for the ClassFeatures we want to count
     *   }
     * })
    **/
    count<T extends ClassFeatureCountArgs>(
      args?: Subset<T, ClassFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassFeatureAggregateArgs>(args: Subset<T, ClassFeatureAggregateArgs>): Prisma.PrismaPromise<GetClassFeatureAggregateType<T>>

    /**
     * Group by ClassFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassFeatureGroupByArgs['orderBy'] }
        : { orderBy?: ClassFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassFeature model
   */
  readonly fields: ClassFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassFeature model
   */
  interface ClassFeatureFieldRefs {
    readonly id: FieldRef<"ClassFeature", 'Int'>
    readonly classId: FieldRef<"ClassFeature", 'Int'>
    readonly name: FieldRef<"ClassFeature", 'String'>
    readonly description: FieldRef<"ClassFeature", 'String'>
    readonly level: FieldRef<"ClassFeature", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClassFeature findUnique
   */
  export type ClassFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ClassFeature to fetch.
     */
    where: ClassFeatureWhereUniqueInput
  }

  /**
   * ClassFeature findUniqueOrThrow
   */
  export type ClassFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ClassFeature to fetch.
     */
    where: ClassFeatureWhereUniqueInput
  }

  /**
   * ClassFeature findFirst
   */
  export type ClassFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ClassFeature to fetch.
     */
    where?: ClassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassFeatures to fetch.
     */
    orderBy?: ClassFeatureOrderByWithRelationInput | ClassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassFeatures.
     */
    cursor?: ClassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassFeatures.
     */
    distinct?: ClassFeatureScalarFieldEnum | ClassFeatureScalarFieldEnum[]
  }

  /**
   * ClassFeature findFirstOrThrow
   */
  export type ClassFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ClassFeature to fetch.
     */
    where?: ClassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassFeatures to fetch.
     */
    orderBy?: ClassFeatureOrderByWithRelationInput | ClassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassFeatures.
     */
    cursor?: ClassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassFeatures.
     */
    distinct?: ClassFeatureScalarFieldEnum | ClassFeatureScalarFieldEnum[]
  }

  /**
   * ClassFeature findMany
   */
  export type ClassFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ClassFeatures to fetch.
     */
    where?: ClassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassFeatures to fetch.
     */
    orderBy?: ClassFeatureOrderByWithRelationInput | ClassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassFeatures.
     */
    cursor?: ClassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassFeatures.
     */
    skip?: number
    distinct?: ClassFeatureScalarFieldEnum | ClassFeatureScalarFieldEnum[]
  }

  /**
   * ClassFeature create
   */
  export type ClassFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassFeature.
     */
    data: XOR<ClassFeatureCreateInput, ClassFeatureUncheckedCreateInput>
  }

  /**
   * ClassFeature createMany
   */
  export type ClassFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassFeatures.
     */
    data: ClassFeatureCreateManyInput | ClassFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassFeature update
   */
  export type ClassFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassFeature.
     */
    data: XOR<ClassFeatureUpdateInput, ClassFeatureUncheckedUpdateInput>
    /**
     * Choose, which ClassFeature to update.
     */
    where: ClassFeatureWhereUniqueInput
  }

  /**
   * ClassFeature updateMany
   */
  export type ClassFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassFeatures.
     */
    data: XOR<ClassFeatureUpdateManyMutationInput, ClassFeatureUncheckedUpdateManyInput>
    /**
     * Filter which ClassFeatures to update
     */
    where?: ClassFeatureWhereInput
    /**
     * Limit how many ClassFeatures to update.
     */
    limit?: number
  }

  /**
   * ClassFeature upsert
   */
  export type ClassFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassFeature to update in case it exists.
     */
    where: ClassFeatureWhereUniqueInput
    /**
     * In case the ClassFeature found by the `where` argument doesn't exist, create a new ClassFeature with this data.
     */
    create: XOR<ClassFeatureCreateInput, ClassFeatureUncheckedCreateInput>
    /**
     * In case the ClassFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassFeatureUpdateInput, ClassFeatureUncheckedUpdateInput>
  }

  /**
   * ClassFeature delete
   */
  export type ClassFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter which ClassFeature to delete.
     */
    where: ClassFeatureWhereUniqueInput
  }

  /**
   * ClassFeature deleteMany
   */
  export type ClassFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassFeatures to delete
     */
    where?: ClassFeatureWhereInput
    /**
     * Limit how many ClassFeatures to delete.
     */
    limit?: number
  }

  /**
   * ClassFeature without action
   */
  export type ClassFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
  }


  /**
   * Model ClassSpellLevel
   */

  export type AggregateClassSpellLevel = {
    _count: ClassSpellLevelCountAggregateOutputType | null
    _avg: ClassSpellLevelAvgAggregateOutputType | null
    _sum: ClassSpellLevelSumAggregateOutputType | null
    _min: ClassSpellLevelMinAggregateOutputType | null
    _max: ClassSpellLevelMaxAggregateOutputType | null
  }

  export type ClassSpellLevelAvgAggregateOutputType = {
    id: number | null
    classId: number | null
    spellLevel: number | null
  }

  export type ClassSpellLevelSumAggregateOutputType = {
    id: number | null
    classId: number | null
    spellLevel: number | null
  }

  export type ClassSpellLevelMinAggregateOutputType = {
    id: number | null
    classId: number | null
    spellLevel: number | null
  }

  export type ClassSpellLevelMaxAggregateOutputType = {
    id: number | null
    classId: number | null
    spellLevel: number | null
  }

  export type ClassSpellLevelCountAggregateOutputType = {
    id: number
    classId: number
    spellLevel: number
    _all: number
  }


  export type ClassSpellLevelAvgAggregateInputType = {
    id?: true
    classId?: true
    spellLevel?: true
  }

  export type ClassSpellLevelSumAggregateInputType = {
    id?: true
    classId?: true
    spellLevel?: true
  }

  export type ClassSpellLevelMinAggregateInputType = {
    id?: true
    classId?: true
    spellLevel?: true
  }

  export type ClassSpellLevelMaxAggregateInputType = {
    id?: true
    classId?: true
    spellLevel?: true
  }

  export type ClassSpellLevelCountAggregateInputType = {
    id?: true
    classId?: true
    spellLevel?: true
    _all?: true
  }

  export type ClassSpellLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSpellLevel to aggregate.
     */
    where?: ClassSpellLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSpellLevels to fetch.
     */
    orderBy?: ClassSpellLevelOrderByWithRelationInput | ClassSpellLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassSpellLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSpellLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSpellLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSpellLevels
    **/
    _count?: true | ClassSpellLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassSpellLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSpellLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassSpellLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassSpellLevelMaxAggregateInputType
  }

  export type GetClassSpellLevelAggregateType<T extends ClassSpellLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSpellLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSpellLevel[P]>
      : GetScalarType<T[P], AggregateClassSpellLevel[P]>
  }




  export type ClassSpellLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSpellLevelWhereInput
    orderBy?: ClassSpellLevelOrderByWithAggregationInput | ClassSpellLevelOrderByWithAggregationInput[]
    by: ClassSpellLevelScalarFieldEnum[] | ClassSpellLevelScalarFieldEnum
    having?: ClassSpellLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassSpellLevelCountAggregateInputType | true
    _avg?: ClassSpellLevelAvgAggregateInputType
    _sum?: ClassSpellLevelSumAggregateInputType
    _min?: ClassSpellLevelMinAggregateInputType
    _max?: ClassSpellLevelMaxAggregateInputType
  }

  export type ClassSpellLevelGroupByOutputType = {
    id: number
    classId: number
    spellLevel: number
    _count: ClassSpellLevelCountAggregateOutputType | null
    _avg: ClassSpellLevelAvgAggregateOutputType | null
    _sum: ClassSpellLevelSumAggregateOutputType | null
    _min: ClassSpellLevelMinAggregateOutputType | null
    _max: ClassSpellLevelMaxAggregateOutputType | null
  }

  type GetClassSpellLevelGroupByPayload<T extends ClassSpellLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassSpellLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassSpellLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassSpellLevelGroupByOutputType[P]>
            : GetScalarType<T[P], ClassSpellLevelGroupByOutputType[P]>
        }
      >
    >


  export type ClassSpellLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    spellLevel?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSpellLevel"]>



  export type ClassSpellLevelSelectScalar = {
    id?: boolean
    classId?: boolean
    spellLevel?: boolean
  }

  export type ClassSpellLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "spellLevel", ExtArgs["result"]["classSpellLevel"]>
  export type ClassSpellLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $ClassSpellLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSpellLevel"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classId: number
      spellLevel: number
    }, ExtArgs["result"]["classSpellLevel"]>
    composites: {}
  }

  type ClassSpellLevelGetPayload<S extends boolean | null | undefined | ClassSpellLevelDefaultArgs> = $Result.GetResult<Prisma.$ClassSpellLevelPayload, S>

  type ClassSpellLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassSpellLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassSpellLevelCountAggregateInputType | true
    }

  export interface ClassSpellLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSpellLevel'], meta: { name: 'ClassSpellLevel' } }
    /**
     * Find zero or one ClassSpellLevel that matches the filter.
     * @param {ClassSpellLevelFindUniqueArgs} args - Arguments to find a ClassSpellLevel
     * @example
     * // Get one ClassSpellLevel
     * const classSpellLevel = await prisma.classSpellLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassSpellLevelFindUniqueArgs>(args: SelectSubset<T, ClassSpellLevelFindUniqueArgs<ExtArgs>>): Prisma__ClassSpellLevelClient<$Result.GetResult<Prisma.$ClassSpellLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassSpellLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassSpellLevelFindUniqueOrThrowArgs} args - Arguments to find a ClassSpellLevel
     * @example
     * // Get one ClassSpellLevel
     * const classSpellLevel = await prisma.classSpellLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassSpellLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassSpellLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassSpellLevelClient<$Result.GetResult<Prisma.$ClassSpellLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSpellLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSpellLevelFindFirstArgs} args - Arguments to find a ClassSpellLevel
     * @example
     * // Get one ClassSpellLevel
     * const classSpellLevel = await prisma.classSpellLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassSpellLevelFindFirstArgs>(args?: SelectSubset<T, ClassSpellLevelFindFirstArgs<ExtArgs>>): Prisma__ClassSpellLevelClient<$Result.GetResult<Prisma.$ClassSpellLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSpellLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSpellLevelFindFirstOrThrowArgs} args - Arguments to find a ClassSpellLevel
     * @example
     * // Get one ClassSpellLevel
     * const classSpellLevel = await prisma.classSpellLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassSpellLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassSpellLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassSpellLevelClient<$Result.GetResult<Prisma.$ClassSpellLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassSpellLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSpellLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSpellLevels
     * const classSpellLevels = await prisma.classSpellLevel.findMany()
     * 
     * // Get first 10 ClassSpellLevels
     * const classSpellLevels = await prisma.classSpellLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classSpellLevelWithIdOnly = await prisma.classSpellLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassSpellLevelFindManyArgs>(args?: SelectSubset<T, ClassSpellLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSpellLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassSpellLevel.
     * @param {ClassSpellLevelCreateArgs} args - Arguments to create a ClassSpellLevel.
     * @example
     * // Create one ClassSpellLevel
     * const ClassSpellLevel = await prisma.classSpellLevel.create({
     *   data: {
     *     // ... data to create a ClassSpellLevel
     *   }
     * })
     * 
     */
    create<T extends ClassSpellLevelCreateArgs>(args: SelectSubset<T, ClassSpellLevelCreateArgs<ExtArgs>>): Prisma__ClassSpellLevelClient<$Result.GetResult<Prisma.$ClassSpellLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassSpellLevels.
     * @param {ClassSpellLevelCreateManyArgs} args - Arguments to create many ClassSpellLevels.
     * @example
     * // Create many ClassSpellLevels
     * const classSpellLevel = await prisma.classSpellLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassSpellLevelCreateManyArgs>(args?: SelectSubset<T, ClassSpellLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassSpellLevel.
     * @param {ClassSpellLevelDeleteArgs} args - Arguments to delete one ClassSpellLevel.
     * @example
     * // Delete one ClassSpellLevel
     * const ClassSpellLevel = await prisma.classSpellLevel.delete({
     *   where: {
     *     // ... filter to delete one ClassSpellLevel
     *   }
     * })
     * 
     */
    delete<T extends ClassSpellLevelDeleteArgs>(args: SelectSubset<T, ClassSpellLevelDeleteArgs<ExtArgs>>): Prisma__ClassSpellLevelClient<$Result.GetResult<Prisma.$ClassSpellLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassSpellLevel.
     * @param {ClassSpellLevelUpdateArgs} args - Arguments to update one ClassSpellLevel.
     * @example
     * // Update one ClassSpellLevel
     * const classSpellLevel = await prisma.classSpellLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassSpellLevelUpdateArgs>(args: SelectSubset<T, ClassSpellLevelUpdateArgs<ExtArgs>>): Prisma__ClassSpellLevelClient<$Result.GetResult<Prisma.$ClassSpellLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassSpellLevels.
     * @param {ClassSpellLevelDeleteManyArgs} args - Arguments to filter ClassSpellLevels to delete.
     * @example
     * // Delete a few ClassSpellLevels
     * const { count } = await prisma.classSpellLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassSpellLevelDeleteManyArgs>(args?: SelectSubset<T, ClassSpellLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSpellLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSpellLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSpellLevels
     * const classSpellLevel = await prisma.classSpellLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassSpellLevelUpdateManyArgs>(args: SelectSubset<T, ClassSpellLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassSpellLevel.
     * @param {ClassSpellLevelUpsertArgs} args - Arguments to update or create a ClassSpellLevel.
     * @example
     * // Update or create a ClassSpellLevel
     * const classSpellLevel = await prisma.classSpellLevel.upsert({
     *   create: {
     *     // ... data to create a ClassSpellLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSpellLevel we want to update
     *   }
     * })
     */
    upsert<T extends ClassSpellLevelUpsertArgs>(args: SelectSubset<T, ClassSpellLevelUpsertArgs<ExtArgs>>): Prisma__ClassSpellLevelClient<$Result.GetResult<Prisma.$ClassSpellLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassSpellLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSpellLevelCountArgs} args - Arguments to filter ClassSpellLevels to count.
     * @example
     * // Count the number of ClassSpellLevels
     * const count = await prisma.classSpellLevel.count({
     *   where: {
     *     // ... the filter for the ClassSpellLevels we want to count
     *   }
     * })
    **/
    count<T extends ClassSpellLevelCountArgs>(
      args?: Subset<T, ClassSpellLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassSpellLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSpellLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSpellLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassSpellLevelAggregateArgs>(args: Subset<T, ClassSpellLevelAggregateArgs>): Prisma.PrismaPromise<GetClassSpellLevelAggregateType<T>>

    /**
     * Group by ClassSpellLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSpellLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassSpellLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassSpellLevelGroupByArgs['orderBy'] }
        : { orderBy?: ClassSpellLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassSpellLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassSpellLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSpellLevel model
   */
  readonly fields: ClassSpellLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSpellLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassSpellLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassSpellLevel model
   */
  interface ClassSpellLevelFieldRefs {
    readonly id: FieldRef<"ClassSpellLevel", 'Int'>
    readonly classId: FieldRef<"ClassSpellLevel", 'Int'>
    readonly spellLevel: FieldRef<"ClassSpellLevel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClassSpellLevel findUnique
   */
  export type ClassSpellLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSpellLevel
     */
    select?: ClassSpellLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSpellLevel
     */
    omit?: ClassSpellLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSpellLevelInclude<ExtArgs> | null
    /**
     * Filter, which ClassSpellLevel to fetch.
     */
    where: ClassSpellLevelWhereUniqueInput
  }

  /**
   * ClassSpellLevel findUniqueOrThrow
   */
  export type ClassSpellLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSpellLevel
     */
    select?: ClassSpellLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSpellLevel
     */
    omit?: ClassSpellLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSpellLevelInclude<ExtArgs> | null
    /**
     * Filter, which ClassSpellLevel to fetch.
     */
    where: ClassSpellLevelWhereUniqueInput
  }

  /**
   * ClassSpellLevel findFirst
   */
  export type ClassSpellLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSpellLevel
     */
    select?: ClassSpellLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSpellLevel
     */
    omit?: ClassSpellLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSpellLevelInclude<ExtArgs> | null
    /**
     * Filter, which ClassSpellLevel to fetch.
     */
    where?: ClassSpellLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSpellLevels to fetch.
     */
    orderBy?: ClassSpellLevelOrderByWithRelationInput | ClassSpellLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSpellLevels.
     */
    cursor?: ClassSpellLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSpellLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSpellLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSpellLevels.
     */
    distinct?: ClassSpellLevelScalarFieldEnum | ClassSpellLevelScalarFieldEnum[]
  }

  /**
   * ClassSpellLevel findFirstOrThrow
   */
  export type ClassSpellLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSpellLevel
     */
    select?: ClassSpellLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSpellLevel
     */
    omit?: ClassSpellLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSpellLevelInclude<ExtArgs> | null
    /**
     * Filter, which ClassSpellLevel to fetch.
     */
    where?: ClassSpellLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSpellLevels to fetch.
     */
    orderBy?: ClassSpellLevelOrderByWithRelationInput | ClassSpellLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSpellLevels.
     */
    cursor?: ClassSpellLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSpellLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSpellLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSpellLevels.
     */
    distinct?: ClassSpellLevelScalarFieldEnum | ClassSpellLevelScalarFieldEnum[]
  }

  /**
   * ClassSpellLevel findMany
   */
  export type ClassSpellLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSpellLevel
     */
    select?: ClassSpellLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSpellLevel
     */
    omit?: ClassSpellLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSpellLevelInclude<ExtArgs> | null
    /**
     * Filter, which ClassSpellLevels to fetch.
     */
    where?: ClassSpellLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSpellLevels to fetch.
     */
    orderBy?: ClassSpellLevelOrderByWithRelationInput | ClassSpellLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSpellLevels.
     */
    cursor?: ClassSpellLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSpellLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSpellLevels.
     */
    skip?: number
    distinct?: ClassSpellLevelScalarFieldEnum | ClassSpellLevelScalarFieldEnum[]
  }

  /**
   * ClassSpellLevel create
   */
  export type ClassSpellLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSpellLevel
     */
    select?: ClassSpellLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSpellLevel
     */
    omit?: ClassSpellLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSpellLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSpellLevel.
     */
    data: XOR<ClassSpellLevelCreateInput, ClassSpellLevelUncheckedCreateInput>
  }

  /**
   * ClassSpellLevel createMany
   */
  export type ClassSpellLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSpellLevels.
     */
    data: ClassSpellLevelCreateManyInput | ClassSpellLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassSpellLevel update
   */
  export type ClassSpellLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSpellLevel
     */
    select?: ClassSpellLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSpellLevel
     */
    omit?: ClassSpellLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSpellLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSpellLevel.
     */
    data: XOR<ClassSpellLevelUpdateInput, ClassSpellLevelUncheckedUpdateInput>
    /**
     * Choose, which ClassSpellLevel to update.
     */
    where: ClassSpellLevelWhereUniqueInput
  }

  /**
   * ClassSpellLevel updateMany
   */
  export type ClassSpellLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSpellLevels.
     */
    data: XOR<ClassSpellLevelUpdateManyMutationInput, ClassSpellLevelUncheckedUpdateManyInput>
    /**
     * Filter which ClassSpellLevels to update
     */
    where?: ClassSpellLevelWhereInput
    /**
     * Limit how many ClassSpellLevels to update.
     */
    limit?: number
  }

  /**
   * ClassSpellLevel upsert
   */
  export type ClassSpellLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSpellLevel
     */
    select?: ClassSpellLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSpellLevel
     */
    omit?: ClassSpellLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSpellLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSpellLevel to update in case it exists.
     */
    where: ClassSpellLevelWhereUniqueInput
    /**
     * In case the ClassSpellLevel found by the `where` argument doesn't exist, create a new ClassSpellLevel with this data.
     */
    create: XOR<ClassSpellLevelCreateInput, ClassSpellLevelUncheckedCreateInput>
    /**
     * In case the ClassSpellLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassSpellLevelUpdateInput, ClassSpellLevelUncheckedUpdateInput>
  }

  /**
   * ClassSpellLevel delete
   */
  export type ClassSpellLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSpellLevel
     */
    select?: ClassSpellLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSpellLevel
     */
    omit?: ClassSpellLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSpellLevelInclude<ExtArgs> | null
    /**
     * Filter which ClassSpellLevel to delete.
     */
    where: ClassSpellLevelWhereUniqueInput
  }

  /**
   * ClassSpellLevel deleteMany
   */
  export type ClassSpellLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSpellLevels to delete
     */
    where?: ClassSpellLevelWhereInput
    /**
     * Limit how many ClassSpellLevels to delete.
     */
    limit?: number
  }

  /**
   * ClassSpellLevel without action
   */
  export type ClassSpellLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSpellLevel
     */
    select?: ClassSpellLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSpellLevel
     */
    omit?: ClassSpellLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSpellLevelInclude<ExtArgs> | null
  }


  /**
   * Model ClassLevelAttribute
   */

  export type AggregateClassLevelAttribute = {
    _count: ClassLevelAttributeCountAggregateOutputType | null
    _avg: ClassLevelAttributeAvgAggregateOutputType | null
    _sum: ClassLevelAttributeSumAggregateOutputType | null
    _min: ClassLevelAttributeMinAggregateOutputType | null
    _max: ClassLevelAttributeMaxAggregateOutputType | null
  }

  export type ClassLevelAttributeAvgAggregateOutputType = {
    id: number | null
    classId: number | null
    baseAttackBonus: number | null
    fortSave: number | null
    refSave: number | null
    willSave: number | null
  }

  export type ClassLevelAttributeSumAggregateOutputType = {
    id: number | null
    classId: number | null
    baseAttackBonus: number | null
    fortSave: number | null
    refSave: number | null
    willSave: number | null
  }

  export type ClassLevelAttributeMinAggregateOutputType = {
    id: number | null
    classId: number | null
    baseAttackBonus: number | null
    fortSave: number | null
    refSave: number | null
    willSave: number | null
  }

  export type ClassLevelAttributeMaxAggregateOutputType = {
    id: number | null
    classId: number | null
    baseAttackBonus: number | null
    fortSave: number | null
    refSave: number | null
    willSave: number | null
  }

  export type ClassLevelAttributeCountAggregateOutputType = {
    id: number
    classId: number
    baseAttackBonus: number
    fortSave: number
    refSave: number
    willSave: number
    _all: number
  }


  export type ClassLevelAttributeAvgAggregateInputType = {
    id?: true
    classId?: true
    baseAttackBonus?: true
    fortSave?: true
    refSave?: true
    willSave?: true
  }

  export type ClassLevelAttributeSumAggregateInputType = {
    id?: true
    classId?: true
    baseAttackBonus?: true
    fortSave?: true
    refSave?: true
    willSave?: true
  }

  export type ClassLevelAttributeMinAggregateInputType = {
    id?: true
    classId?: true
    baseAttackBonus?: true
    fortSave?: true
    refSave?: true
    willSave?: true
  }

  export type ClassLevelAttributeMaxAggregateInputType = {
    id?: true
    classId?: true
    baseAttackBonus?: true
    fortSave?: true
    refSave?: true
    willSave?: true
  }

  export type ClassLevelAttributeCountAggregateInputType = {
    id?: true
    classId?: true
    baseAttackBonus?: true
    fortSave?: true
    refSave?: true
    willSave?: true
    _all?: true
  }

  export type ClassLevelAttributeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassLevelAttribute to aggregate.
     */
    where?: ClassLevelAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassLevelAttributes to fetch.
     */
    orderBy?: ClassLevelAttributeOrderByWithRelationInput | ClassLevelAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassLevelAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassLevelAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassLevelAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassLevelAttributes
    **/
    _count?: true | ClassLevelAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassLevelAttributeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassLevelAttributeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassLevelAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassLevelAttributeMaxAggregateInputType
  }

  export type GetClassLevelAttributeAggregateType<T extends ClassLevelAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateClassLevelAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassLevelAttribute[P]>
      : GetScalarType<T[P], AggregateClassLevelAttribute[P]>
  }




  export type ClassLevelAttributeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassLevelAttributeWhereInput
    orderBy?: ClassLevelAttributeOrderByWithAggregationInput | ClassLevelAttributeOrderByWithAggregationInput[]
    by: ClassLevelAttributeScalarFieldEnum[] | ClassLevelAttributeScalarFieldEnum
    having?: ClassLevelAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassLevelAttributeCountAggregateInputType | true
    _avg?: ClassLevelAttributeAvgAggregateInputType
    _sum?: ClassLevelAttributeSumAggregateInputType
    _min?: ClassLevelAttributeMinAggregateInputType
    _max?: ClassLevelAttributeMaxAggregateInputType
  }

  export type ClassLevelAttributeGroupByOutputType = {
    id: number
    classId: number
    baseAttackBonus: number
    fortSave: number
    refSave: number
    willSave: number
    _count: ClassLevelAttributeCountAggregateOutputType | null
    _avg: ClassLevelAttributeAvgAggregateOutputType | null
    _sum: ClassLevelAttributeSumAggregateOutputType | null
    _min: ClassLevelAttributeMinAggregateOutputType | null
    _max: ClassLevelAttributeMaxAggregateOutputType | null
  }

  type GetClassLevelAttributeGroupByPayload<T extends ClassLevelAttributeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassLevelAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassLevelAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassLevelAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], ClassLevelAttributeGroupByOutputType[P]>
        }
      >
    >


  export type ClassLevelAttributeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    baseAttackBonus?: boolean
    fortSave?: boolean
    refSave?: boolean
    willSave?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classLevelAttribute"]>



  export type ClassLevelAttributeSelectScalar = {
    id?: boolean
    classId?: boolean
    baseAttackBonus?: boolean
    fortSave?: boolean
    refSave?: boolean
    willSave?: boolean
  }

  export type ClassLevelAttributeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "baseAttackBonus" | "fortSave" | "refSave" | "willSave", ExtArgs["result"]["classLevelAttribute"]>
  export type ClassLevelAttributeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $ClassLevelAttributePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassLevelAttribute"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classId: number
      baseAttackBonus: number
      fortSave: number
      refSave: number
      willSave: number
    }, ExtArgs["result"]["classLevelAttribute"]>
    composites: {}
  }

  type ClassLevelAttributeGetPayload<S extends boolean | null | undefined | ClassLevelAttributeDefaultArgs> = $Result.GetResult<Prisma.$ClassLevelAttributePayload, S>

  type ClassLevelAttributeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassLevelAttributeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassLevelAttributeCountAggregateInputType | true
    }

  export interface ClassLevelAttributeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassLevelAttribute'], meta: { name: 'ClassLevelAttribute' } }
    /**
     * Find zero or one ClassLevelAttribute that matches the filter.
     * @param {ClassLevelAttributeFindUniqueArgs} args - Arguments to find a ClassLevelAttribute
     * @example
     * // Get one ClassLevelAttribute
     * const classLevelAttribute = await prisma.classLevelAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassLevelAttributeFindUniqueArgs>(args: SelectSubset<T, ClassLevelAttributeFindUniqueArgs<ExtArgs>>): Prisma__ClassLevelAttributeClient<$Result.GetResult<Prisma.$ClassLevelAttributePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassLevelAttribute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassLevelAttributeFindUniqueOrThrowArgs} args - Arguments to find a ClassLevelAttribute
     * @example
     * // Get one ClassLevelAttribute
     * const classLevelAttribute = await prisma.classLevelAttribute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassLevelAttributeFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassLevelAttributeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassLevelAttributeClient<$Result.GetResult<Prisma.$ClassLevelAttributePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassLevelAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassLevelAttributeFindFirstArgs} args - Arguments to find a ClassLevelAttribute
     * @example
     * // Get one ClassLevelAttribute
     * const classLevelAttribute = await prisma.classLevelAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassLevelAttributeFindFirstArgs>(args?: SelectSubset<T, ClassLevelAttributeFindFirstArgs<ExtArgs>>): Prisma__ClassLevelAttributeClient<$Result.GetResult<Prisma.$ClassLevelAttributePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassLevelAttribute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassLevelAttributeFindFirstOrThrowArgs} args - Arguments to find a ClassLevelAttribute
     * @example
     * // Get one ClassLevelAttribute
     * const classLevelAttribute = await prisma.classLevelAttribute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassLevelAttributeFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassLevelAttributeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassLevelAttributeClient<$Result.GetResult<Prisma.$ClassLevelAttributePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassLevelAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassLevelAttributeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassLevelAttributes
     * const classLevelAttributes = await prisma.classLevelAttribute.findMany()
     * 
     * // Get first 10 ClassLevelAttributes
     * const classLevelAttributes = await prisma.classLevelAttribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classLevelAttributeWithIdOnly = await prisma.classLevelAttribute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassLevelAttributeFindManyArgs>(args?: SelectSubset<T, ClassLevelAttributeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassLevelAttributePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassLevelAttribute.
     * @param {ClassLevelAttributeCreateArgs} args - Arguments to create a ClassLevelAttribute.
     * @example
     * // Create one ClassLevelAttribute
     * const ClassLevelAttribute = await prisma.classLevelAttribute.create({
     *   data: {
     *     // ... data to create a ClassLevelAttribute
     *   }
     * })
     * 
     */
    create<T extends ClassLevelAttributeCreateArgs>(args: SelectSubset<T, ClassLevelAttributeCreateArgs<ExtArgs>>): Prisma__ClassLevelAttributeClient<$Result.GetResult<Prisma.$ClassLevelAttributePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassLevelAttributes.
     * @param {ClassLevelAttributeCreateManyArgs} args - Arguments to create many ClassLevelAttributes.
     * @example
     * // Create many ClassLevelAttributes
     * const classLevelAttribute = await prisma.classLevelAttribute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassLevelAttributeCreateManyArgs>(args?: SelectSubset<T, ClassLevelAttributeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassLevelAttribute.
     * @param {ClassLevelAttributeDeleteArgs} args - Arguments to delete one ClassLevelAttribute.
     * @example
     * // Delete one ClassLevelAttribute
     * const ClassLevelAttribute = await prisma.classLevelAttribute.delete({
     *   where: {
     *     // ... filter to delete one ClassLevelAttribute
     *   }
     * })
     * 
     */
    delete<T extends ClassLevelAttributeDeleteArgs>(args: SelectSubset<T, ClassLevelAttributeDeleteArgs<ExtArgs>>): Prisma__ClassLevelAttributeClient<$Result.GetResult<Prisma.$ClassLevelAttributePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassLevelAttribute.
     * @param {ClassLevelAttributeUpdateArgs} args - Arguments to update one ClassLevelAttribute.
     * @example
     * // Update one ClassLevelAttribute
     * const classLevelAttribute = await prisma.classLevelAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassLevelAttributeUpdateArgs>(args: SelectSubset<T, ClassLevelAttributeUpdateArgs<ExtArgs>>): Prisma__ClassLevelAttributeClient<$Result.GetResult<Prisma.$ClassLevelAttributePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassLevelAttributes.
     * @param {ClassLevelAttributeDeleteManyArgs} args - Arguments to filter ClassLevelAttributes to delete.
     * @example
     * // Delete a few ClassLevelAttributes
     * const { count } = await prisma.classLevelAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassLevelAttributeDeleteManyArgs>(args?: SelectSubset<T, ClassLevelAttributeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassLevelAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassLevelAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassLevelAttributes
     * const classLevelAttribute = await prisma.classLevelAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassLevelAttributeUpdateManyArgs>(args: SelectSubset<T, ClassLevelAttributeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassLevelAttribute.
     * @param {ClassLevelAttributeUpsertArgs} args - Arguments to update or create a ClassLevelAttribute.
     * @example
     * // Update or create a ClassLevelAttribute
     * const classLevelAttribute = await prisma.classLevelAttribute.upsert({
     *   create: {
     *     // ... data to create a ClassLevelAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassLevelAttribute we want to update
     *   }
     * })
     */
    upsert<T extends ClassLevelAttributeUpsertArgs>(args: SelectSubset<T, ClassLevelAttributeUpsertArgs<ExtArgs>>): Prisma__ClassLevelAttributeClient<$Result.GetResult<Prisma.$ClassLevelAttributePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassLevelAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassLevelAttributeCountArgs} args - Arguments to filter ClassLevelAttributes to count.
     * @example
     * // Count the number of ClassLevelAttributes
     * const count = await prisma.classLevelAttribute.count({
     *   where: {
     *     // ... the filter for the ClassLevelAttributes we want to count
     *   }
     * })
    **/
    count<T extends ClassLevelAttributeCountArgs>(
      args?: Subset<T, ClassLevelAttributeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassLevelAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassLevelAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassLevelAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassLevelAttributeAggregateArgs>(args: Subset<T, ClassLevelAttributeAggregateArgs>): Prisma.PrismaPromise<GetClassLevelAttributeAggregateType<T>>

    /**
     * Group by ClassLevelAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassLevelAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassLevelAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassLevelAttributeGroupByArgs['orderBy'] }
        : { orderBy?: ClassLevelAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassLevelAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassLevelAttributeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassLevelAttribute model
   */
  readonly fields: ClassLevelAttributeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassLevelAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassLevelAttributeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassLevelAttribute model
   */
  interface ClassLevelAttributeFieldRefs {
    readonly id: FieldRef<"ClassLevelAttribute", 'Int'>
    readonly classId: FieldRef<"ClassLevelAttribute", 'Int'>
    readonly baseAttackBonus: FieldRef<"ClassLevelAttribute", 'Int'>
    readonly fortSave: FieldRef<"ClassLevelAttribute", 'Int'>
    readonly refSave: FieldRef<"ClassLevelAttribute", 'Int'>
    readonly willSave: FieldRef<"ClassLevelAttribute", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClassLevelAttribute findUnique
   */
  export type ClassLevelAttributeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassLevelAttribute
     */
    select?: ClassLevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassLevelAttribute
     */
    omit?: ClassLevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassLevelAttributeInclude<ExtArgs> | null
    /**
     * Filter, which ClassLevelAttribute to fetch.
     */
    where: ClassLevelAttributeWhereUniqueInput
  }

  /**
   * ClassLevelAttribute findUniqueOrThrow
   */
  export type ClassLevelAttributeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassLevelAttribute
     */
    select?: ClassLevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassLevelAttribute
     */
    omit?: ClassLevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassLevelAttributeInclude<ExtArgs> | null
    /**
     * Filter, which ClassLevelAttribute to fetch.
     */
    where: ClassLevelAttributeWhereUniqueInput
  }

  /**
   * ClassLevelAttribute findFirst
   */
  export type ClassLevelAttributeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassLevelAttribute
     */
    select?: ClassLevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassLevelAttribute
     */
    omit?: ClassLevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassLevelAttributeInclude<ExtArgs> | null
    /**
     * Filter, which ClassLevelAttribute to fetch.
     */
    where?: ClassLevelAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassLevelAttributes to fetch.
     */
    orderBy?: ClassLevelAttributeOrderByWithRelationInput | ClassLevelAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassLevelAttributes.
     */
    cursor?: ClassLevelAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassLevelAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassLevelAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassLevelAttributes.
     */
    distinct?: ClassLevelAttributeScalarFieldEnum | ClassLevelAttributeScalarFieldEnum[]
  }

  /**
   * ClassLevelAttribute findFirstOrThrow
   */
  export type ClassLevelAttributeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassLevelAttribute
     */
    select?: ClassLevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassLevelAttribute
     */
    omit?: ClassLevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassLevelAttributeInclude<ExtArgs> | null
    /**
     * Filter, which ClassLevelAttribute to fetch.
     */
    where?: ClassLevelAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassLevelAttributes to fetch.
     */
    orderBy?: ClassLevelAttributeOrderByWithRelationInput | ClassLevelAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassLevelAttributes.
     */
    cursor?: ClassLevelAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassLevelAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassLevelAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassLevelAttributes.
     */
    distinct?: ClassLevelAttributeScalarFieldEnum | ClassLevelAttributeScalarFieldEnum[]
  }

  /**
   * ClassLevelAttribute findMany
   */
  export type ClassLevelAttributeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassLevelAttribute
     */
    select?: ClassLevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassLevelAttribute
     */
    omit?: ClassLevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassLevelAttributeInclude<ExtArgs> | null
    /**
     * Filter, which ClassLevelAttributes to fetch.
     */
    where?: ClassLevelAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassLevelAttributes to fetch.
     */
    orderBy?: ClassLevelAttributeOrderByWithRelationInput | ClassLevelAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassLevelAttributes.
     */
    cursor?: ClassLevelAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassLevelAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassLevelAttributes.
     */
    skip?: number
    distinct?: ClassLevelAttributeScalarFieldEnum | ClassLevelAttributeScalarFieldEnum[]
  }

  /**
   * ClassLevelAttribute create
   */
  export type ClassLevelAttributeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassLevelAttribute
     */
    select?: ClassLevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassLevelAttribute
     */
    omit?: ClassLevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassLevelAttributeInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassLevelAttribute.
     */
    data: XOR<ClassLevelAttributeCreateInput, ClassLevelAttributeUncheckedCreateInput>
  }

  /**
   * ClassLevelAttribute createMany
   */
  export type ClassLevelAttributeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassLevelAttributes.
     */
    data: ClassLevelAttributeCreateManyInput | ClassLevelAttributeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassLevelAttribute update
   */
  export type ClassLevelAttributeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassLevelAttribute
     */
    select?: ClassLevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassLevelAttribute
     */
    omit?: ClassLevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassLevelAttributeInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassLevelAttribute.
     */
    data: XOR<ClassLevelAttributeUpdateInput, ClassLevelAttributeUncheckedUpdateInput>
    /**
     * Choose, which ClassLevelAttribute to update.
     */
    where: ClassLevelAttributeWhereUniqueInput
  }

  /**
   * ClassLevelAttribute updateMany
   */
  export type ClassLevelAttributeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassLevelAttributes.
     */
    data: XOR<ClassLevelAttributeUpdateManyMutationInput, ClassLevelAttributeUncheckedUpdateManyInput>
    /**
     * Filter which ClassLevelAttributes to update
     */
    where?: ClassLevelAttributeWhereInput
    /**
     * Limit how many ClassLevelAttributes to update.
     */
    limit?: number
  }

  /**
   * ClassLevelAttribute upsert
   */
  export type ClassLevelAttributeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassLevelAttribute
     */
    select?: ClassLevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassLevelAttribute
     */
    omit?: ClassLevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassLevelAttributeInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassLevelAttribute to update in case it exists.
     */
    where: ClassLevelAttributeWhereUniqueInput
    /**
     * In case the ClassLevelAttribute found by the `where` argument doesn't exist, create a new ClassLevelAttribute with this data.
     */
    create: XOR<ClassLevelAttributeCreateInput, ClassLevelAttributeUncheckedCreateInput>
    /**
     * In case the ClassLevelAttribute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassLevelAttributeUpdateInput, ClassLevelAttributeUncheckedUpdateInput>
  }

  /**
   * ClassLevelAttribute delete
   */
  export type ClassLevelAttributeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassLevelAttribute
     */
    select?: ClassLevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassLevelAttribute
     */
    omit?: ClassLevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassLevelAttributeInclude<ExtArgs> | null
    /**
     * Filter which ClassLevelAttribute to delete.
     */
    where: ClassLevelAttributeWhereUniqueInput
  }

  /**
   * ClassLevelAttribute deleteMany
   */
  export type ClassLevelAttributeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassLevelAttributes to delete
     */
    where?: ClassLevelAttributeWhereInput
    /**
     * Limit how many ClassLevelAttributes to delete.
     */
    limit?: number
  }

  /**
   * ClassLevelAttribute without action
   */
  export type ClassLevelAttributeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassLevelAttribute
     */
    select?: ClassLevelAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassLevelAttribute
     */
    omit?: ClassLevelAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassLevelAttributeInclude<ExtArgs> | null
  }


  /**
   * Model ClassSkillMap
   */

  export type AggregateClassSkillMap = {
    _count: ClassSkillMapCountAggregateOutputType | null
    _avg: ClassSkillMapAvgAggregateOutputType | null
    _sum: ClassSkillMapSumAggregateOutputType | null
    _min: ClassSkillMapMinAggregateOutputType | null
    _max: ClassSkillMapMaxAggregateOutputType | null
  }

  export type ClassSkillMapAvgAggregateOutputType = {
    id: number | null
    classId: number | null
    skillId: number | null
  }

  export type ClassSkillMapSumAggregateOutputType = {
    id: number | null
    classId: number | null
    skillId: number | null
  }

  export type ClassSkillMapMinAggregateOutputType = {
    id: number | null
    classId: number | null
    skillId: number | null
  }

  export type ClassSkillMapMaxAggregateOutputType = {
    id: number | null
    classId: number | null
    skillId: number | null
  }

  export type ClassSkillMapCountAggregateOutputType = {
    id: number
    classId: number
    skillId: number
    _all: number
  }


  export type ClassSkillMapAvgAggregateInputType = {
    id?: true
    classId?: true
    skillId?: true
  }

  export type ClassSkillMapSumAggregateInputType = {
    id?: true
    classId?: true
    skillId?: true
  }

  export type ClassSkillMapMinAggregateInputType = {
    id?: true
    classId?: true
    skillId?: true
  }

  export type ClassSkillMapMaxAggregateInputType = {
    id?: true
    classId?: true
    skillId?: true
  }

  export type ClassSkillMapCountAggregateInputType = {
    id?: true
    classId?: true
    skillId?: true
    _all?: true
  }

  export type ClassSkillMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSkillMap to aggregate.
     */
    where?: ClassSkillMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSkillMaps to fetch.
     */
    orderBy?: ClassSkillMapOrderByWithRelationInput | ClassSkillMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassSkillMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSkillMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSkillMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSkillMaps
    **/
    _count?: true | ClassSkillMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassSkillMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSkillMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassSkillMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassSkillMapMaxAggregateInputType
  }

  export type GetClassSkillMapAggregateType<T extends ClassSkillMapAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSkillMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSkillMap[P]>
      : GetScalarType<T[P], AggregateClassSkillMap[P]>
  }




  export type ClassSkillMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSkillMapWhereInput
    orderBy?: ClassSkillMapOrderByWithAggregationInput | ClassSkillMapOrderByWithAggregationInput[]
    by: ClassSkillMapScalarFieldEnum[] | ClassSkillMapScalarFieldEnum
    having?: ClassSkillMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassSkillMapCountAggregateInputType | true
    _avg?: ClassSkillMapAvgAggregateInputType
    _sum?: ClassSkillMapSumAggregateInputType
    _min?: ClassSkillMapMinAggregateInputType
    _max?: ClassSkillMapMaxAggregateInputType
  }

  export type ClassSkillMapGroupByOutputType = {
    id: number
    classId: number
    skillId: number
    _count: ClassSkillMapCountAggregateOutputType | null
    _avg: ClassSkillMapAvgAggregateOutputType | null
    _sum: ClassSkillMapSumAggregateOutputType | null
    _min: ClassSkillMapMinAggregateOutputType | null
    _max: ClassSkillMapMaxAggregateOutputType | null
  }

  type GetClassSkillMapGroupByPayload<T extends ClassSkillMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassSkillMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassSkillMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassSkillMapGroupByOutputType[P]>
            : GetScalarType<T[P], ClassSkillMapGroupByOutputType[P]>
        }
      >
    >


  export type ClassSkillMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    skillId?: boolean
    Class?: boolean | ClassDefaultArgs<ExtArgs>
    Skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSkillMap"]>



  export type ClassSkillMapSelectScalar = {
    id?: boolean
    classId?: boolean
    skillId?: boolean
  }

  export type ClassSkillMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "skillId", ExtArgs["result"]["classSkillMap"]>
  export type ClassSkillMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Class?: boolean | ClassDefaultArgs<ExtArgs>
    Skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $ClassSkillMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSkillMap"
    objects: {
      Class: Prisma.$ClassPayload<ExtArgs>
      Skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classId: number
      skillId: number
    }, ExtArgs["result"]["classSkillMap"]>
    composites: {}
  }

  type ClassSkillMapGetPayload<S extends boolean | null | undefined | ClassSkillMapDefaultArgs> = $Result.GetResult<Prisma.$ClassSkillMapPayload, S>

  type ClassSkillMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassSkillMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassSkillMapCountAggregateInputType | true
    }

  export interface ClassSkillMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSkillMap'], meta: { name: 'ClassSkillMap' } }
    /**
     * Find zero or one ClassSkillMap that matches the filter.
     * @param {ClassSkillMapFindUniqueArgs} args - Arguments to find a ClassSkillMap
     * @example
     * // Get one ClassSkillMap
     * const classSkillMap = await prisma.classSkillMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassSkillMapFindUniqueArgs>(args: SelectSubset<T, ClassSkillMapFindUniqueArgs<ExtArgs>>): Prisma__ClassSkillMapClient<$Result.GetResult<Prisma.$ClassSkillMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassSkillMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassSkillMapFindUniqueOrThrowArgs} args - Arguments to find a ClassSkillMap
     * @example
     * // Get one ClassSkillMap
     * const classSkillMap = await prisma.classSkillMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassSkillMapFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassSkillMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassSkillMapClient<$Result.GetResult<Prisma.$ClassSkillMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSkillMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillMapFindFirstArgs} args - Arguments to find a ClassSkillMap
     * @example
     * // Get one ClassSkillMap
     * const classSkillMap = await prisma.classSkillMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassSkillMapFindFirstArgs>(args?: SelectSubset<T, ClassSkillMapFindFirstArgs<ExtArgs>>): Prisma__ClassSkillMapClient<$Result.GetResult<Prisma.$ClassSkillMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSkillMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillMapFindFirstOrThrowArgs} args - Arguments to find a ClassSkillMap
     * @example
     * // Get one ClassSkillMap
     * const classSkillMap = await prisma.classSkillMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassSkillMapFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassSkillMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassSkillMapClient<$Result.GetResult<Prisma.$ClassSkillMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassSkillMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSkillMaps
     * const classSkillMaps = await prisma.classSkillMap.findMany()
     * 
     * // Get first 10 ClassSkillMaps
     * const classSkillMaps = await prisma.classSkillMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classSkillMapWithIdOnly = await prisma.classSkillMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassSkillMapFindManyArgs>(args?: SelectSubset<T, ClassSkillMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSkillMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassSkillMap.
     * @param {ClassSkillMapCreateArgs} args - Arguments to create a ClassSkillMap.
     * @example
     * // Create one ClassSkillMap
     * const ClassSkillMap = await prisma.classSkillMap.create({
     *   data: {
     *     // ... data to create a ClassSkillMap
     *   }
     * })
     * 
     */
    create<T extends ClassSkillMapCreateArgs>(args: SelectSubset<T, ClassSkillMapCreateArgs<ExtArgs>>): Prisma__ClassSkillMapClient<$Result.GetResult<Prisma.$ClassSkillMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassSkillMaps.
     * @param {ClassSkillMapCreateManyArgs} args - Arguments to create many ClassSkillMaps.
     * @example
     * // Create many ClassSkillMaps
     * const classSkillMap = await prisma.classSkillMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassSkillMapCreateManyArgs>(args?: SelectSubset<T, ClassSkillMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassSkillMap.
     * @param {ClassSkillMapDeleteArgs} args - Arguments to delete one ClassSkillMap.
     * @example
     * // Delete one ClassSkillMap
     * const ClassSkillMap = await prisma.classSkillMap.delete({
     *   where: {
     *     // ... filter to delete one ClassSkillMap
     *   }
     * })
     * 
     */
    delete<T extends ClassSkillMapDeleteArgs>(args: SelectSubset<T, ClassSkillMapDeleteArgs<ExtArgs>>): Prisma__ClassSkillMapClient<$Result.GetResult<Prisma.$ClassSkillMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassSkillMap.
     * @param {ClassSkillMapUpdateArgs} args - Arguments to update one ClassSkillMap.
     * @example
     * // Update one ClassSkillMap
     * const classSkillMap = await prisma.classSkillMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassSkillMapUpdateArgs>(args: SelectSubset<T, ClassSkillMapUpdateArgs<ExtArgs>>): Prisma__ClassSkillMapClient<$Result.GetResult<Prisma.$ClassSkillMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassSkillMaps.
     * @param {ClassSkillMapDeleteManyArgs} args - Arguments to filter ClassSkillMaps to delete.
     * @example
     * // Delete a few ClassSkillMaps
     * const { count } = await prisma.classSkillMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassSkillMapDeleteManyArgs>(args?: SelectSubset<T, ClassSkillMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSkillMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSkillMaps
     * const classSkillMap = await prisma.classSkillMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassSkillMapUpdateManyArgs>(args: SelectSubset<T, ClassSkillMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassSkillMap.
     * @param {ClassSkillMapUpsertArgs} args - Arguments to update or create a ClassSkillMap.
     * @example
     * // Update or create a ClassSkillMap
     * const classSkillMap = await prisma.classSkillMap.upsert({
     *   create: {
     *     // ... data to create a ClassSkillMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSkillMap we want to update
     *   }
     * })
     */
    upsert<T extends ClassSkillMapUpsertArgs>(args: SelectSubset<T, ClassSkillMapUpsertArgs<ExtArgs>>): Prisma__ClassSkillMapClient<$Result.GetResult<Prisma.$ClassSkillMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassSkillMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillMapCountArgs} args - Arguments to filter ClassSkillMaps to count.
     * @example
     * // Count the number of ClassSkillMaps
     * const count = await prisma.classSkillMap.count({
     *   where: {
     *     // ... the filter for the ClassSkillMaps we want to count
     *   }
     * })
    **/
    count<T extends ClassSkillMapCountArgs>(
      args?: Subset<T, ClassSkillMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassSkillMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSkillMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassSkillMapAggregateArgs>(args: Subset<T, ClassSkillMapAggregateArgs>): Prisma.PrismaPromise<GetClassSkillMapAggregateType<T>>

    /**
     * Group by ClassSkillMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassSkillMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassSkillMapGroupByArgs['orderBy'] }
        : { orderBy?: ClassSkillMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassSkillMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassSkillMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSkillMap model
   */
  readonly fields: ClassSkillMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSkillMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassSkillMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassSkillMap model
   */
  interface ClassSkillMapFieldRefs {
    readonly id: FieldRef<"ClassSkillMap", 'Int'>
    readonly classId: FieldRef<"ClassSkillMap", 'Int'>
    readonly skillId: FieldRef<"ClassSkillMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClassSkillMap findUnique
   */
  export type ClassSkillMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
    /**
     * Filter, which ClassSkillMap to fetch.
     */
    where: ClassSkillMapWhereUniqueInput
  }

  /**
   * ClassSkillMap findUniqueOrThrow
   */
  export type ClassSkillMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
    /**
     * Filter, which ClassSkillMap to fetch.
     */
    where: ClassSkillMapWhereUniqueInput
  }

  /**
   * ClassSkillMap findFirst
   */
  export type ClassSkillMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
    /**
     * Filter, which ClassSkillMap to fetch.
     */
    where?: ClassSkillMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSkillMaps to fetch.
     */
    orderBy?: ClassSkillMapOrderByWithRelationInput | ClassSkillMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSkillMaps.
     */
    cursor?: ClassSkillMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSkillMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSkillMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSkillMaps.
     */
    distinct?: ClassSkillMapScalarFieldEnum | ClassSkillMapScalarFieldEnum[]
  }

  /**
   * ClassSkillMap findFirstOrThrow
   */
  export type ClassSkillMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
    /**
     * Filter, which ClassSkillMap to fetch.
     */
    where?: ClassSkillMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSkillMaps to fetch.
     */
    orderBy?: ClassSkillMapOrderByWithRelationInput | ClassSkillMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSkillMaps.
     */
    cursor?: ClassSkillMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSkillMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSkillMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSkillMaps.
     */
    distinct?: ClassSkillMapScalarFieldEnum | ClassSkillMapScalarFieldEnum[]
  }

  /**
   * ClassSkillMap findMany
   */
  export type ClassSkillMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
    /**
     * Filter, which ClassSkillMaps to fetch.
     */
    where?: ClassSkillMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSkillMaps to fetch.
     */
    orderBy?: ClassSkillMapOrderByWithRelationInput | ClassSkillMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSkillMaps.
     */
    cursor?: ClassSkillMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSkillMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSkillMaps.
     */
    skip?: number
    distinct?: ClassSkillMapScalarFieldEnum | ClassSkillMapScalarFieldEnum[]
  }

  /**
   * ClassSkillMap create
   */
  export type ClassSkillMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSkillMap.
     */
    data: XOR<ClassSkillMapCreateInput, ClassSkillMapUncheckedCreateInput>
  }

  /**
   * ClassSkillMap createMany
   */
  export type ClassSkillMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSkillMaps.
     */
    data: ClassSkillMapCreateManyInput | ClassSkillMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassSkillMap update
   */
  export type ClassSkillMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSkillMap.
     */
    data: XOR<ClassSkillMapUpdateInput, ClassSkillMapUncheckedUpdateInput>
    /**
     * Choose, which ClassSkillMap to update.
     */
    where: ClassSkillMapWhereUniqueInput
  }

  /**
   * ClassSkillMap updateMany
   */
  export type ClassSkillMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSkillMaps.
     */
    data: XOR<ClassSkillMapUpdateManyMutationInput, ClassSkillMapUncheckedUpdateManyInput>
    /**
     * Filter which ClassSkillMaps to update
     */
    where?: ClassSkillMapWhereInput
    /**
     * Limit how many ClassSkillMaps to update.
     */
    limit?: number
  }

  /**
   * ClassSkillMap upsert
   */
  export type ClassSkillMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSkillMap to update in case it exists.
     */
    where: ClassSkillMapWhereUniqueInput
    /**
     * In case the ClassSkillMap found by the `where` argument doesn't exist, create a new ClassSkillMap with this data.
     */
    create: XOR<ClassSkillMapCreateInput, ClassSkillMapUncheckedCreateInput>
    /**
     * In case the ClassSkillMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassSkillMapUpdateInput, ClassSkillMapUncheckedUpdateInput>
  }

  /**
   * ClassSkillMap delete
   */
  export type ClassSkillMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
    /**
     * Filter which ClassSkillMap to delete.
     */
    where: ClassSkillMapWhereUniqueInput
  }

  /**
   * ClassSkillMap deleteMany
   */
  export type ClassSkillMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSkillMaps to delete
     */
    where?: ClassSkillMapWhereInput
    /**
     * Limit how many ClassSkillMaps to delete.
     */
    limit?: number
  }

  /**
   * ClassSkillMap without action
   */
  export type ClassSkillMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
  }


  /**
   * Model ClassSourceMap
   */

  export type AggregateClassSourceMap = {
    _count: ClassSourceMapCountAggregateOutputType | null
    _avg: ClassSourceMapAvgAggregateOutputType | null
    _sum: ClassSourceMapSumAggregateOutputType | null
    _min: ClassSourceMapMinAggregateOutputType | null
    _max: ClassSourceMapMaxAggregateOutputType | null
  }

  export type ClassSourceMapAvgAggregateOutputType = {
    id: number | null
    classId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type ClassSourceMapSumAggregateOutputType = {
    id: number | null
    classId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type ClassSourceMapMinAggregateOutputType = {
    id: number | null
    classId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type ClassSourceMapMaxAggregateOutputType = {
    id: number | null
    classId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type ClassSourceMapCountAggregateOutputType = {
    id: number
    classId: number
    bookId: number
    pageNumber: number
    sourceBookId: number
    _all: number
  }


  export type ClassSourceMapAvgAggregateInputType = {
    id?: true
    classId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type ClassSourceMapSumAggregateInputType = {
    id?: true
    classId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type ClassSourceMapMinAggregateInputType = {
    id?: true
    classId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type ClassSourceMapMaxAggregateInputType = {
    id?: true
    classId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type ClassSourceMapCountAggregateInputType = {
    id?: true
    classId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
    _all?: true
  }

  export type ClassSourceMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSourceMap to aggregate.
     */
    where?: ClassSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSourceMaps to fetch.
     */
    orderBy?: ClassSourceMapOrderByWithRelationInput | ClassSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSourceMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSourceMaps
    **/
    _count?: true | ClassSourceMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassSourceMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSourceMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassSourceMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassSourceMapMaxAggregateInputType
  }

  export type GetClassSourceMapAggregateType<T extends ClassSourceMapAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSourceMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSourceMap[P]>
      : GetScalarType<T[P], AggregateClassSourceMap[P]>
  }




  export type ClassSourceMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSourceMapWhereInput
    orderBy?: ClassSourceMapOrderByWithAggregationInput | ClassSourceMapOrderByWithAggregationInput[]
    by: ClassSourceMapScalarFieldEnum[] | ClassSourceMapScalarFieldEnum
    having?: ClassSourceMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassSourceMapCountAggregateInputType | true
    _avg?: ClassSourceMapAvgAggregateInputType
    _sum?: ClassSourceMapSumAggregateInputType
    _min?: ClassSourceMapMinAggregateInputType
    _max?: ClassSourceMapMaxAggregateInputType
  }

  export type ClassSourceMapGroupByOutputType = {
    id: number
    classId: number
    bookId: number
    pageNumber: number | null
    sourceBookId: number | null
    _count: ClassSourceMapCountAggregateOutputType | null
    _avg: ClassSourceMapAvgAggregateOutputType | null
    _sum: ClassSourceMapSumAggregateOutputType | null
    _min: ClassSourceMapMinAggregateOutputType | null
    _max: ClassSourceMapMaxAggregateOutputType | null
  }

  type GetClassSourceMapGroupByPayload<T extends ClassSourceMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassSourceMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassSourceMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassSourceMapGroupByOutputType[P]>
            : GetScalarType<T[P], ClassSourceMapGroupByOutputType[P]>
        }
      >
    >


  export type ClassSourceMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    bookId?: boolean
    pageNumber?: boolean
    sourceBookId?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    SourceBook?: boolean | ClassSourceMap$SourceBookArgs<ExtArgs>
  }, ExtArgs["result"]["classSourceMap"]>



  export type ClassSourceMapSelectScalar = {
    id?: boolean
    classId?: boolean
    bookId?: boolean
    pageNumber?: boolean
    sourceBookId?: boolean
  }

  export type ClassSourceMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "bookId" | "pageNumber" | "sourceBookId", ExtArgs["result"]["classSourceMap"]>
  export type ClassSourceMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    SourceBook?: boolean | ClassSourceMap$SourceBookArgs<ExtArgs>
  }

  export type $ClassSourceMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSourceMap"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      SourceBook: Prisma.$SourceBookPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classId: number
      bookId: number
      pageNumber: number | null
      sourceBookId: number | null
    }, ExtArgs["result"]["classSourceMap"]>
    composites: {}
  }

  type ClassSourceMapGetPayload<S extends boolean | null | undefined | ClassSourceMapDefaultArgs> = $Result.GetResult<Prisma.$ClassSourceMapPayload, S>

  type ClassSourceMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassSourceMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassSourceMapCountAggregateInputType | true
    }

  export interface ClassSourceMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSourceMap'], meta: { name: 'ClassSourceMap' } }
    /**
     * Find zero or one ClassSourceMap that matches the filter.
     * @param {ClassSourceMapFindUniqueArgs} args - Arguments to find a ClassSourceMap
     * @example
     * // Get one ClassSourceMap
     * const classSourceMap = await prisma.classSourceMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassSourceMapFindUniqueArgs>(args: SelectSubset<T, ClassSourceMapFindUniqueArgs<ExtArgs>>): Prisma__ClassSourceMapClient<$Result.GetResult<Prisma.$ClassSourceMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassSourceMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassSourceMapFindUniqueOrThrowArgs} args - Arguments to find a ClassSourceMap
     * @example
     * // Get one ClassSourceMap
     * const classSourceMap = await prisma.classSourceMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassSourceMapFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassSourceMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassSourceMapClient<$Result.GetResult<Prisma.$ClassSourceMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSourceMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSourceMapFindFirstArgs} args - Arguments to find a ClassSourceMap
     * @example
     * // Get one ClassSourceMap
     * const classSourceMap = await prisma.classSourceMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassSourceMapFindFirstArgs>(args?: SelectSubset<T, ClassSourceMapFindFirstArgs<ExtArgs>>): Prisma__ClassSourceMapClient<$Result.GetResult<Prisma.$ClassSourceMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSourceMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSourceMapFindFirstOrThrowArgs} args - Arguments to find a ClassSourceMap
     * @example
     * // Get one ClassSourceMap
     * const classSourceMap = await prisma.classSourceMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassSourceMapFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassSourceMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassSourceMapClient<$Result.GetResult<Prisma.$ClassSourceMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassSourceMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSourceMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSourceMaps
     * const classSourceMaps = await prisma.classSourceMap.findMany()
     * 
     * // Get first 10 ClassSourceMaps
     * const classSourceMaps = await prisma.classSourceMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classSourceMapWithIdOnly = await prisma.classSourceMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassSourceMapFindManyArgs>(args?: SelectSubset<T, ClassSourceMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSourceMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassSourceMap.
     * @param {ClassSourceMapCreateArgs} args - Arguments to create a ClassSourceMap.
     * @example
     * // Create one ClassSourceMap
     * const ClassSourceMap = await prisma.classSourceMap.create({
     *   data: {
     *     // ... data to create a ClassSourceMap
     *   }
     * })
     * 
     */
    create<T extends ClassSourceMapCreateArgs>(args: SelectSubset<T, ClassSourceMapCreateArgs<ExtArgs>>): Prisma__ClassSourceMapClient<$Result.GetResult<Prisma.$ClassSourceMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassSourceMaps.
     * @param {ClassSourceMapCreateManyArgs} args - Arguments to create many ClassSourceMaps.
     * @example
     * // Create many ClassSourceMaps
     * const classSourceMap = await prisma.classSourceMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassSourceMapCreateManyArgs>(args?: SelectSubset<T, ClassSourceMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassSourceMap.
     * @param {ClassSourceMapDeleteArgs} args - Arguments to delete one ClassSourceMap.
     * @example
     * // Delete one ClassSourceMap
     * const ClassSourceMap = await prisma.classSourceMap.delete({
     *   where: {
     *     // ... filter to delete one ClassSourceMap
     *   }
     * })
     * 
     */
    delete<T extends ClassSourceMapDeleteArgs>(args: SelectSubset<T, ClassSourceMapDeleteArgs<ExtArgs>>): Prisma__ClassSourceMapClient<$Result.GetResult<Prisma.$ClassSourceMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassSourceMap.
     * @param {ClassSourceMapUpdateArgs} args - Arguments to update one ClassSourceMap.
     * @example
     * // Update one ClassSourceMap
     * const classSourceMap = await prisma.classSourceMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassSourceMapUpdateArgs>(args: SelectSubset<T, ClassSourceMapUpdateArgs<ExtArgs>>): Prisma__ClassSourceMapClient<$Result.GetResult<Prisma.$ClassSourceMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassSourceMaps.
     * @param {ClassSourceMapDeleteManyArgs} args - Arguments to filter ClassSourceMaps to delete.
     * @example
     * // Delete a few ClassSourceMaps
     * const { count } = await prisma.classSourceMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassSourceMapDeleteManyArgs>(args?: SelectSubset<T, ClassSourceMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSourceMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSourceMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSourceMaps
     * const classSourceMap = await prisma.classSourceMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassSourceMapUpdateManyArgs>(args: SelectSubset<T, ClassSourceMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassSourceMap.
     * @param {ClassSourceMapUpsertArgs} args - Arguments to update or create a ClassSourceMap.
     * @example
     * // Update or create a ClassSourceMap
     * const classSourceMap = await prisma.classSourceMap.upsert({
     *   create: {
     *     // ... data to create a ClassSourceMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSourceMap we want to update
     *   }
     * })
     */
    upsert<T extends ClassSourceMapUpsertArgs>(args: SelectSubset<T, ClassSourceMapUpsertArgs<ExtArgs>>): Prisma__ClassSourceMapClient<$Result.GetResult<Prisma.$ClassSourceMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassSourceMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSourceMapCountArgs} args - Arguments to filter ClassSourceMaps to count.
     * @example
     * // Count the number of ClassSourceMaps
     * const count = await prisma.classSourceMap.count({
     *   where: {
     *     // ... the filter for the ClassSourceMaps we want to count
     *   }
     * })
    **/
    count<T extends ClassSourceMapCountArgs>(
      args?: Subset<T, ClassSourceMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassSourceMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSourceMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSourceMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassSourceMapAggregateArgs>(args: Subset<T, ClassSourceMapAggregateArgs>): Prisma.PrismaPromise<GetClassSourceMapAggregateType<T>>

    /**
     * Group by ClassSourceMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSourceMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassSourceMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassSourceMapGroupByArgs['orderBy'] }
        : { orderBy?: ClassSourceMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassSourceMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassSourceMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSourceMap model
   */
  readonly fields: ClassSourceMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSourceMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassSourceMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SourceBook<T extends ClassSourceMap$SourceBookArgs<ExtArgs> = {}>(args?: Subset<T, ClassSourceMap$SourceBookArgs<ExtArgs>>): Prisma__SourceBookClient<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassSourceMap model
   */
  interface ClassSourceMapFieldRefs {
    readonly id: FieldRef<"ClassSourceMap", 'Int'>
    readonly classId: FieldRef<"ClassSourceMap", 'Int'>
    readonly bookId: FieldRef<"ClassSourceMap", 'Int'>
    readonly pageNumber: FieldRef<"ClassSourceMap", 'Int'>
    readonly sourceBookId: FieldRef<"ClassSourceMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClassSourceMap findUnique
   */
  export type ClassSourceMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which ClassSourceMap to fetch.
     */
    where: ClassSourceMapWhereUniqueInput
  }

  /**
   * ClassSourceMap findUniqueOrThrow
   */
  export type ClassSourceMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which ClassSourceMap to fetch.
     */
    where: ClassSourceMapWhereUniqueInput
  }

  /**
   * ClassSourceMap findFirst
   */
  export type ClassSourceMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which ClassSourceMap to fetch.
     */
    where?: ClassSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSourceMaps to fetch.
     */
    orderBy?: ClassSourceMapOrderByWithRelationInput | ClassSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSourceMaps.
     */
    cursor?: ClassSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSourceMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSourceMaps.
     */
    distinct?: ClassSourceMapScalarFieldEnum | ClassSourceMapScalarFieldEnum[]
  }

  /**
   * ClassSourceMap findFirstOrThrow
   */
  export type ClassSourceMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which ClassSourceMap to fetch.
     */
    where?: ClassSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSourceMaps to fetch.
     */
    orderBy?: ClassSourceMapOrderByWithRelationInput | ClassSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSourceMaps.
     */
    cursor?: ClassSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSourceMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSourceMaps.
     */
    distinct?: ClassSourceMapScalarFieldEnum | ClassSourceMapScalarFieldEnum[]
  }

  /**
   * ClassSourceMap findMany
   */
  export type ClassSourceMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which ClassSourceMaps to fetch.
     */
    where?: ClassSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSourceMaps to fetch.
     */
    orderBy?: ClassSourceMapOrderByWithRelationInput | ClassSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSourceMaps.
     */
    cursor?: ClassSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSourceMaps.
     */
    skip?: number
    distinct?: ClassSourceMapScalarFieldEnum | ClassSourceMapScalarFieldEnum[]
  }

  /**
   * ClassSourceMap create
   */
  export type ClassSourceMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSourceMap.
     */
    data: XOR<ClassSourceMapCreateInput, ClassSourceMapUncheckedCreateInput>
  }

  /**
   * ClassSourceMap createMany
   */
  export type ClassSourceMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSourceMaps.
     */
    data: ClassSourceMapCreateManyInput | ClassSourceMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassSourceMap update
   */
  export type ClassSourceMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSourceMap.
     */
    data: XOR<ClassSourceMapUpdateInput, ClassSourceMapUncheckedUpdateInput>
    /**
     * Choose, which ClassSourceMap to update.
     */
    where: ClassSourceMapWhereUniqueInput
  }

  /**
   * ClassSourceMap updateMany
   */
  export type ClassSourceMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSourceMaps.
     */
    data: XOR<ClassSourceMapUpdateManyMutationInput, ClassSourceMapUncheckedUpdateManyInput>
    /**
     * Filter which ClassSourceMaps to update
     */
    where?: ClassSourceMapWhereInput
    /**
     * Limit how many ClassSourceMaps to update.
     */
    limit?: number
  }

  /**
   * ClassSourceMap upsert
   */
  export type ClassSourceMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSourceMap to update in case it exists.
     */
    where: ClassSourceMapWhereUniqueInput
    /**
     * In case the ClassSourceMap found by the `where` argument doesn't exist, create a new ClassSourceMap with this data.
     */
    create: XOR<ClassSourceMapCreateInput, ClassSourceMapUncheckedCreateInput>
    /**
     * In case the ClassSourceMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassSourceMapUpdateInput, ClassSourceMapUncheckedUpdateInput>
  }

  /**
   * ClassSourceMap delete
   */
  export type ClassSourceMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
    /**
     * Filter which ClassSourceMap to delete.
     */
    where: ClassSourceMapWhereUniqueInput
  }

  /**
   * ClassSourceMap deleteMany
   */
  export type ClassSourceMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSourceMaps to delete
     */
    where?: ClassSourceMapWhereInput
    /**
     * Limit how many ClassSourceMaps to delete.
     */
    limit?: number
  }

  /**
   * ClassSourceMap.SourceBook
   */
  export type ClassSourceMap$SourceBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    where?: SourceBookWhereInput
  }

  /**
   * ClassSourceMap without action
   */
  export type ClassSourceMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
  }


  /**
   * Model SpellLevelMap
   */

  export type AggregateSpellLevelMap = {
    _count: SpellLevelMapCountAggregateOutputType | null
    _avg: SpellLevelMapAvgAggregateOutputType | null
    _sum: SpellLevelMapSumAggregateOutputType | null
    _min: SpellLevelMapMinAggregateOutputType | null
    _max: SpellLevelMapMaxAggregateOutputType | null
  }

  export type SpellLevelMapAvgAggregateOutputType = {
    id: number | null
    classId: number | null
    spellId: number | null
    level: number | null
  }

  export type SpellLevelMapSumAggregateOutputType = {
    id: number | null
    classId: number | null
    spellId: number | null
    level: number | null
  }

  export type SpellLevelMapMinAggregateOutputType = {
    id: number | null
    classId: number | null
    spellId: number | null
    level: number | null
    isVisible: boolean | null
  }

  export type SpellLevelMapMaxAggregateOutputType = {
    id: number | null
    classId: number | null
    spellId: number | null
    level: number | null
    isVisible: boolean | null
  }

  export type SpellLevelMapCountAggregateOutputType = {
    id: number
    classId: number
    spellId: number
    level: number
    isVisible: number
    _all: number
  }


  export type SpellLevelMapAvgAggregateInputType = {
    id?: true
    classId?: true
    spellId?: true
    level?: true
  }

  export type SpellLevelMapSumAggregateInputType = {
    id?: true
    classId?: true
    spellId?: true
    level?: true
  }

  export type SpellLevelMapMinAggregateInputType = {
    id?: true
    classId?: true
    spellId?: true
    level?: true
    isVisible?: true
  }

  export type SpellLevelMapMaxAggregateInputType = {
    id?: true
    classId?: true
    spellId?: true
    level?: true
    isVisible?: true
  }

  export type SpellLevelMapCountAggregateInputType = {
    id?: true
    classId?: true
    spellId?: true
    level?: true
    isVisible?: true
    _all?: true
  }

  export type SpellLevelMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellLevelMap to aggregate.
     */
    where?: SpellLevelMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellLevelMaps to fetch.
     */
    orderBy?: SpellLevelMapOrderByWithRelationInput | SpellLevelMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellLevelMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellLevelMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellLevelMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellLevelMaps
    **/
    _count?: true | SpellLevelMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellLevelMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellLevelMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellLevelMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellLevelMapMaxAggregateInputType
  }

  export type GetSpellLevelMapAggregateType<T extends SpellLevelMapAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellLevelMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellLevelMap[P]>
      : GetScalarType<T[P], AggregateSpellLevelMap[P]>
  }




  export type SpellLevelMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellLevelMapWhereInput
    orderBy?: SpellLevelMapOrderByWithAggregationInput | SpellLevelMapOrderByWithAggregationInput[]
    by: SpellLevelMapScalarFieldEnum[] | SpellLevelMapScalarFieldEnum
    having?: SpellLevelMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellLevelMapCountAggregateInputType | true
    _avg?: SpellLevelMapAvgAggregateInputType
    _sum?: SpellLevelMapSumAggregateInputType
    _min?: SpellLevelMapMinAggregateInputType
    _max?: SpellLevelMapMaxAggregateInputType
  }

  export type SpellLevelMapGroupByOutputType = {
    id: number
    classId: number
    spellId: number
    level: number
    isVisible: boolean
    _count: SpellLevelMapCountAggregateOutputType | null
    _avg: SpellLevelMapAvgAggregateOutputType | null
    _sum: SpellLevelMapSumAggregateOutputType | null
    _min: SpellLevelMapMinAggregateOutputType | null
    _max: SpellLevelMapMaxAggregateOutputType | null
  }

  type GetSpellLevelMapGroupByPayload<T extends SpellLevelMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellLevelMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellLevelMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellLevelMapGroupByOutputType[P]>
            : GetScalarType<T[P], SpellLevelMapGroupByOutputType[P]>
        }
      >
    >


  export type SpellLevelMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    spellId?: boolean
    level?: boolean
    isVisible?: boolean
    spell?: boolean | SpellDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellLevelMap"]>



  export type SpellLevelMapSelectScalar = {
    id?: boolean
    classId?: boolean
    spellId?: boolean
    level?: boolean
    isVisible?: boolean
  }

  export type SpellLevelMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "spellId" | "level" | "isVisible", ExtArgs["result"]["spellLevelMap"]>
  export type SpellLevelMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $SpellLevelMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellLevelMap"
    objects: {
      spell: Prisma.$SpellPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classId: number
      spellId: number
      level: number
      isVisible: boolean
    }, ExtArgs["result"]["spellLevelMap"]>
    composites: {}
  }

  type SpellLevelMapGetPayload<S extends boolean | null | undefined | SpellLevelMapDefaultArgs> = $Result.GetResult<Prisma.$SpellLevelMapPayload, S>

  type SpellLevelMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellLevelMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellLevelMapCountAggregateInputType | true
    }

  export interface SpellLevelMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellLevelMap'], meta: { name: 'SpellLevelMap' } }
    /**
     * Find zero or one SpellLevelMap that matches the filter.
     * @param {SpellLevelMapFindUniqueArgs} args - Arguments to find a SpellLevelMap
     * @example
     * // Get one SpellLevelMap
     * const spellLevelMap = await prisma.spellLevelMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellLevelMapFindUniqueArgs>(args: SelectSubset<T, SpellLevelMapFindUniqueArgs<ExtArgs>>): Prisma__SpellLevelMapClient<$Result.GetResult<Prisma.$SpellLevelMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpellLevelMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellLevelMapFindUniqueOrThrowArgs} args - Arguments to find a SpellLevelMap
     * @example
     * // Get one SpellLevelMap
     * const spellLevelMap = await prisma.spellLevelMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellLevelMapFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellLevelMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellLevelMapClient<$Result.GetResult<Prisma.$SpellLevelMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellLevelMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellLevelMapFindFirstArgs} args - Arguments to find a SpellLevelMap
     * @example
     * // Get one SpellLevelMap
     * const spellLevelMap = await prisma.spellLevelMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellLevelMapFindFirstArgs>(args?: SelectSubset<T, SpellLevelMapFindFirstArgs<ExtArgs>>): Prisma__SpellLevelMapClient<$Result.GetResult<Prisma.$SpellLevelMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellLevelMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellLevelMapFindFirstOrThrowArgs} args - Arguments to find a SpellLevelMap
     * @example
     * // Get one SpellLevelMap
     * const spellLevelMap = await prisma.spellLevelMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellLevelMapFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellLevelMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellLevelMapClient<$Result.GetResult<Prisma.$SpellLevelMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpellLevelMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellLevelMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellLevelMaps
     * const spellLevelMaps = await prisma.spellLevelMap.findMany()
     * 
     * // Get first 10 SpellLevelMaps
     * const spellLevelMaps = await prisma.spellLevelMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellLevelMapWithIdOnly = await prisma.spellLevelMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpellLevelMapFindManyArgs>(args?: SelectSubset<T, SpellLevelMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellLevelMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpellLevelMap.
     * @param {SpellLevelMapCreateArgs} args - Arguments to create a SpellLevelMap.
     * @example
     * // Create one SpellLevelMap
     * const SpellLevelMap = await prisma.spellLevelMap.create({
     *   data: {
     *     // ... data to create a SpellLevelMap
     *   }
     * })
     * 
     */
    create<T extends SpellLevelMapCreateArgs>(args: SelectSubset<T, SpellLevelMapCreateArgs<ExtArgs>>): Prisma__SpellLevelMapClient<$Result.GetResult<Prisma.$SpellLevelMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpellLevelMaps.
     * @param {SpellLevelMapCreateManyArgs} args - Arguments to create many SpellLevelMaps.
     * @example
     * // Create many SpellLevelMaps
     * const spellLevelMap = await prisma.spellLevelMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellLevelMapCreateManyArgs>(args?: SelectSubset<T, SpellLevelMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellLevelMap.
     * @param {SpellLevelMapDeleteArgs} args - Arguments to delete one SpellLevelMap.
     * @example
     * // Delete one SpellLevelMap
     * const SpellLevelMap = await prisma.spellLevelMap.delete({
     *   where: {
     *     // ... filter to delete one SpellLevelMap
     *   }
     * })
     * 
     */
    delete<T extends SpellLevelMapDeleteArgs>(args: SelectSubset<T, SpellLevelMapDeleteArgs<ExtArgs>>): Prisma__SpellLevelMapClient<$Result.GetResult<Prisma.$SpellLevelMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpellLevelMap.
     * @param {SpellLevelMapUpdateArgs} args - Arguments to update one SpellLevelMap.
     * @example
     * // Update one SpellLevelMap
     * const spellLevelMap = await prisma.spellLevelMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellLevelMapUpdateArgs>(args: SelectSubset<T, SpellLevelMapUpdateArgs<ExtArgs>>): Prisma__SpellLevelMapClient<$Result.GetResult<Prisma.$SpellLevelMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpellLevelMaps.
     * @param {SpellLevelMapDeleteManyArgs} args - Arguments to filter SpellLevelMaps to delete.
     * @example
     * // Delete a few SpellLevelMaps
     * const { count } = await prisma.spellLevelMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellLevelMapDeleteManyArgs>(args?: SelectSubset<T, SpellLevelMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellLevelMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellLevelMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellLevelMaps
     * const spellLevelMap = await prisma.spellLevelMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellLevelMapUpdateManyArgs>(args: SelectSubset<T, SpellLevelMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellLevelMap.
     * @param {SpellLevelMapUpsertArgs} args - Arguments to update or create a SpellLevelMap.
     * @example
     * // Update or create a SpellLevelMap
     * const spellLevelMap = await prisma.spellLevelMap.upsert({
     *   create: {
     *     // ... data to create a SpellLevelMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellLevelMap we want to update
     *   }
     * })
     */
    upsert<T extends SpellLevelMapUpsertArgs>(args: SelectSubset<T, SpellLevelMapUpsertArgs<ExtArgs>>): Prisma__SpellLevelMapClient<$Result.GetResult<Prisma.$SpellLevelMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpellLevelMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellLevelMapCountArgs} args - Arguments to filter SpellLevelMaps to count.
     * @example
     * // Count the number of SpellLevelMaps
     * const count = await prisma.spellLevelMap.count({
     *   where: {
     *     // ... the filter for the SpellLevelMaps we want to count
     *   }
     * })
    **/
    count<T extends SpellLevelMapCountArgs>(
      args?: Subset<T, SpellLevelMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellLevelMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellLevelMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellLevelMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellLevelMapAggregateArgs>(args: Subset<T, SpellLevelMapAggregateArgs>): Prisma.PrismaPromise<GetSpellLevelMapAggregateType<T>>

    /**
     * Group by SpellLevelMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellLevelMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellLevelMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellLevelMapGroupByArgs['orderBy'] }
        : { orderBy?: SpellLevelMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellLevelMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellLevelMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellLevelMap model
   */
  readonly fields: SpellLevelMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellLevelMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellLevelMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpellLevelMap model
   */
  interface SpellLevelMapFieldRefs {
    readonly id: FieldRef<"SpellLevelMap", 'Int'>
    readonly classId: FieldRef<"SpellLevelMap", 'Int'>
    readonly spellId: FieldRef<"SpellLevelMap", 'Int'>
    readonly level: FieldRef<"SpellLevelMap", 'Int'>
    readonly isVisible: FieldRef<"SpellLevelMap", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SpellLevelMap findUnique
   */
  export type SpellLevelMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellLevelMap to fetch.
     */
    where: SpellLevelMapWhereUniqueInput
  }

  /**
   * SpellLevelMap findUniqueOrThrow
   */
  export type SpellLevelMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellLevelMap to fetch.
     */
    where: SpellLevelMapWhereUniqueInput
  }

  /**
   * SpellLevelMap findFirst
   */
  export type SpellLevelMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellLevelMap to fetch.
     */
    where?: SpellLevelMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellLevelMaps to fetch.
     */
    orderBy?: SpellLevelMapOrderByWithRelationInput | SpellLevelMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellLevelMaps.
     */
    cursor?: SpellLevelMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellLevelMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellLevelMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellLevelMaps.
     */
    distinct?: SpellLevelMapScalarFieldEnum | SpellLevelMapScalarFieldEnum[]
  }

  /**
   * SpellLevelMap findFirstOrThrow
   */
  export type SpellLevelMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellLevelMap to fetch.
     */
    where?: SpellLevelMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellLevelMaps to fetch.
     */
    orderBy?: SpellLevelMapOrderByWithRelationInput | SpellLevelMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellLevelMaps.
     */
    cursor?: SpellLevelMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellLevelMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellLevelMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellLevelMaps.
     */
    distinct?: SpellLevelMapScalarFieldEnum | SpellLevelMapScalarFieldEnum[]
  }

  /**
   * SpellLevelMap findMany
   */
  export type SpellLevelMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellLevelMaps to fetch.
     */
    where?: SpellLevelMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellLevelMaps to fetch.
     */
    orderBy?: SpellLevelMapOrderByWithRelationInput | SpellLevelMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellLevelMaps.
     */
    cursor?: SpellLevelMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellLevelMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellLevelMaps.
     */
    skip?: number
    distinct?: SpellLevelMapScalarFieldEnum | SpellLevelMapScalarFieldEnum[]
  }

  /**
   * SpellLevelMap create
   */
  export type SpellLevelMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellLevelMap.
     */
    data: XOR<SpellLevelMapCreateInput, SpellLevelMapUncheckedCreateInput>
  }

  /**
   * SpellLevelMap createMany
   */
  export type SpellLevelMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellLevelMaps.
     */
    data: SpellLevelMapCreateManyInput | SpellLevelMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpellLevelMap update
   */
  export type SpellLevelMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellLevelMap.
     */
    data: XOR<SpellLevelMapUpdateInput, SpellLevelMapUncheckedUpdateInput>
    /**
     * Choose, which SpellLevelMap to update.
     */
    where: SpellLevelMapWhereUniqueInput
  }

  /**
   * SpellLevelMap updateMany
   */
  export type SpellLevelMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellLevelMaps.
     */
    data: XOR<SpellLevelMapUpdateManyMutationInput, SpellLevelMapUncheckedUpdateManyInput>
    /**
     * Filter which SpellLevelMaps to update
     */
    where?: SpellLevelMapWhereInput
    /**
     * Limit how many SpellLevelMaps to update.
     */
    limit?: number
  }

  /**
   * SpellLevelMap upsert
   */
  export type SpellLevelMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellLevelMap to update in case it exists.
     */
    where: SpellLevelMapWhereUniqueInput
    /**
     * In case the SpellLevelMap found by the `where` argument doesn't exist, create a new SpellLevelMap with this data.
     */
    create: XOR<SpellLevelMapCreateInput, SpellLevelMapUncheckedCreateInput>
    /**
     * In case the SpellLevelMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellLevelMapUpdateInput, SpellLevelMapUncheckedUpdateInput>
  }

  /**
   * SpellLevelMap delete
   */
  export type SpellLevelMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
    /**
     * Filter which SpellLevelMap to delete.
     */
    where: SpellLevelMapWhereUniqueInput
  }

  /**
   * SpellLevelMap deleteMany
   */
  export type SpellLevelMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellLevelMaps to delete
     */
    where?: SpellLevelMapWhereInput
    /**
     * Limit how many SpellLevelMaps to delete.
     */
    limit?: number
  }

  /**
   * SpellLevelMap without action
   */
  export type SpellLevelMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
  }


  /**
   * Model Spell
   */

  export type AggregateSpell = {
    _count: SpellCountAggregateOutputType | null
    _avg: SpellAvgAggregateOutputType | null
    _sum: SpellSumAggregateOutputType | null
    _min: SpellMinAggregateOutputType | null
    _max: SpellMaxAggregateOutputType | null
  }

  export type SpellAvgAggregateOutputType = {
    id: number | null
    rangeTypeId: number | null
    editionId: number | null
    baseLevel: number | null
  }

  export type SpellSumAggregateOutputType = {
    id: number | null
    rangeTypeId: number | null
    editionId: number | null
    baseLevel: number | null
  }

  export type SpellMinAggregateOutputType = {
    id: number | null
    name: string | null
    summary: string | null
    description: string | null
    castingTime: string | null
    range: string | null
    rangeTypeId: number | null
    rangeValue: string | null
    area: string | null
    duration: string | null
    savingThrow: string | null
    spellResistance: string | null
    editionId: number | null
    baseLevel: number | null
    effect: string | null
    target: string | null
  }

  export type SpellMaxAggregateOutputType = {
    id: number | null
    name: string | null
    summary: string | null
    description: string | null
    castingTime: string | null
    range: string | null
    rangeTypeId: number | null
    rangeValue: string | null
    area: string | null
    duration: string | null
    savingThrow: string | null
    spellResistance: string | null
    editionId: number | null
    baseLevel: number | null
    effect: string | null
    target: string | null
  }

  export type SpellCountAggregateOutputType = {
    id: number
    name: number
    summary: number
    description: number
    castingTime: number
    range: number
    rangeTypeId: number
    rangeValue: number
    area: number
    duration: number
    savingThrow: number
    spellResistance: number
    editionId: number
    baseLevel: number
    effect: number
    target: number
    _all: number
  }


  export type SpellAvgAggregateInputType = {
    id?: true
    rangeTypeId?: true
    editionId?: true
    baseLevel?: true
  }

  export type SpellSumAggregateInputType = {
    id?: true
    rangeTypeId?: true
    editionId?: true
    baseLevel?: true
  }

  export type SpellMinAggregateInputType = {
    id?: true
    name?: true
    summary?: true
    description?: true
    castingTime?: true
    range?: true
    rangeTypeId?: true
    rangeValue?: true
    area?: true
    duration?: true
    savingThrow?: true
    spellResistance?: true
    editionId?: true
    baseLevel?: true
    effect?: true
    target?: true
  }

  export type SpellMaxAggregateInputType = {
    id?: true
    name?: true
    summary?: true
    description?: true
    castingTime?: true
    range?: true
    rangeTypeId?: true
    rangeValue?: true
    area?: true
    duration?: true
    savingThrow?: true
    spellResistance?: true
    editionId?: true
    baseLevel?: true
    effect?: true
    target?: true
  }

  export type SpellCountAggregateInputType = {
    id?: true
    name?: true
    summary?: true
    description?: true
    castingTime?: true
    range?: true
    rangeTypeId?: true
    rangeValue?: true
    area?: true
    duration?: true
    savingThrow?: true
    spellResistance?: true
    editionId?: true
    baseLevel?: true
    effect?: true
    target?: true
    _all?: true
  }

  export type SpellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spell to aggregate.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spells
    **/
    _count?: true | SpellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellMaxAggregateInputType
  }

  export type GetSpellAggregateType<T extends SpellAggregateArgs> = {
        [P in keyof T & keyof AggregateSpell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpell[P]>
      : GetScalarType<T[P], AggregateSpell[P]>
  }




  export type SpellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellWhereInput
    orderBy?: SpellOrderByWithAggregationInput | SpellOrderByWithAggregationInput[]
    by: SpellScalarFieldEnum[] | SpellScalarFieldEnum
    having?: SpellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellCountAggregateInputType | true
    _avg?: SpellAvgAggregateInputType
    _sum?: SpellSumAggregateInputType
    _min?: SpellMinAggregateInputType
    _max?: SpellMaxAggregateInputType
  }

  export type SpellGroupByOutputType = {
    id: number
    name: string
    summary: string | null
    description: string | null
    castingTime: string | null
    range: string | null
    rangeTypeId: number | null
    rangeValue: string | null
    area: string | null
    duration: string | null
    savingThrow: string | null
    spellResistance: string | null
    editionId: number
    baseLevel: number
    effect: string | null
    target: string | null
    _count: SpellCountAggregateOutputType | null
    _avg: SpellAvgAggregateOutputType | null
    _sum: SpellSumAggregateOutputType | null
    _min: SpellMinAggregateOutputType | null
    _max: SpellMaxAggregateOutputType | null
  }

  type GetSpellGroupByPayload<T extends SpellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellGroupByOutputType[P]>
            : GetScalarType<T[P], SpellGroupByOutputType[P]>
        }
      >
    >


  export type SpellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    summary?: boolean
    description?: boolean
    castingTime?: boolean
    range?: boolean
    rangeTypeId?: boolean
    rangeValue?: boolean
    area?: boolean
    duration?: boolean
    savingThrow?: boolean
    spellResistance?: boolean
    editionId?: boolean
    baseLevel?: boolean
    effect?: boolean
    target?: boolean
    descriptors?: boolean | Spell$descriptorsArgs<ExtArgs>
    levelMapping?: boolean | Spell$levelMappingArgs<ExtArgs>
    schools?: boolean | Spell$schoolsArgs<ExtArgs>
    sources?: boolean | Spell$sourcesArgs<ExtArgs>
    subschools?: boolean | Spell$subschoolsArgs<ExtArgs>
    _count?: boolean | SpellCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spell"]>



  export type SpellSelectScalar = {
    id?: boolean
    name?: boolean
    summary?: boolean
    description?: boolean
    castingTime?: boolean
    range?: boolean
    rangeTypeId?: boolean
    rangeValue?: boolean
    area?: boolean
    duration?: boolean
    savingThrow?: boolean
    spellResistance?: boolean
    editionId?: boolean
    baseLevel?: boolean
    effect?: boolean
    target?: boolean
  }

  export type SpellOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "summary" | "description" | "castingTime" | "range" | "rangeTypeId" | "rangeValue" | "area" | "duration" | "savingThrow" | "spellResistance" | "editionId" | "baseLevel" | "effect" | "target", ExtArgs["result"]["spell"]>
  export type SpellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    descriptors?: boolean | Spell$descriptorsArgs<ExtArgs>
    levelMapping?: boolean | Spell$levelMappingArgs<ExtArgs>
    schools?: boolean | Spell$schoolsArgs<ExtArgs>
    sources?: boolean | Spell$sourcesArgs<ExtArgs>
    subschools?: boolean | Spell$subschoolsArgs<ExtArgs>
    _count?: boolean | SpellCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SpellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Spell"
    objects: {
      descriptors: Prisma.$SpellDescriptorMapPayload<ExtArgs>[]
      levelMapping: Prisma.$SpellLevelMapPayload<ExtArgs>[]
      schools: Prisma.$SpellSchoolMapPayload<ExtArgs>[]
      sources: Prisma.$SpellSourceMapPayload<ExtArgs>[]
      subschools: Prisma.$SpellSubschoolMapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      summary: string | null
      description: string | null
      castingTime: string | null
      range: string | null
      rangeTypeId: number | null
      rangeValue: string | null
      area: string | null
      duration: string | null
      savingThrow: string | null
      spellResistance: string | null
      editionId: number
      baseLevel: number
      effect: string | null
      target: string | null
    }, ExtArgs["result"]["spell"]>
    composites: {}
  }

  type SpellGetPayload<S extends boolean | null | undefined | SpellDefaultArgs> = $Result.GetResult<Prisma.$SpellPayload, S>

  type SpellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellCountAggregateInputType | true
    }

  export interface SpellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Spell'], meta: { name: 'Spell' } }
    /**
     * Find zero or one Spell that matches the filter.
     * @param {SpellFindUniqueArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellFindUniqueArgs>(args: SelectSubset<T, SpellFindUniqueArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Spell that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellFindUniqueOrThrowArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindFirstArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellFindFirstArgs>(args?: SelectSubset<T, SpellFindFirstArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindFirstOrThrowArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Spells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spells
     * const spells = await prisma.spell.findMany()
     * 
     * // Get first 10 Spells
     * const spells = await prisma.spell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellWithIdOnly = await prisma.spell.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpellFindManyArgs>(args?: SelectSubset<T, SpellFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Spell.
     * @param {SpellCreateArgs} args - Arguments to create a Spell.
     * @example
     * // Create one Spell
     * const Spell = await prisma.spell.create({
     *   data: {
     *     // ... data to create a Spell
     *   }
     * })
     * 
     */
    create<T extends SpellCreateArgs>(args: SelectSubset<T, SpellCreateArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Spells.
     * @param {SpellCreateManyArgs} args - Arguments to create many Spells.
     * @example
     * // Create many Spells
     * const spell = await prisma.spell.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellCreateManyArgs>(args?: SelectSubset<T, SpellCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Spell.
     * @param {SpellDeleteArgs} args - Arguments to delete one Spell.
     * @example
     * // Delete one Spell
     * const Spell = await prisma.spell.delete({
     *   where: {
     *     // ... filter to delete one Spell
     *   }
     * })
     * 
     */
    delete<T extends SpellDeleteArgs>(args: SelectSubset<T, SpellDeleteArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Spell.
     * @param {SpellUpdateArgs} args - Arguments to update one Spell.
     * @example
     * // Update one Spell
     * const spell = await prisma.spell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellUpdateArgs>(args: SelectSubset<T, SpellUpdateArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Spells.
     * @param {SpellDeleteManyArgs} args - Arguments to filter Spells to delete.
     * @example
     * // Delete a few Spells
     * const { count } = await prisma.spell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellDeleteManyArgs>(args?: SelectSubset<T, SpellDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spells
     * const spell = await prisma.spell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellUpdateManyArgs>(args: SelectSubset<T, SpellUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Spell.
     * @param {SpellUpsertArgs} args - Arguments to update or create a Spell.
     * @example
     * // Update or create a Spell
     * const spell = await prisma.spell.upsert({
     *   create: {
     *     // ... data to create a Spell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spell we want to update
     *   }
     * })
     */
    upsert<T extends SpellUpsertArgs>(args: SelectSubset<T, SpellUpsertArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Spells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellCountArgs} args - Arguments to filter Spells to count.
     * @example
     * // Count the number of Spells
     * const count = await prisma.spell.count({
     *   where: {
     *     // ... the filter for the Spells we want to count
     *   }
     * })
    **/
    count<T extends SpellCountArgs>(
      args?: Subset<T, SpellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellAggregateArgs>(args: Subset<T, SpellAggregateArgs>): Prisma.PrismaPromise<GetSpellAggregateType<T>>

    /**
     * Group by Spell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellGroupByArgs['orderBy'] }
        : { orderBy?: SpellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Spell model
   */
  readonly fields: SpellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Spell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    descriptors<T extends Spell$descriptorsArgs<ExtArgs> = {}>(args?: Subset<T, Spell$descriptorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellDescriptorMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    levelMapping<T extends Spell$levelMappingArgs<ExtArgs> = {}>(args?: Subset<T, Spell$levelMappingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellLevelMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schools<T extends Spell$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, Spell$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellSchoolMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sources<T extends Spell$sourcesArgs<ExtArgs> = {}>(args?: Subset<T, Spell$sourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellSourceMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subschools<T extends Spell$subschoolsArgs<ExtArgs> = {}>(args?: Subset<T, Spell$subschoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellSubschoolMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Spell model
   */
  interface SpellFieldRefs {
    readonly id: FieldRef<"Spell", 'Int'>
    readonly name: FieldRef<"Spell", 'String'>
    readonly summary: FieldRef<"Spell", 'String'>
    readonly description: FieldRef<"Spell", 'String'>
    readonly castingTime: FieldRef<"Spell", 'String'>
    readonly range: FieldRef<"Spell", 'String'>
    readonly rangeTypeId: FieldRef<"Spell", 'Int'>
    readonly rangeValue: FieldRef<"Spell", 'String'>
    readonly area: FieldRef<"Spell", 'String'>
    readonly duration: FieldRef<"Spell", 'String'>
    readonly savingThrow: FieldRef<"Spell", 'String'>
    readonly spellResistance: FieldRef<"Spell", 'String'>
    readonly editionId: FieldRef<"Spell", 'Int'>
    readonly baseLevel: FieldRef<"Spell", 'Int'>
    readonly effect: FieldRef<"Spell", 'String'>
    readonly target: FieldRef<"Spell", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Spell findUnique
   */
  export type SpellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where: SpellWhereUniqueInput
  }

  /**
   * Spell findUniqueOrThrow
   */
  export type SpellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where: SpellWhereUniqueInput
  }

  /**
   * Spell findFirst
   */
  export type SpellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spells.
     */
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }

  /**
   * Spell findFirstOrThrow
   */
  export type SpellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spells.
     */
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }

  /**
   * Spell findMany
   */
  export type SpellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spells to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }

  /**
   * Spell create
   */
  export type SpellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The data needed to create a Spell.
     */
    data: XOR<SpellCreateInput, SpellUncheckedCreateInput>
  }

  /**
   * Spell createMany
   */
  export type SpellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Spells.
     */
    data: SpellCreateManyInput | SpellCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Spell update
   */
  export type SpellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The data needed to update a Spell.
     */
    data: XOR<SpellUpdateInput, SpellUncheckedUpdateInput>
    /**
     * Choose, which Spell to update.
     */
    where: SpellWhereUniqueInput
  }

  /**
   * Spell updateMany
   */
  export type SpellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Spells.
     */
    data: XOR<SpellUpdateManyMutationInput, SpellUncheckedUpdateManyInput>
    /**
     * Filter which Spells to update
     */
    where?: SpellWhereInput
    /**
     * Limit how many Spells to update.
     */
    limit?: number
  }

  /**
   * Spell upsert
   */
  export type SpellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The filter to search for the Spell to update in case it exists.
     */
    where: SpellWhereUniqueInput
    /**
     * In case the Spell found by the `where` argument doesn't exist, create a new Spell with this data.
     */
    create: XOR<SpellCreateInput, SpellUncheckedCreateInput>
    /**
     * In case the Spell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellUpdateInput, SpellUncheckedUpdateInput>
  }

  /**
   * Spell delete
   */
  export type SpellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter which Spell to delete.
     */
    where: SpellWhereUniqueInput
  }

  /**
   * Spell deleteMany
   */
  export type SpellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spells to delete
     */
    where?: SpellWhereInput
    /**
     * Limit how many Spells to delete.
     */
    limit?: number
  }

  /**
   * Spell.descriptors
   */
  export type Spell$descriptorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellDescriptorMap
     */
    select?: SpellDescriptorMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellDescriptorMap
     */
    omit?: SpellDescriptorMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellDescriptorMapInclude<ExtArgs> | null
    where?: SpellDescriptorMapWhereInput
    orderBy?: SpellDescriptorMapOrderByWithRelationInput | SpellDescriptorMapOrderByWithRelationInput[]
    cursor?: SpellDescriptorMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellDescriptorMapScalarFieldEnum | SpellDescriptorMapScalarFieldEnum[]
  }

  /**
   * Spell.levelMapping
   */
  export type Spell$levelMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellLevelMap
     */
    select?: SpellLevelMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellLevelMap
     */
    omit?: SpellLevelMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellLevelMapInclude<ExtArgs> | null
    where?: SpellLevelMapWhereInput
    orderBy?: SpellLevelMapOrderByWithRelationInput | SpellLevelMapOrderByWithRelationInput[]
    cursor?: SpellLevelMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellLevelMapScalarFieldEnum | SpellLevelMapScalarFieldEnum[]
  }

  /**
   * Spell.schools
   */
  export type Spell$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolMap
     */
    select?: SpellSchoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSchoolMap
     */
    omit?: SpellSchoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSchoolMapInclude<ExtArgs> | null
    where?: SpellSchoolMapWhereInput
    orderBy?: SpellSchoolMapOrderByWithRelationInput | SpellSchoolMapOrderByWithRelationInput[]
    cursor?: SpellSchoolMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellSchoolMapScalarFieldEnum | SpellSchoolMapScalarFieldEnum[]
  }

  /**
   * Spell.sources
   */
  export type Spell$sourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
    where?: SpellSourceMapWhereInput
    orderBy?: SpellSourceMapOrderByWithRelationInput | SpellSourceMapOrderByWithRelationInput[]
    cursor?: SpellSourceMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellSourceMapScalarFieldEnum | SpellSourceMapScalarFieldEnum[]
  }

  /**
   * Spell.subschools
   */
  export type Spell$subschoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSubschoolMap
     */
    select?: SpellSubschoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSubschoolMap
     */
    omit?: SpellSubschoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSubschoolMapInclude<ExtArgs> | null
    where?: SpellSubschoolMapWhereInput
    orderBy?: SpellSubschoolMapOrderByWithRelationInput | SpellSubschoolMapOrderByWithRelationInput[]
    cursor?: SpellSubschoolMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellSubschoolMapScalarFieldEnum | SpellSubschoolMapScalarFieldEnum[]
  }

  /**
   * Spell without action
   */
  export type SpellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
  }


  /**
   * Model SpellDescriptorMap
   */

  export type AggregateSpellDescriptorMap = {
    _count: SpellDescriptorMapCountAggregateOutputType | null
    _avg: SpellDescriptorMapAvgAggregateOutputType | null
    _sum: SpellDescriptorMapSumAggregateOutputType | null
    _min: SpellDescriptorMapMinAggregateOutputType | null
    _max: SpellDescriptorMapMaxAggregateOutputType | null
  }

  export type SpellDescriptorMapAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
    descriptorId: number | null
  }

  export type SpellDescriptorMapSumAggregateOutputType = {
    id: number | null
    spellId: number | null
    descriptorId: number | null
  }

  export type SpellDescriptorMapMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    descriptorId: number | null
  }

  export type SpellDescriptorMapMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    descriptorId: number | null
  }

  export type SpellDescriptorMapCountAggregateOutputType = {
    id: number
    spellId: number
    descriptorId: number
    _all: number
  }


  export type SpellDescriptorMapAvgAggregateInputType = {
    id?: true
    spellId?: true
    descriptorId?: true
  }

  export type SpellDescriptorMapSumAggregateInputType = {
    id?: true
    spellId?: true
    descriptorId?: true
  }

  export type SpellDescriptorMapMinAggregateInputType = {
    id?: true
    spellId?: true
    descriptorId?: true
  }

  export type SpellDescriptorMapMaxAggregateInputType = {
    id?: true
    spellId?: true
    descriptorId?: true
  }

  export type SpellDescriptorMapCountAggregateInputType = {
    id?: true
    spellId?: true
    descriptorId?: true
    _all?: true
  }

  export type SpellDescriptorMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellDescriptorMap to aggregate.
     */
    where?: SpellDescriptorMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellDescriptorMaps to fetch.
     */
    orderBy?: SpellDescriptorMapOrderByWithRelationInput | SpellDescriptorMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellDescriptorMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellDescriptorMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellDescriptorMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellDescriptorMaps
    **/
    _count?: true | SpellDescriptorMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellDescriptorMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellDescriptorMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellDescriptorMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellDescriptorMapMaxAggregateInputType
  }

  export type GetSpellDescriptorMapAggregateType<T extends SpellDescriptorMapAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellDescriptorMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellDescriptorMap[P]>
      : GetScalarType<T[P], AggregateSpellDescriptorMap[P]>
  }




  export type SpellDescriptorMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellDescriptorMapWhereInput
    orderBy?: SpellDescriptorMapOrderByWithAggregationInput | SpellDescriptorMapOrderByWithAggregationInput[]
    by: SpellDescriptorMapScalarFieldEnum[] | SpellDescriptorMapScalarFieldEnum
    having?: SpellDescriptorMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellDescriptorMapCountAggregateInputType | true
    _avg?: SpellDescriptorMapAvgAggregateInputType
    _sum?: SpellDescriptorMapSumAggregateInputType
    _min?: SpellDescriptorMapMinAggregateInputType
    _max?: SpellDescriptorMapMaxAggregateInputType
  }

  export type SpellDescriptorMapGroupByOutputType = {
    id: number
    spellId: number
    descriptorId: number
    _count: SpellDescriptorMapCountAggregateOutputType | null
    _avg: SpellDescriptorMapAvgAggregateOutputType | null
    _sum: SpellDescriptorMapSumAggregateOutputType | null
    _min: SpellDescriptorMapMinAggregateOutputType | null
    _max: SpellDescriptorMapMaxAggregateOutputType | null
  }

  type GetSpellDescriptorMapGroupByPayload<T extends SpellDescriptorMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellDescriptorMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellDescriptorMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellDescriptorMapGroupByOutputType[P]>
            : GetScalarType<T[P], SpellDescriptorMapGroupByOutputType[P]>
        }
      >
    >


  export type SpellDescriptorMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    descriptorId?: boolean
    Spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellDescriptorMap"]>



  export type SpellDescriptorMapSelectScalar = {
    id?: boolean
    spellId?: boolean
    descriptorId?: boolean
  }

  export type SpellDescriptorMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "spellId" | "descriptorId", ExtArgs["result"]["spellDescriptorMap"]>
  export type SpellDescriptorMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Spell?: boolean | SpellDefaultArgs<ExtArgs>
  }

  export type $SpellDescriptorMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellDescriptorMap"
    objects: {
      Spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      descriptorId: number
    }, ExtArgs["result"]["spellDescriptorMap"]>
    composites: {}
  }

  type SpellDescriptorMapGetPayload<S extends boolean | null | undefined | SpellDescriptorMapDefaultArgs> = $Result.GetResult<Prisma.$SpellDescriptorMapPayload, S>

  type SpellDescriptorMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellDescriptorMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellDescriptorMapCountAggregateInputType | true
    }

  export interface SpellDescriptorMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellDescriptorMap'], meta: { name: 'SpellDescriptorMap' } }
    /**
     * Find zero or one SpellDescriptorMap that matches the filter.
     * @param {SpellDescriptorMapFindUniqueArgs} args - Arguments to find a SpellDescriptorMap
     * @example
     * // Get one SpellDescriptorMap
     * const spellDescriptorMap = await prisma.spellDescriptorMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellDescriptorMapFindUniqueArgs>(args: SelectSubset<T, SpellDescriptorMapFindUniqueArgs<ExtArgs>>): Prisma__SpellDescriptorMapClient<$Result.GetResult<Prisma.$SpellDescriptorMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpellDescriptorMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellDescriptorMapFindUniqueOrThrowArgs} args - Arguments to find a SpellDescriptorMap
     * @example
     * // Get one SpellDescriptorMap
     * const spellDescriptorMap = await prisma.spellDescriptorMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellDescriptorMapFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellDescriptorMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellDescriptorMapClient<$Result.GetResult<Prisma.$SpellDescriptorMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellDescriptorMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellDescriptorMapFindFirstArgs} args - Arguments to find a SpellDescriptorMap
     * @example
     * // Get one SpellDescriptorMap
     * const spellDescriptorMap = await prisma.spellDescriptorMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellDescriptorMapFindFirstArgs>(args?: SelectSubset<T, SpellDescriptorMapFindFirstArgs<ExtArgs>>): Prisma__SpellDescriptorMapClient<$Result.GetResult<Prisma.$SpellDescriptorMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellDescriptorMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellDescriptorMapFindFirstOrThrowArgs} args - Arguments to find a SpellDescriptorMap
     * @example
     * // Get one SpellDescriptorMap
     * const spellDescriptorMap = await prisma.spellDescriptorMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellDescriptorMapFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellDescriptorMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellDescriptorMapClient<$Result.GetResult<Prisma.$SpellDescriptorMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpellDescriptorMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellDescriptorMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellDescriptorMaps
     * const spellDescriptorMaps = await prisma.spellDescriptorMap.findMany()
     * 
     * // Get first 10 SpellDescriptorMaps
     * const spellDescriptorMaps = await prisma.spellDescriptorMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellDescriptorMapWithIdOnly = await prisma.spellDescriptorMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpellDescriptorMapFindManyArgs>(args?: SelectSubset<T, SpellDescriptorMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellDescriptorMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpellDescriptorMap.
     * @param {SpellDescriptorMapCreateArgs} args - Arguments to create a SpellDescriptorMap.
     * @example
     * // Create one SpellDescriptorMap
     * const SpellDescriptorMap = await prisma.spellDescriptorMap.create({
     *   data: {
     *     // ... data to create a SpellDescriptorMap
     *   }
     * })
     * 
     */
    create<T extends SpellDescriptorMapCreateArgs>(args: SelectSubset<T, SpellDescriptorMapCreateArgs<ExtArgs>>): Prisma__SpellDescriptorMapClient<$Result.GetResult<Prisma.$SpellDescriptorMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpellDescriptorMaps.
     * @param {SpellDescriptorMapCreateManyArgs} args - Arguments to create many SpellDescriptorMaps.
     * @example
     * // Create many SpellDescriptorMaps
     * const spellDescriptorMap = await prisma.spellDescriptorMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellDescriptorMapCreateManyArgs>(args?: SelectSubset<T, SpellDescriptorMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellDescriptorMap.
     * @param {SpellDescriptorMapDeleteArgs} args - Arguments to delete one SpellDescriptorMap.
     * @example
     * // Delete one SpellDescriptorMap
     * const SpellDescriptorMap = await prisma.spellDescriptorMap.delete({
     *   where: {
     *     // ... filter to delete one SpellDescriptorMap
     *   }
     * })
     * 
     */
    delete<T extends SpellDescriptorMapDeleteArgs>(args: SelectSubset<T, SpellDescriptorMapDeleteArgs<ExtArgs>>): Prisma__SpellDescriptorMapClient<$Result.GetResult<Prisma.$SpellDescriptorMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpellDescriptorMap.
     * @param {SpellDescriptorMapUpdateArgs} args - Arguments to update one SpellDescriptorMap.
     * @example
     * // Update one SpellDescriptorMap
     * const spellDescriptorMap = await prisma.spellDescriptorMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellDescriptorMapUpdateArgs>(args: SelectSubset<T, SpellDescriptorMapUpdateArgs<ExtArgs>>): Prisma__SpellDescriptorMapClient<$Result.GetResult<Prisma.$SpellDescriptorMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpellDescriptorMaps.
     * @param {SpellDescriptorMapDeleteManyArgs} args - Arguments to filter SpellDescriptorMaps to delete.
     * @example
     * // Delete a few SpellDescriptorMaps
     * const { count } = await prisma.spellDescriptorMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellDescriptorMapDeleteManyArgs>(args?: SelectSubset<T, SpellDescriptorMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellDescriptorMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellDescriptorMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellDescriptorMaps
     * const spellDescriptorMap = await prisma.spellDescriptorMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellDescriptorMapUpdateManyArgs>(args: SelectSubset<T, SpellDescriptorMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellDescriptorMap.
     * @param {SpellDescriptorMapUpsertArgs} args - Arguments to update or create a SpellDescriptorMap.
     * @example
     * // Update or create a SpellDescriptorMap
     * const spellDescriptorMap = await prisma.spellDescriptorMap.upsert({
     *   create: {
     *     // ... data to create a SpellDescriptorMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellDescriptorMap we want to update
     *   }
     * })
     */
    upsert<T extends SpellDescriptorMapUpsertArgs>(args: SelectSubset<T, SpellDescriptorMapUpsertArgs<ExtArgs>>): Prisma__SpellDescriptorMapClient<$Result.GetResult<Prisma.$SpellDescriptorMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpellDescriptorMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellDescriptorMapCountArgs} args - Arguments to filter SpellDescriptorMaps to count.
     * @example
     * // Count the number of SpellDescriptorMaps
     * const count = await prisma.spellDescriptorMap.count({
     *   where: {
     *     // ... the filter for the SpellDescriptorMaps we want to count
     *   }
     * })
    **/
    count<T extends SpellDescriptorMapCountArgs>(
      args?: Subset<T, SpellDescriptorMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellDescriptorMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellDescriptorMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellDescriptorMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellDescriptorMapAggregateArgs>(args: Subset<T, SpellDescriptorMapAggregateArgs>): Prisma.PrismaPromise<GetSpellDescriptorMapAggregateType<T>>

    /**
     * Group by SpellDescriptorMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellDescriptorMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellDescriptorMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellDescriptorMapGroupByArgs['orderBy'] }
        : { orderBy?: SpellDescriptorMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellDescriptorMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellDescriptorMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellDescriptorMap model
   */
  readonly fields: SpellDescriptorMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellDescriptorMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellDescriptorMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpellDescriptorMap model
   */
  interface SpellDescriptorMapFieldRefs {
    readonly id: FieldRef<"SpellDescriptorMap", 'Int'>
    readonly spellId: FieldRef<"SpellDescriptorMap", 'Int'>
    readonly descriptorId: FieldRef<"SpellDescriptorMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpellDescriptorMap findUnique
   */
  export type SpellDescriptorMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellDescriptorMap
     */
    select?: SpellDescriptorMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellDescriptorMap
     */
    omit?: SpellDescriptorMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellDescriptorMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellDescriptorMap to fetch.
     */
    where: SpellDescriptorMapWhereUniqueInput
  }

  /**
   * SpellDescriptorMap findUniqueOrThrow
   */
  export type SpellDescriptorMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellDescriptorMap
     */
    select?: SpellDescriptorMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellDescriptorMap
     */
    omit?: SpellDescriptorMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellDescriptorMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellDescriptorMap to fetch.
     */
    where: SpellDescriptorMapWhereUniqueInput
  }

  /**
   * SpellDescriptorMap findFirst
   */
  export type SpellDescriptorMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellDescriptorMap
     */
    select?: SpellDescriptorMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellDescriptorMap
     */
    omit?: SpellDescriptorMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellDescriptorMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellDescriptorMap to fetch.
     */
    where?: SpellDescriptorMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellDescriptorMaps to fetch.
     */
    orderBy?: SpellDescriptorMapOrderByWithRelationInput | SpellDescriptorMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellDescriptorMaps.
     */
    cursor?: SpellDescriptorMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellDescriptorMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellDescriptorMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellDescriptorMaps.
     */
    distinct?: SpellDescriptorMapScalarFieldEnum | SpellDescriptorMapScalarFieldEnum[]
  }

  /**
   * SpellDescriptorMap findFirstOrThrow
   */
  export type SpellDescriptorMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellDescriptorMap
     */
    select?: SpellDescriptorMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellDescriptorMap
     */
    omit?: SpellDescriptorMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellDescriptorMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellDescriptorMap to fetch.
     */
    where?: SpellDescriptorMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellDescriptorMaps to fetch.
     */
    orderBy?: SpellDescriptorMapOrderByWithRelationInput | SpellDescriptorMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellDescriptorMaps.
     */
    cursor?: SpellDescriptorMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellDescriptorMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellDescriptorMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellDescriptorMaps.
     */
    distinct?: SpellDescriptorMapScalarFieldEnum | SpellDescriptorMapScalarFieldEnum[]
  }

  /**
   * SpellDescriptorMap findMany
   */
  export type SpellDescriptorMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellDescriptorMap
     */
    select?: SpellDescriptorMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellDescriptorMap
     */
    omit?: SpellDescriptorMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellDescriptorMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellDescriptorMaps to fetch.
     */
    where?: SpellDescriptorMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellDescriptorMaps to fetch.
     */
    orderBy?: SpellDescriptorMapOrderByWithRelationInput | SpellDescriptorMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellDescriptorMaps.
     */
    cursor?: SpellDescriptorMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellDescriptorMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellDescriptorMaps.
     */
    skip?: number
    distinct?: SpellDescriptorMapScalarFieldEnum | SpellDescriptorMapScalarFieldEnum[]
  }

  /**
   * SpellDescriptorMap create
   */
  export type SpellDescriptorMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellDescriptorMap
     */
    select?: SpellDescriptorMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellDescriptorMap
     */
    omit?: SpellDescriptorMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellDescriptorMapInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellDescriptorMap.
     */
    data: XOR<SpellDescriptorMapCreateInput, SpellDescriptorMapUncheckedCreateInput>
  }

  /**
   * SpellDescriptorMap createMany
   */
  export type SpellDescriptorMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellDescriptorMaps.
     */
    data: SpellDescriptorMapCreateManyInput | SpellDescriptorMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpellDescriptorMap update
   */
  export type SpellDescriptorMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellDescriptorMap
     */
    select?: SpellDescriptorMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellDescriptorMap
     */
    omit?: SpellDescriptorMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellDescriptorMapInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellDescriptorMap.
     */
    data: XOR<SpellDescriptorMapUpdateInput, SpellDescriptorMapUncheckedUpdateInput>
    /**
     * Choose, which SpellDescriptorMap to update.
     */
    where: SpellDescriptorMapWhereUniqueInput
  }

  /**
   * SpellDescriptorMap updateMany
   */
  export type SpellDescriptorMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellDescriptorMaps.
     */
    data: XOR<SpellDescriptorMapUpdateManyMutationInput, SpellDescriptorMapUncheckedUpdateManyInput>
    /**
     * Filter which SpellDescriptorMaps to update
     */
    where?: SpellDescriptorMapWhereInput
    /**
     * Limit how many SpellDescriptorMaps to update.
     */
    limit?: number
  }

  /**
   * SpellDescriptorMap upsert
   */
  export type SpellDescriptorMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellDescriptorMap
     */
    select?: SpellDescriptorMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellDescriptorMap
     */
    omit?: SpellDescriptorMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellDescriptorMapInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellDescriptorMap to update in case it exists.
     */
    where: SpellDescriptorMapWhereUniqueInput
    /**
     * In case the SpellDescriptorMap found by the `where` argument doesn't exist, create a new SpellDescriptorMap with this data.
     */
    create: XOR<SpellDescriptorMapCreateInput, SpellDescriptorMapUncheckedCreateInput>
    /**
     * In case the SpellDescriptorMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellDescriptorMapUpdateInput, SpellDescriptorMapUncheckedUpdateInput>
  }

  /**
   * SpellDescriptorMap delete
   */
  export type SpellDescriptorMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellDescriptorMap
     */
    select?: SpellDescriptorMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellDescriptorMap
     */
    omit?: SpellDescriptorMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellDescriptorMapInclude<ExtArgs> | null
    /**
     * Filter which SpellDescriptorMap to delete.
     */
    where: SpellDescriptorMapWhereUniqueInput
  }

  /**
   * SpellDescriptorMap deleteMany
   */
  export type SpellDescriptorMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellDescriptorMaps to delete
     */
    where?: SpellDescriptorMapWhereInput
    /**
     * Limit how many SpellDescriptorMaps to delete.
     */
    limit?: number
  }

  /**
   * SpellDescriptorMap without action
   */
  export type SpellDescriptorMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellDescriptorMap
     */
    select?: SpellDescriptorMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellDescriptorMap
     */
    omit?: SpellDescriptorMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellDescriptorMapInclude<ExtArgs> | null
  }


  /**
   * Model SpellSchoolMap
   */

  export type AggregateSpellSchoolMap = {
    _count: SpellSchoolMapCountAggregateOutputType | null
    _avg: SpellSchoolMapAvgAggregateOutputType | null
    _sum: SpellSchoolMapSumAggregateOutputType | null
    _min: SpellSchoolMapMinAggregateOutputType | null
    _max: SpellSchoolMapMaxAggregateOutputType | null
  }

  export type SpellSchoolMapAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
    schoolId: number | null
  }

  export type SpellSchoolMapSumAggregateOutputType = {
    id: number | null
    spellId: number | null
    schoolId: number | null
  }

  export type SpellSchoolMapMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    schoolId: number | null
  }

  export type SpellSchoolMapMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    schoolId: number | null
  }

  export type SpellSchoolMapCountAggregateOutputType = {
    id: number
    spellId: number
    schoolId: number
    _all: number
  }


  export type SpellSchoolMapAvgAggregateInputType = {
    id?: true
    spellId?: true
    schoolId?: true
  }

  export type SpellSchoolMapSumAggregateInputType = {
    id?: true
    spellId?: true
    schoolId?: true
  }

  export type SpellSchoolMapMinAggregateInputType = {
    id?: true
    spellId?: true
    schoolId?: true
  }

  export type SpellSchoolMapMaxAggregateInputType = {
    id?: true
    spellId?: true
    schoolId?: true
  }

  export type SpellSchoolMapCountAggregateInputType = {
    id?: true
    spellId?: true
    schoolId?: true
    _all?: true
  }

  export type SpellSchoolMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellSchoolMap to aggregate.
     */
    where?: SpellSchoolMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSchoolMaps to fetch.
     */
    orderBy?: SpellSchoolMapOrderByWithRelationInput | SpellSchoolMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellSchoolMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSchoolMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSchoolMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellSchoolMaps
    **/
    _count?: true | SpellSchoolMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellSchoolMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellSchoolMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellSchoolMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellSchoolMapMaxAggregateInputType
  }

  export type GetSpellSchoolMapAggregateType<T extends SpellSchoolMapAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellSchoolMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellSchoolMap[P]>
      : GetScalarType<T[P], AggregateSpellSchoolMap[P]>
  }




  export type SpellSchoolMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellSchoolMapWhereInput
    orderBy?: SpellSchoolMapOrderByWithAggregationInput | SpellSchoolMapOrderByWithAggregationInput[]
    by: SpellSchoolMapScalarFieldEnum[] | SpellSchoolMapScalarFieldEnum
    having?: SpellSchoolMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellSchoolMapCountAggregateInputType | true
    _avg?: SpellSchoolMapAvgAggregateInputType
    _sum?: SpellSchoolMapSumAggregateInputType
    _min?: SpellSchoolMapMinAggregateInputType
    _max?: SpellSchoolMapMaxAggregateInputType
  }

  export type SpellSchoolMapGroupByOutputType = {
    id: number
    spellId: number
    schoolId: number
    _count: SpellSchoolMapCountAggregateOutputType | null
    _avg: SpellSchoolMapAvgAggregateOutputType | null
    _sum: SpellSchoolMapSumAggregateOutputType | null
    _min: SpellSchoolMapMinAggregateOutputType | null
    _max: SpellSchoolMapMaxAggregateOutputType | null
  }

  type GetSpellSchoolMapGroupByPayload<T extends SpellSchoolMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellSchoolMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellSchoolMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellSchoolMapGroupByOutputType[P]>
            : GetScalarType<T[P], SpellSchoolMapGroupByOutputType[P]>
        }
      >
    >


  export type SpellSchoolMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    schoolId?: boolean
    Spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellSchoolMap"]>



  export type SpellSchoolMapSelectScalar = {
    id?: boolean
    spellId?: boolean
    schoolId?: boolean
  }

  export type SpellSchoolMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "spellId" | "schoolId", ExtArgs["result"]["spellSchoolMap"]>
  export type SpellSchoolMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Spell?: boolean | SpellDefaultArgs<ExtArgs>
  }

  export type $SpellSchoolMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellSchoolMap"
    objects: {
      Spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      schoolId: number
    }, ExtArgs["result"]["spellSchoolMap"]>
    composites: {}
  }

  type SpellSchoolMapGetPayload<S extends boolean | null | undefined | SpellSchoolMapDefaultArgs> = $Result.GetResult<Prisma.$SpellSchoolMapPayload, S>

  type SpellSchoolMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellSchoolMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellSchoolMapCountAggregateInputType | true
    }

  export interface SpellSchoolMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellSchoolMap'], meta: { name: 'SpellSchoolMap' } }
    /**
     * Find zero or one SpellSchoolMap that matches the filter.
     * @param {SpellSchoolMapFindUniqueArgs} args - Arguments to find a SpellSchoolMap
     * @example
     * // Get one SpellSchoolMap
     * const spellSchoolMap = await prisma.spellSchoolMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellSchoolMapFindUniqueArgs>(args: SelectSubset<T, SpellSchoolMapFindUniqueArgs<ExtArgs>>): Prisma__SpellSchoolMapClient<$Result.GetResult<Prisma.$SpellSchoolMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpellSchoolMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellSchoolMapFindUniqueOrThrowArgs} args - Arguments to find a SpellSchoolMap
     * @example
     * // Get one SpellSchoolMap
     * const spellSchoolMap = await prisma.spellSchoolMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellSchoolMapFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellSchoolMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellSchoolMapClient<$Result.GetResult<Prisma.$SpellSchoolMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellSchoolMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolMapFindFirstArgs} args - Arguments to find a SpellSchoolMap
     * @example
     * // Get one SpellSchoolMap
     * const spellSchoolMap = await prisma.spellSchoolMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellSchoolMapFindFirstArgs>(args?: SelectSubset<T, SpellSchoolMapFindFirstArgs<ExtArgs>>): Prisma__SpellSchoolMapClient<$Result.GetResult<Prisma.$SpellSchoolMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellSchoolMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolMapFindFirstOrThrowArgs} args - Arguments to find a SpellSchoolMap
     * @example
     * // Get one SpellSchoolMap
     * const spellSchoolMap = await prisma.spellSchoolMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellSchoolMapFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellSchoolMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellSchoolMapClient<$Result.GetResult<Prisma.$SpellSchoolMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpellSchoolMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellSchoolMaps
     * const spellSchoolMaps = await prisma.spellSchoolMap.findMany()
     * 
     * // Get first 10 SpellSchoolMaps
     * const spellSchoolMaps = await prisma.spellSchoolMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellSchoolMapWithIdOnly = await prisma.spellSchoolMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpellSchoolMapFindManyArgs>(args?: SelectSubset<T, SpellSchoolMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellSchoolMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpellSchoolMap.
     * @param {SpellSchoolMapCreateArgs} args - Arguments to create a SpellSchoolMap.
     * @example
     * // Create one SpellSchoolMap
     * const SpellSchoolMap = await prisma.spellSchoolMap.create({
     *   data: {
     *     // ... data to create a SpellSchoolMap
     *   }
     * })
     * 
     */
    create<T extends SpellSchoolMapCreateArgs>(args: SelectSubset<T, SpellSchoolMapCreateArgs<ExtArgs>>): Prisma__SpellSchoolMapClient<$Result.GetResult<Prisma.$SpellSchoolMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpellSchoolMaps.
     * @param {SpellSchoolMapCreateManyArgs} args - Arguments to create many SpellSchoolMaps.
     * @example
     * // Create many SpellSchoolMaps
     * const spellSchoolMap = await prisma.spellSchoolMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellSchoolMapCreateManyArgs>(args?: SelectSubset<T, SpellSchoolMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellSchoolMap.
     * @param {SpellSchoolMapDeleteArgs} args - Arguments to delete one SpellSchoolMap.
     * @example
     * // Delete one SpellSchoolMap
     * const SpellSchoolMap = await prisma.spellSchoolMap.delete({
     *   where: {
     *     // ... filter to delete one SpellSchoolMap
     *   }
     * })
     * 
     */
    delete<T extends SpellSchoolMapDeleteArgs>(args: SelectSubset<T, SpellSchoolMapDeleteArgs<ExtArgs>>): Prisma__SpellSchoolMapClient<$Result.GetResult<Prisma.$SpellSchoolMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpellSchoolMap.
     * @param {SpellSchoolMapUpdateArgs} args - Arguments to update one SpellSchoolMap.
     * @example
     * // Update one SpellSchoolMap
     * const spellSchoolMap = await prisma.spellSchoolMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellSchoolMapUpdateArgs>(args: SelectSubset<T, SpellSchoolMapUpdateArgs<ExtArgs>>): Prisma__SpellSchoolMapClient<$Result.GetResult<Prisma.$SpellSchoolMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpellSchoolMaps.
     * @param {SpellSchoolMapDeleteManyArgs} args - Arguments to filter SpellSchoolMaps to delete.
     * @example
     * // Delete a few SpellSchoolMaps
     * const { count } = await prisma.spellSchoolMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellSchoolMapDeleteManyArgs>(args?: SelectSubset<T, SpellSchoolMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellSchoolMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellSchoolMaps
     * const spellSchoolMap = await prisma.spellSchoolMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellSchoolMapUpdateManyArgs>(args: SelectSubset<T, SpellSchoolMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellSchoolMap.
     * @param {SpellSchoolMapUpsertArgs} args - Arguments to update or create a SpellSchoolMap.
     * @example
     * // Update or create a SpellSchoolMap
     * const spellSchoolMap = await prisma.spellSchoolMap.upsert({
     *   create: {
     *     // ... data to create a SpellSchoolMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellSchoolMap we want to update
     *   }
     * })
     */
    upsert<T extends SpellSchoolMapUpsertArgs>(args: SelectSubset<T, SpellSchoolMapUpsertArgs<ExtArgs>>): Prisma__SpellSchoolMapClient<$Result.GetResult<Prisma.$SpellSchoolMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpellSchoolMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolMapCountArgs} args - Arguments to filter SpellSchoolMaps to count.
     * @example
     * // Count the number of SpellSchoolMaps
     * const count = await prisma.spellSchoolMap.count({
     *   where: {
     *     // ... the filter for the SpellSchoolMaps we want to count
     *   }
     * })
    **/
    count<T extends SpellSchoolMapCountArgs>(
      args?: Subset<T, SpellSchoolMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellSchoolMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellSchoolMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellSchoolMapAggregateArgs>(args: Subset<T, SpellSchoolMapAggregateArgs>): Prisma.PrismaPromise<GetSpellSchoolMapAggregateType<T>>

    /**
     * Group by SpellSchoolMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellSchoolMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellSchoolMapGroupByArgs['orderBy'] }
        : { orderBy?: SpellSchoolMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellSchoolMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellSchoolMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellSchoolMap model
   */
  readonly fields: SpellSchoolMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellSchoolMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellSchoolMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpellSchoolMap model
   */
  interface SpellSchoolMapFieldRefs {
    readonly id: FieldRef<"SpellSchoolMap", 'Int'>
    readonly spellId: FieldRef<"SpellSchoolMap", 'Int'>
    readonly schoolId: FieldRef<"SpellSchoolMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpellSchoolMap findUnique
   */
  export type SpellSchoolMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolMap
     */
    select?: SpellSchoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSchoolMap
     */
    omit?: SpellSchoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSchoolMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSchoolMap to fetch.
     */
    where: SpellSchoolMapWhereUniqueInput
  }

  /**
   * SpellSchoolMap findUniqueOrThrow
   */
  export type SpellSchoolMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolMap
     */
    select?: SpellSchoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSchoolMap
     */
    omit?: SpellSchoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSchoolMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSchoolMap to fetch.
     */
    where: SpellSchoolMapWhereUniqueInput
  }

  /**
   * SpellSchoolMap findFirst
   */
  export type SpellSchoolMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolMap
     */
    select?: SpellSchoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSchoolMap
     */
    omit?: SpellSchoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSchoolMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSchoolMap to fetch.
     */
    where?: SpellSchoolMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSchoolMaps to fetch.
     */
    orderBy?: SpellSchoolMapOrderByWithRelationInput | SpellSchoolMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellSchoolMaps.
     */
    cursor?: SpellSchoolMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSchoolMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSchoolMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellSchoolMaps.
     */
    distinct?: SpellSchoolMapScalarFieldEnum | SpellSchoolMapScalarFieldEnum[]
  }

  /**
   * SpellSchoolMap findFirstOrThrow
   */
  export type SpellSchoolMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolMap
     */
    select?: SpellSchoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSchoolMap
     */
    omit?: SpellSchoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSchoolMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSchoolMap to fetch.
     */
    where?: SpellSchoolMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSchoolMaps to fetch.
     */
    orderBy?: SpellSchoolMapOrderByWithRelationInput | SpellSchoolMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellSchoolMaps.
     */
    cursor?: SpellSchoolMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSchoolMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSchoolMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellSchoolMaps.
     */
    distinct?: SpellSchoolMapScalarFieldEnum | SpellSchoolMapScalarFieldEnum[]
  }

  /**
   * SpellSchoolMap findMany
   */
  export type SpellSchoolMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolMap
     */
    select?: SpellSchoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSchoolMap
     */
    omit?: SpellSchoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSchoolMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSchoolMaps to fetch.
     */
    where?: SpellSchoolMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSchoolMaps to fetch.
     */
    orderBy?: SpellSchoolMapOrderByWithRelationInput | SpellSchoolMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellSchoolMaps.
     */
    cursor?: SpellSchoolMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSchoolMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSchoolMaps.
     */
    skip?: number
    distinct?: SpellSchoolMapScalarFieldEnum | SpellSchoolMapScalarFieldEnum[]
  }

  /**
   * SpellSchoolMap create
   */
  export type SpellSchoolMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolMap
     */
    select?: SpellSchoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSchoolMap
     */
    omit?: SpellSchoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSchoolMapInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellSchoolMap.
     */
    data: XOR<SpellSchoolMapCreateInput, SpellSchoolMapUncheckedCreateInput>
  }

  /**
   * SpellSchoolMap createMany
   */
  export type SpellSchoolMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellSchoolMaps.
     */
    data: SpellSchoolMapCreateManyInput | SpellSchoolMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpellSchoolMap update
   */
  export type SpellSchoolMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolMap
     */
    select?: SpellSchoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSchoolMap
     */
    omit?: SpellSchoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSchoolMapInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellSchoolMap.
     */
    data: XOR<SpellSchoolMapUpdateInput, SpellSchoolMapUncheckedUpdateInput>
    /**
     * Choose, which SpellSchoolMap to update.
     */
    where: SpellSchoolMapWhereUniqueInput
  }

  /**
   * SpellSchoolMap updateMany
   */
  export type SpellSchoolMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellSchoolMaps.
     */
    data: XOR<SpellSchoolMapUpdateManyMutationInput, SpellSchoolMapUncheckedUpdateManyInput>
    /**
     * Filter which SpellSchoolMaps to update
     */
    where?: SpellSchoolMapWhereInput
    /**
     * Limit how many SpellSchoolMaps to update.
     */
    limit?: number
  }

  /**
   * SpellSchoolMap upsert
   */
  export type SpellSchoolMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolMap
     */
    select?: SpellSchoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSchoolMap
     */
    omit?: SpellSchoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSchoolMapInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellSchoolMap to update in case it exists.
     */
    where: SpellSchoolMapWhereUniqueInput
    /**
     * In case the SpellSchoolMap found by the `where` argument doesn't exist, create a new SpellSchoolMap with this data.
     */
    create: XOR<SpellSchoolMapCreateInput, SpellSchoolMapUncheckedCreateInput>
    /**
     * In case the SpellSchoolMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellSchoolMapUpdateInput, SpellSchoolMapUncheckedUpdateInput>
  }

  /**
   * SpellSchoolMap delete
   */
  export type SpellSchoolMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolMap
     */
    select?: SpellSchoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSchoolMap
     */
    omit?: SpellSchoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSchoolMapInclude<ExtArgs> | null
    /**
     * Filter which SpellSchoolMap to delete.
     */
    where: SpellSchoolMapWhereUniqueInput
  }

  /**
   * SpellSchoolMap deleteMany
   */
  export type SpellSchoolMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellSchoolMaps to delete
     */
    where?: SpellSchoolMapWhereInput
    /**
     * Limit how many SpellSchoolMaps to delete.
     */
    limit?: number
  }

  /**
   * SpellSchoolMap without action
   */
  export type SpellSchoolMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolMap
     */
    select?: SpellSchoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSchoolMap
     */
    omit?: SpellSchoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSchoolMapInclude<ExtArgs> | null
  }


  /**
   * Model SpellSourceMap
   */

  export type AggregateSpellSourceMap = {
    _count: SpellSourceMapCountAggregateOutputType | null
    _avg: SpellSourceMapAvgAggregateOutputType | null
    _sum: SpellSourceMapSumAggregateOutputType | null
    _min: SpellSourceMapMinAggregateOutputType | null
    _max: SpellSourceMapMaxAggregateOutputType | null
  }

  export type SpellSourceMapAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type SpellSourceMapSumAggregateOutputType = {
    id: number | null
    spellId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type SpellSourceMapMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type SpellSourceMapMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type SpellSourceMapCountAggregateOutputType = {
    id: number
    spellId: number
    bookId: number
    pageNumber: number
    sourceBookId: number
    _all: number
  }


  export type SpellSourceMapAvgAggregateInputType = {
    id?: true
    spellId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type SpellSourceMapSumAggregateInputType = {
    id?: true
    spellId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type SpellSourceMapMinAggregateInputType = {
    id?: true
    spellId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type SpellSourceMapMaxAggregateInputType = {
    id?: true
    spellId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type SpellSourceMapCountAggregateInputType = {
    id?: true
    spellId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
    _all?: true
  }

  export type SpellSourceMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellSourceMap to aggregate.
     */
    where?: SpellSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSourceMaps to fetch.
     */
    orderBy?: SpellSourceMapOrderByWithRelationInput | SpellSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSourceMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellSourceMaps
    **/
    _count?: true | SpellSourceMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellSourceMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellSourceMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellSourceMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellSourceMapMaxAggregateInputType
  }

  export type GetSpellSourceMapAggregateType<T extends SpellSourceMapAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellSourceMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellSourceMap[P]>
      : GetScalarType<T[P], AggregateSpellSourceMap[P]>
  }




  export type SpellSourceMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellSourceMapWhereInput
    orderBy?: SpellSourceMapOrderByWithAggregationInput | SpellSourceMapOrderByWithAggregationInput[]
    by: SpellSourceMapScalarFieldEnum[] | SpellSourceMapScalarFieldEnum
    having?: SpellSourceMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellSourceMapCountAggregateInputType | true
    _avg?: SpellSourceMapAvgAggregateInputType
    _sum?: SpellSourceMapSumAggregateInputType
    _min?: SpellSourceMapMinAggregateInputType
    _max?: SpellSourceMapMaxAggregateInputType
  }

  export type SpellSourceMapGroupByOutputType = {
    id: number
    spellId: number
    bookId: number
    pageNumber: number | null
    sourceBookId: number | null
    _count: SpellSourceMapCountAggregateOutputType | null
    _avg: SpellSourceMapAvgAggregateOutputType | null
    _sum: SpellSourceMapSumAggregateOutputType | null
    _min: SpellSourceMapMinAggregateOutputType | null
    _max: SpellSourceMapMaxAggregateOutputType | null
  }

  type GetSpellSourceMapGroupByPayload<T extends SpellSourceMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellSourceMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellSourceMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellSourceMapGroupByOutputType[P]>
            : GetScalarType<T[P], SpellSourceMapGroupByOutputType[P]>
        }
      >
    >


  export type SpellSourceMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    bookId?: boolean
    pageNumber?: boolean
    sourceBookId?: boolean
    Spell?: boolean | SpellDefaultArgs<ExtArgs>
    SourceBook?: boolean | SpellSourceMap$SourceBookArgs<ExtArgs>
  }, ExtArgs["result"]["spellSourceMap"]>



  export type SpellSourceMapSelectScalar = {
    id?: boolean
    spellId?: boolean
    bookId?: boolean
    pageNumber?: boolean
    sourceBookId?: boolean
  }

  export type SpellSourceMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "spellId" | "bookId" | "pageNumber" | "sourceBookId", ExtArgs["result"]["spellSourceMap"]>
  export type SpellSourceMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Spell?: boolean | SpellDefaultArgs<ExtArgs>
    SourceBook?: boolean | SpellSourceMap$SourceBookArgs<ExtArgs>
  }

  export type $SpellSourceMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellSourceMap"
    objects: {
      Spell: Prisma.$SpellPayload<ExtArgs>
      SourceBook: Prisma.$SourceBookPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      bookId: number
      pageNumber: number | null
      sourceBookId: number | null
    }, ExtArgs["result"]["spellSourceMap"]>
    composites: {}
  }

  type SpellSourceMapGetPayload<S extends boolean | null | undefined | SpellSourceMapDefaultArgs> = $Result.GetResult<Prisma.$SpellSourceMapPayload, S>

  type SpellSourceMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellSourceMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellSourceMapCountAggregateInputType | true
    }

  export interface SpellSourceMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellSourceMap'], meta: { name: 'SpellSourceMap' } }
    /**
     * Find zero or one SpellSourceMap that matches the filter.
     * @param {SpellSourceMapFindUniqueArgs} args - Arguments to find a SpellSourceMap
     * @example
     * // Get one SpellSourceMap
     * const spellSourceMap = await prisma.spellSourceMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellSourceMapFindUniqueArgs>(args: SelectSubset<T, SpellSourceMapFindUniqueArgs<ExtArgs>>): Prisma__SpellSourceMapClient<$Result.GetResult<Prisma.$SpellSourceMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpellSourceMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellSourceMapFindUniqueOrThrowArgs} args - Arguments to find a SpellSourceMap
     * @example
     * // Get one SpellSourceMap
     * const spellSourceMap = await prisma.spellSourceMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellSourceMapFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellSourceMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellSourceMapClient<$Result.GetResult<Prisma.$SpellSourceMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellSourceMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSourceMapFindFirstArgs} args - Arguments to find a SpellSourceMap
     * @example
     * // Get one SpellSourceMap
     * const spellSourceMap = await prisma.spellSourceMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellSourceMapFindFirstArgs>(args?: SelectSubset<T, SpellSourceMapFindFirstArgs<ExtArgs>>): Prisma__SpellSourceMapClient<$Result.GetResult<Prisma.$SpellSourceMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellSourceMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSourceMapFindFirstOrThrowArgs} args - Arguments to find a SpellSourceMap
     * @example
     * // Get one SpellSourceMap
     * const spellSourceMap = await prisma.spellSourceMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellSourceMapFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellSourceMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellSourceMapClient<$Result.GetResult<Prisma.$SpellSourceMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpellSourceMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSourceMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellSourceMaps
     * const spellSourceMaps = await prisma.spellSourceMap.findMany()
     * 
     * // Get first 10 SpellSourceMaps
     * const spellSourceMaps = await prisma.spellSourceMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellSourceMapWithIdOnly = await prisma.spellSourceMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpellSourceMapFindManyArgs>(args?: SelectSubset<T, SpellSourceMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellSourceMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpellSourceMap.
     * @param {SpellSourceMapCreateArgs} args - Arguments to create a SpellSourceMap.
     * @example
     * // Create one SpellSourceMap
     * const SpellSourceMap = await prisma.spellSourceMap.create({
     *   data: {
     *     // ... data to create a SpellSourceMap
     *   }
     * })
     * 
     */
    create<T extends SpellSourceMapCreateArgs>(args: SelectSubset<T, SpellSourceMapCreateArgs<ExtArgs>>): Prisma__SpellSourceMapClient<$Result.GetResult<Prisma.$SpellSourceMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpellSourceMaps.
     * @param {SpellSourceMapCreateManyArgs} args - Arguments to create many SpellSourceMaps.
     * @example
     * // Create many SpellSourceMaps
     * const spellSourceMap = await prisma.spellSourceMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellSourceMapCreateManyArgs>(args?: SelectSubset<T, SpellSourceMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellSourceMap.
     * @param {SpellSourceMapDeleteArgs} args - Arguments to delete one SpellSourceMap.
     * @example
     * // Delete one SpellSourceMap
     * const SpellSourceMap = await prisma.spellSourceMap.delete({
     *   where: {
     *     // ... filter to delete one SpellSourceMap
     *   }
     * })
     * 
     */
    delete<T extends SpellSourceMapDeleteArgs>(args: SelectSubset<T, SpellSourceMapDeleteArgs<ExtArgs>>): Prisma__SpellSourceMapClient<$Result.GetResult<Prisma.$SpellSourceMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpellSourceMap.
     * @param {SpellSourceMapUpdateArgs} args - Arguments to update one SpellSourceMap.
     * @example
     * // Update one SpellSourceMap
     * const spellSourceMap = await prisma.spellSourceMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellSourceMapUpdateArgs>(args: SelectSubset<T, SpellSourceMapUpdateArgs<ExtArgs>>): Prisma__SpellSourceMapClient<$Result.GetResult<Prisma.$SpellSourceMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpellSourceMaps.
     * @param {SpellSourceMapDeleteManyArgs} args - Arguments to filter SpellSourceMaps to delete.
     * @example
     * // Delete a few SpellSourceMaps
     * const { count } = await prisma.spellSourceMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellSourceMapDeleteManyArgs>(args?: SelectSubset<T, SpellSourceMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellSourceMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSourceMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellSourceMaps
     * const spellSourceMap = await prisma.spellSourceMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellSourceMapUpdateManyArgs>(args: SelectSubset<T, SpellSourceMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellSourceMap.
     * @param {SpellSourceMapUpsertArgs} args - Arguments to update or create a SpellSourceMap.
     * @example
     * // Update or create a SpellSourceMap
     * const spellSourceMap = await prisma.spellSourceMap.upsert({
     *   create: {
     *     // ... data to create a SpellSourceMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellSourceMap we want to update
     *   }
     * })
     */
    upsert<T extends SpellSourceMapUpsertArgs>(args: SelectSubset<T, SpellSourceMapUpsertArgs<ExtArgs>>): Prisma__SpellSourceMapClient<$Result.GetResult<Prisma.$SpellSourceMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpellSourceMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSourceMapCountArgs} args - Arguments to filter SpellSourceMaps to count.
     * @example
     * // Count the number of SpellSourceMaps
     * const count = await prisma.spellSourceMap.count({
     *   where: {
     *     // ... the filter for the SpellSourceMaps we want to count
     *   }
     * })
    **/
    count<T extends SpellSourceMapCountArgs>(
      args?: Subset<T, SpellSourceMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellSourceMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellSourceMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSourceMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellSourceMapAggregateArgs>(args: Subset<T, SpellSourceMapAggregateArgs>): Prisma.PrismaPromise<GetSpellSourceMapAggregateType<T>>

    /**
     * Group by SpellSourceMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSourceMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellSourceMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellSourceMapGroupByArgs['orderBy'] }
        : { orderBy?: SpellSourceMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellSourceMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellSourceMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellSourceMap model
   */
  readonly fields: SpellSourceMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellSourceMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellSourceMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SourceBook<T extends SpellSourceMap$SourceBookArgs<ExtArgs> = {}>(args?: Subset<T, SpellSourceMap$SourceBookArgs<ExtArgs>>): Prisma__SourceBookClient<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpellSourceMap model
   */
  interface SpellSourceMapFieldRefs {
    readonly id: FieldRef<"SpellSourceMap", 'Int'>
    readonly spellId: FieldRef<"SpellSourceMap", 'Int'>
    readonly bookId: FieldRef<"SpellSourceMap", 'Int'>
    readonly pageNumber: FieldRef<"SpellSourceMap", 'Int'>
    readonly sourceBookId: FieldRef<"SpellSourceMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpellSourceMap findUnique
   */
  export type SpellSourceMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSourceMap to fetch.
     */
    where: SpellSourceMapWhereUniqueInput
  }

  /**
   * SpellSourceMap findUniqueOrThrow
   */
  export type SpellSourceMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSourceMap to fetch.
     */
    where: SpellSourceMapWhereUniqueInput
  }

  /**
   * SpellSourceMap findFirst
   */
  export type SpellSourceMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSourceMap to fetch.
     */
    where?: SpellSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSourceMaps to fetch.
     */
    orderBy?: SpellSourceMapOrderByWithRelationInput | SpellSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellSourceMaps.
     */
    cursor?: SpellSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSourceMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellSourceMaps.
     */
    distinct?: SpellSourceMapScalarFieldEnum | SpellSourceMapScalarFieldEnum[]
  }

  /**
   * SpellSourceMap findFirstOrThrow
   */
  export type SpellSourceMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSourceMap to fetch.
     */
    where?: SpellSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSourceMaps to fetch.
     */
    orderBy?: SpellSourceMapOrderByWithRelationInput | SpellSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellSourceMaps.
     */
    cursor?: SpellSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSourceMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellSourceMaps.
     */
    distinct?: SpellSourceMapScalarFieldEnum | SpellSourceMapScalarFieldEnum[]
  }

  /**
   * SpellSourceMap findMany
   */
  export type SpellSourceMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSourceMaps to fetch.
     */
    where?: SpellSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSourceMaps to fetch.
     */
    orderBy?: SpellSourceMapOrderByWithRelationInput | SpellSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellSourceMaps.
     */
    cursor?: SpellSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSourceMaps.
     */
    skip?: number
    distinct?: SpellSourceMapScalarFieldEnum | SpellSourceMapScalarFieldEnum[]
  }

  /**
   * SpellSourceMap create
   */
  export type SpellSourceMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellSourceMap.
     */
    data: XOR<SpellSourceMapCreateInput, SpellSourceMapUncheckedCreateInput>
  }

  /**
   * SpellSourceMap createMany
   */
  export type SpellSourceMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellSourceMaps.
     */
    data: SpellSourceMapCreateManyInput | SpellSourceMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpellSourceMap update
   */
  export type SpellSourceMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellSourceMap.
     */
    data: XOR<SpellSourceMapUpdateInput, SpellSourceMapUncheckedUpdateInput>
    /**
     * Choose, which SpellSourceMap to update.
     */
    where: SpellSourceMapWhereUniqueInput
  }

  /**
   * SpellSourceMap updateMany
   */
  export type SpellSourceMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellSourceMaps.
     */
    data: XOR<SpellSourceMapUpdateManyMutationInput, SpellSourceMapUncheckedUpdateManyInput>
    /**
     * Filter which SpellSourceMaps to update
     */
    where?: SpellSourceMapWhereInput
    /**
     * Limit how many SpellSourceMaps to update.
     */
    limit?: number
  }

  /**
   * SpellSourceMap upsert
   */
  export type SpellSourceMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellSourceMap to update in case it exists.
     */
    where: SpellSourceMapWhereUniqueInput
    /**
     * In case the SpellSourceMap found by the `where` argument doesn't exist, create a new SpellSourceMap with this data.
     */
    create: XOR<SpellSourceMapCreateInput, SpellSourceMapUncheckedCreateInput>
    /**
     * In case the SpellSourceMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellSourceMapUpdateInput, SpellSourceMapUncheckedUpdateInput>
  }

  /**
   * SpellSourceMap delete
   */
  export type SpellSourceMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
    /**
     * Filter which SpellSourceMap to delete.
     */
    where: SpellSourceMapWhereUniqueInput
  }

  /**
   * SpellSourceMap deleteMany
   */
  export type SpellSourceMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellSourceMaps to delete
     */
    where?: SpellSourceMapWhereInput
    /**
     * Limit how many SpellSourceMaps to delete.
     */
    limit?: number
  }

  /**
   * SpellSourceMap.SourceBook
   */
  export type SpellSourceMap$SourceBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    where?: SourceBookWhereInput
  }

  /**
   * SpellSourceMap without action
   */
  export type SpellSourceMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
  }


  /**
   * Model SpellSubschoolMap
   */

  export type AggregateSpellSubschoolMap = {
    _count: SpellSubschoolMapCountAggregateOutputType | null
    _avg: SpellSubschoolMapAvgAggregateOutputType | null
    _sum: SpellSubschoolMapSumAggregateOutputType | null
    _min: SpellSubschoolMapMinAggregateOutputType | null
    _max: SpellSubschoolMapMaxAggregateOutputType | null
  }

  export type SpellSubschoolMapAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
    schoolId: number | null
  }

  export type SpellSubschoolMapSumAggregateOutputType = {
    id: number | null
    spellId: number | null
    schoolId: number | null
  }

  export type SpellSubschoolMapMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    schoolId: number | null
  }

  export type SpellSubschoolMapMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    schoolId: number | null
  }

  export type SpellSubschoolMapCountAggregateOutputType = {
    id: number
    spellId: number
    schoolId: number
    _all: number
  }


  export type SpellSubschoolMapAvgAggregateInputType = {
    id?: true
    spellId?: true
    schoolId?: true
  }

  export type SpellSubschoolMapSumAggregateInputType = {
    id?: true
    spellId?: true
    schoolId?: true
  }

  export type SpellSubschoolMapMinAggregateInputType = {
    id?: true
    spellId?: true
    schoolId?: true
  }

  export type SpellSubschoolMapMaxAggregateInputType = {
    id?: true
    spellId?: true
    schoolId?: true
  }

  export type SpellSubschoolMapCountAggregateInputType = {
    id?: true
    spellId?: true
    schoolId?: true
    _all?: true
  }

  export type SpellSubschoolMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellSubschoolMap to aggregate.
     */
    where?: SpellSubschoolMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSubschoolMaps to fetch.
     */
    orderBy?: SpellSubschoolMapOrderByWithRelationInput | SpellSubschoolMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellSubschoolMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSubschoolMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSubschoolMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellSubschoolMaps
    **/
    _count?: true | SpellSubschoolMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellSubschoolMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellSubschoolMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellSubschoolMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellSubschoolMapMaxAggregateInputType
  }

  export type GetSpellSubschoolMapAggregateType<T extends SpellSubschoolMapAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellSubschoolMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellSubschoolMap[P]>
      : GetScalarType<T[P], AggregateSpellSubschoolMap[P]>
  }




  export type SpellSubschoolMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellSubschoolMapWhereInput
    orderBy?: SpellSubschoolMapOrderByWithAggregationInput | SpellSubschoolMapOrderByWithAggregationInput[]
    by: SpellSubschoolMapScalarFieldEnum[] | SpellSubschoolMapScalarFieldEnum
    having?: SpellSubschoolMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellSubschoolMapCountAggregateInputType | true
    _avg?: SpellSubschoolMapAvgAggregateInputType
    _sum?: SpellSubschoolMapSumAggregateInputType
    _min?: SpellSubschoolMapMinAggregateInputType
    _max?: SpellSubschoolMapMaxAggregateInputType
  }

  export type SpellSubschoolMapGroupByOutputType = {
    id: number
    spellId: number
    schoolId: number
    _count: SpellSubschoolMapCountAggregateOutputType | null
    _avg: SpellSubschoolMapAvgAggregateOutputType | null
    _sum: SpellSubschoolMapSumAggregateOutputType | null
    _min: SpellSubschoolMapMinAggregateOutputType | null
    _max: SpellSubschoolMapMaxAggregateOutputType | null
  }

  type GetSpellSubschoolMapGroupByPayload<T extends SpellSubschoolMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellSubschoolMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellSubschoolMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellSubschoolMapGroupByOutputType[P]>
            : GetScalarType<T[P], SpellSubschoolMapGroupByOutputType[P]>
        }
      >
    >


  export type SpellSubschoolMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    schoolId?: boolean
    Spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellSubschoolMap"]>



  export type SpellSubschoolMapSelectScalar = {
    id?: boolean
    spellId?: boolean
    schoolId?: boolean
  }

  export type SpellSubschoolMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "spellId" | "schoolId", ExtArgs["result"]["spellSubschoolMap"]>
  export type SpellSubschoolMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Spell?: boolean | SpellDefaultArgs<ExtArgs>
  }

  export type $SpellSubschoolMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellSubschoolMap"
    objects: {
      Spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      schoolId: number
    }, ExtArgs["result"]["spellSubschoolMap"]>
    composites: {}
  }

  type SpellSubschoolMapGetPayload<S extends boolean | null | undefined | SpellSubschoolMapDefaultArgs> = $Result.GetResult<Prisma.$SpellSubschoolMapPayload, S>

  type SpellSubschoolMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellSubschoolMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellSubschoolMapCountAggregateInputType | true
    }

  export interface SpellSubschoolMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellSubschoolMap'], meta: { name: 'SpellSubschoolMap' } }
    /**
     * Find zero or one SpellSubschoolMap that matches the filter.
     * @param {SpellSubschoolMapFindUniqueArgs} args - Arguments to find a SpellSubschoolMap
     * @example
     * // Get one SpellSubschoolMap
     * const spellSubschoolMap = await prisma.spellSubschoolMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellSubschoolMapFindUniqueArgs>(args: SelectSubset<T, SpellSubschoolMapFindUniqueArgs<ExtArgs>>): Prisma__SpellSubschoolMapClient<$Result.GetResult<Prisma.$SpellSubschoolMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpellSubschoolMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellSubschoolMapFindUniqueOrThrowArgs} args - Arguments to find a SpellSubschoolMap
     * @example
     * // Get one SpellSubschoolMap
     * const spellSubschoolMap = await prisma.spellSubschoolMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellSubschoolMapFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellSubschoolMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellSubschoolMapClient<$Result.GetResult<Prisma.$SpellSubschoolMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellSubschoolMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSubschoolMapFindFirstArgs} args - Arguments to find a SpellSubschoolMap
     * @example
     * // Get one SpellSubschoolMap
     * const spellSubschoolMap = await prisma.spellSubschoolMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellSubschoolMapFindFirstArgs>(args?: SelectSubset<T, SpellSubschoolMapFindFirstArgs<ExtArgs>>): Prisma__SpellSubschoolMapClient<$Result.GetResult<Prisma.$SpellSubschoolMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellSubschoolMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSubschoolMapFindFirstOrThrowArgs} args - Arguments to find a SpellSubschoolMap
     * @example
     * // Get one SpellSubschoolMap
     * const spellSubschoolMap = await prisma.spellSubschoolMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellSubschoolMapFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellSubschoolMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellSubschoolMapClient<$Result.GetResult<Prisma.$SpellSubschoolMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpellSubschoolMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSubschoolMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellSubschoolMaps
     * const spellSubschoolMaps = await prisma.spellSubschoolMap.findMany()
     * 
     * // Get first 10 SpellSubschoolMaps
     * const spellSubschoolMaps = await prisma.spellSubschoolMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellSubschoolMapWithIdOnly = await prisma.spellSubschoolMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpellSubschoolMapFindManyArgs>(args?: SelectSubset<T, SpellSubschoolMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellSubschoolMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpellSubschoolMap.
     * @param {SpellSubschoolMapCreateArgs} args - Arguments to create a SpellSubschoolMap.
     * @example
     * // Create one SpellSubschoolMap
     * const SpellSubschoolMap = await prisma.spellSubschoolMap.create({
     *   data: {
     *     // ... data to create a SpellSubschoolMap
     *   }
     * })
     * 
     */
    create<T extends SpellSubschoolMapCreateArgs>(args: SelectSubset<T, SpellSubschoolMapCreateArgs<ExtArgs>>): Prisma__SpellSubschoolMapClient<$Result.GetResult<Prisma.$SpellSubschoolMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpellSubschoolMaps.
     * @param {SpellSubschoolMapCreateManyArgs} args - Arguments to create many SpellSubschoolMaps.
     * @example
     * // Create many SpellSubschoolMaps
     * const spellSubschoolMap = await prisma.spellSubschoolMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellSubschoolMapCreateManyArgs>(args?: SelectSubset<T, SpellSubschoolMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellSubschoolMap.
     * @param {SpellSubschoolMapDeleteArgs} args - Arguments to delete one SpellSubschoolMap.
     * @example
     * // Delete one SpellSubschoolMap
     * const SpellSubschoolMap = await prisma.spellSubschoolMap.delete({
     *   where: {
     *     // ... filter to delete one SpellSubschoolMap
     *   }
     * })
     * 
     */
    delete<T extends SpellSubschoolMapDeleteArgs>(args: SelectSubset<T, SpellSubschoolMapDeleteArgs<ExtArgs>>): Prisma__SpellSubschoolMapClient<$Result.GetResult<Prisma.$SpellSubschoolMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpellSubschoolMap.
     * @param {SpellSubschoolMapUpdateArgs} args - Arguments to update one SpellSubschoolMap.
     * @example
     * // Update one SpellSubschoolMap
     * const spellSubschoolMap = await prisma.spellSubschoolMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellSubschoolMapUpdateArgs>(args: SelectSubset<T, SpellSubschoolMapUpdateArgs<ExtArgs>>): Prisma__SpellSubschoolMapClient<$Result.GetResult<Prisma.$SpellSubschoolMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpellSubschoolMaps.
     * @param {SpellSubschoolMapDeleteManyArgs} args - Arguments to filter SpellSubschoolMaps to delete.
     * @example
     * // Delete a few SpellSubschoolMaps
     * const { count } = await prisma.spellSubschoolMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellSubschoolMapDeleteManyArgs>(args?: SelectSubset<T, SpellSubschoolMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellSubschoolMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSubschoolMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellSubschoolMaps
     * const spellSubschoolMap = await prisma.spellSubschoolMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellSubschoolMapUpdateManyArgs>(args: SelectSubset<T, SpellSubschoolMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellSubschoolMap.
     * @param {SpellSubschoolMapUpsertArgs} args - Arguments to update or create a SpellSubschoolMap.
     * @example
     * // Update or create a SpellSubschoolMap
     * const spellSubschoolMap = await prisma.spellSubschoolMap.upsert({
     *   create: {
     *     // ... data to create a SpellSubschoolMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellSubschoolMap we want to update
     *   }
     * })
     */
    upsert<T extends SpellSubschoolMapUpsertArgs>(args: SelectSubset<T, SpellSubschoolMapUpsertArgs<ExtArgs>>): Prisma__SpellSubschoolMapClient<$Result.GetResult<Prisma.$SpellSubschoolMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpellSubschoolMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSubschoolMapCountArgs} args - Arguments to filter SpellSubschoolMaps to count.
     * @example
     * // Count the number of SpellSubschoolMaps
     * const count = await prisma.spellSubschoolMap.count({
     *   where: {
     *     // ... the filter for the SpellSubschoolMaps we want to count
     *   }
     * })
    **/
    count<T extends SpellSubschoolMapCountArgs>(
      args?: Subset<T, SpellSubschoolMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellSubschoolMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellSubschoolMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSubschoolMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellSubschoolMapAggregateArgs>(args: Subset<T, SpellSubschoolMapAggregateArgs>): Prisma.PrismaPromise<GetSpellSubschoolMapAggregateType<T>>

    /**
     * Group by SpellSubschoolMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSubschoolMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellSubschoolMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellSubschoolMapGroupByArgs['orderBy'] }
        : { orderBy?: SpellSubschoolMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellSubschoolMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellSubschoolMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellSubschoolMap model
   */
  readonly fields: SpellSubschoolMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellSubschoolMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellSubschoolMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpellSubschoolMap model
   */
  interface SpellSubschoolMapFieldRefs {
    readonly id: FieldRef<"SpellSubschoolMap", 'Int'>
    readonly spellId: FieldRef<"SpellSubschoolMap", 'Int'>
    readonly schoolId: FieldRef<"SpellSubschoolMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpellSubschoolMap findUnique
   */
  export type SpellSubschoolMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSubschoolMap
     */
    select?: SpellSubschoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSubschoolMap
     */
    omit?: SpellSubschoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSubschoolMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSubschoolMap to fetch.
     */
    where: SpellSubschoolMapWhereUniqueInput
  }

  /**
   * SpellSubschoolMap findUniqueOrThrow
   */
  export type SpellSubschoolMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSubschoolMap
     */
    select?: SpellSubschoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSubschoolMap
     */
    omit?: SpellSubschoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSubschoolMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSubschoolMap to fetch.
     */
    where: SpellSubschoolMapWhereUniqueInput
  }

  /**
   * SpellSubschoolMap findFirst
   */
  export type SpellSubschoolMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSubschoolMap
     */
    select?: SpellSubschoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSubschoolMap
     */
    omit?: SpellSubschoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSubschoolMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSubschoolMap to fetch.
     */
    where?: SpellSubschoolMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSubschoolMaps to fetch.
     */
    orderBy?: SpellSubschoolMapOrderByWithRelationInput | SpellSubschoolMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellSubschoolMaps.
     */
    cursor?: SpellSubschoolMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSubschoolMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSubschoolMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellSubschoolMaps.
     */
    distinct?: SpellSubschoolMapScalarFieldEnum | SpellSubschoolMapScalarFieldEnum[]
  }

  /**
   * SpellSubschoolMap findFirstOrThrow
   */
  export type SpellSubschoolMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSubschoolMap
     */
    select?: SpellSubschoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSubschoolMap
     */
    omit?: SpellSubschoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSubschoolMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSubschoolMap to fetch.
     */
    where?: SpellSubschoolMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSubschoolMaps to fetch.
     */
    orderBy?: SpellSubschoolMapOrderByWithRelationInput | SpellSubschoolMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellSubschoolMaps.
     */
    cursor?: SpellSubschoolMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSubschoolMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSubschoolMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellSubschoolMaps.
     */
    distinct?: SpellSubschoolMapScalarFieldEnum | SpellSubschoolMapScalarFieldEnum[]
  }

  /**
   * SpellSubschoolMap findMany
   */
  export type SpellSubschoolMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSubschoolMap
     */
    select?: SpellSubschoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSubschoolMap
     */
    omit?: SpellSubschoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSubschoolMapInclude<ExtArgs> | null
    /**
     * Filter, which SpellSubschoolMaps to fetch.
     */
    where?: SpellSubschoolMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSubschoolMaps to fetch.
     */
    orderBy?: SpellSubschoolMapOrderByWithRelationInput | SpellSubschoolMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellSubschoolMaps.
     */
    cursor?: SpellSubschoolMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSubschoolMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSubschoolMaps.
     */
    skip?: number
    distinct?: SpellSubschoolMapScalarFieldEnum | SpellSubschoolMapScalarFieldEnum[]
  }

  /**
   * SpellSubschoolMap create
   */
  export type SpellSubschoolMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSubschoolMap
     */
    select?: SpellSubschoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSubschoolMap
     */
    omit?: SpellSubschoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSubschoolMapInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellSubschoolMap.
     */
    data: XOR<SpellSubschoolMapCreateInput, SpellSubschoolMapUncheckedCreateInput>
  }

  /**
   * SpellSubschoolMap createMany
   */
  export type SpellSubschoolMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellSubschoolMaps.
     */
    data: SpellSubschoolMapCreateManyInput | SpellSubschoolMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpellSubschoolMap update
   */
  export type SpellSubschoolMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSubschoolMap
     */
    select?: SpellSubschoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSubschoolMap
     */
    omit?: SpellSubschoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSubschoolMapInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellSubschoolMap.
     */
    data: XOR<SpellSubschoolMapUpdateInput, SpellSubschoolMapUncheckedUpdateInput>
    /**
     * Choose, which SpellSubschoolMap to update.
     */
    where: SpellSubschoolMapWhereUniqueInput
  }

  /**
   * SpellSubschoolMap updateMany
   */
  export type SpellSubschoolMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellSubschoolMaps.
     */
    data: XOR<SpellSubschoolMapUpdateManyMutationInput, SpellSubschoolMapUncheckedUpdateManyInput>
    /**
     * Filter which SpellSubschoolMaps to update
     */
    where?: SpellSubschoolMapWhereInput
    /**
     * Limit how many SpellSubschoolMaps to update.
     */
    limit?: number
  }

  /**
   * SpellSubschoolMap upsert
   */
  export type SpellSubschoolMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSubschoolMap
     */
    select?: SpellSubschoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSubschoolMap
     */
    omit?: SpellSubschoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSubschoolMapInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellSubschoolMap to update in case it exists.
     */
    where: SpellSubschoolMapWhereUniqueInput
    /**
     * In case the SpellSubschoolMap found by the `where` argument doesn't exist, create a new SpellSubschoolMap with this data.
     */
    create: XOR<SpellSubschoolMapCreateInput, SpellSubschoolMapUncheckedCreateInput>
    /**
     * In case the SpellSubschoolMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellSubschoolMapUpdateInput, SpellSubschoolMapUncheckedUpdateInput>
  }

  /**
   * SpellSubschoolMap delete
   */
  export type SpellSubschoolMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSubschoolMap
     */
    select?: SpellSubschoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSubschoolMap
     */
    omit?: SpellSubschoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSubschoolMapInclude<ExtArgs> | null
    /**
     * Filter which SpellSubschoolMap to delete.
     */
    where: SpellSubschoolMapWhereUniqueInput
  }

  /**
   * SpellSubschoolMap deleteMany
   */
  export type SpellSubschoolMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellSubschoolMaps to delete
     */
    where?: SpellSubschoolMapWhereInput
    /**
     * Limit how many SpellSubschoolMaps to delete.
     */
    limit?: number
  }

  /**
   * SpellSubschoolMap without action
   */
  export type SpellSubschoolMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSubschoolMap
     */
    select?: SpellSubschoolMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSubschoolMap
     */
    omit?: SpellSubschoolMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSubschoolMapInclude<ExtArgs> | null
  }


  /**
   * Model SpellComponentMap
   */

  export type AggregateSpellComponentMap = {
    _count: SpellComponentMapCountAggregateOutputType | null
    _avg: SpellComponentMapAvgAggregateOutputType | null
    _sum: SpellComponentMapSumAggregateOutputType | null
    _min: SpellComponentMapMinAggregateOutputType | null
    _max: SpellComponentMapMaxAggregateOutputType | null
  }

  export type SpellComponentMapAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
    componentId: number | null
  }

  export type SpellComponentMapSumAggregateOutputType = {
    id: number | null
    spellId: number | null
    componentId: number | null
  }

  export type SpellComponentMapMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    componentId: number | null
  }

  export type SpellComponentMapMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    componentId: number | null
  }

  export type SpellComponentMapCountAggregateOutputType = {
    id: number
    spellId: number
    componentId: number
    _all: number
  }


  export type SpellComponentMapAvgAggregateInputType = {
    id?: true
    spellId?: true
    componentId?: true
  }

  export type SpellComponentMapSumAggregateInputType = {
    id?: true
    spellId?: true
    componentId?: true
  }

  export type SpellComponentMapMinAggregateInputType = {
    id?: true
    spellId?: true
    componentId?: true
  }

  export type SpellComponentMapMaxAggregateInputType = {
    id?: true
    spellId?: true
    componentId?: true
  }

  export type SpellComponentMapCountAggregateInputType = {
    id?: true
    spellId?: true
    componentId?: true
    _all?: true
  }

  export type SpellComponentMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellComponentMap to aggregate.
     */
    where?: SpellComponentMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellComponentMaps to fetch.
     */
    orderBy?: SpellComponentMapOrderByWithRelationInput | SpellComponentMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellComponentMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellComponentMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellComponentMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellComponentMaps
    **/
    _count?: true | SpellComponentMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellComponentMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellComponentMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellComponentMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellComponentMapMaxAggregateInputType
  }

  export type GetSpellComponentMapAggregateType<T extends SpellComponentMapAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellComponentMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellComponentMap[P]>
      : GetScalarType<T[P], AggregateSpellComponentMap[P]>
  }




  export type SpellComponentMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellComponentMapWhereInput
    orderBy?: SpellComponentMapOrderByWithAggregationInput | SpellComponentMapOrderByWithAggregationInput[]
    by: SpellComponentMapScalarFieldEnum[] | SpellComponentMapScalarFieldEnum
    having?: SpellComponentMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellComponentMapCountAggregateInputType | true
    _avg?: SpellComponentMapAvgAggregateInputType
    _sum?: SpellComponentMapSumAggregateInputType
    _min?: SpellComponentMapMinAggregateInputType
    _max?: SpellComponentMapMaxAggregateInputType
  }

  export type SpellComponentMapGroupByOutputType = {
    id: number
    spellId: number
    componentId: number
    _count: SpellComponentMapCountAggregateOutputType | null
    _avg: SpellComponentMapAvgAggregateOutputType | null
    _sum: SpellComponentMapSumAggregateOutputType | null
    _min: SpellComponentMapMinAggregateOutputType | null
    _max: SpellComponentMapMaxAggregateOutputType | null
  }

  type GetSpellComponentMapGroupByPayload<T extends SpellComponentMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellComponentMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellComponentMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellComponentMapGroupByOutputType[P]>
            : GetScalarType<T[P], SpellComponentMapGroupByOutputType[P]>
        }
      >
    >


  export type SpellComponentMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    componentId?: boolean
  }, ExtArgs["result"]["spellComponentMap"]>



  export type SpellComponentMapSelectScalar = {
    id?: boolean
    spellId?: boolean
    componentId?: boolean
  }

  export type SpellComponentMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "spellId" | "componentId", ExtArgs["result"]["spellComponentMap"]>

  export type $SpellComponentMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellComponentMap"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      componentId: number
    }, ExtArgs["result"]["spellComponentMap"]>
    composites: {}
  }

  type SpellComponentMapGetPayload<S extends boolean | null | undefined | SpellComponentMapDefaultArgs> = $Result.GetResult<Prisma.$SpellComponentMapPayload, S>

  type SpellComponentMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellComponentMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellComponentMapCountAggregateInputType | true
    }

  export interface SpellComponentMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellComponentMap'], meta: { name: 'SpellComponentMap' } }
    /**
     * Find zero or one SpellComponentMap that matches the filter.
     * @param {SpellComponentMapFindUniqueArgs} args - Arguments to find a SpellComponentMap
     * @example
     * // Get one SpellComponentMap
     * const spellComponentMap = await prisma.spellComponentMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellComponentMapFindUniqueArgs>(args: SelectSubset<T, SpellComponentMapFindUniqueArgs<ExtArgs>>): Prisma__SpellComponentMapClient<$Result.GetResult<Prisma.$SpellComponentMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpellComponentMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellComponentMapFindUniqueOrThrowArgs} args - Arguments to find a SpellComponentMap
     * @example
     * // Get one SpellComponentMap
     * const spellComponentMap = await prisma.spellComponentMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellComponentMapFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellComponentMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellComponentMapClient<$Result.GetResult<Prisma.$SpellComponentMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellComponentMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentMapFindFirstArgs} args - Arguments to find a SpellComponentMap
     * @example
     * // Get one SpellComponentMap
     * const spellComponentMap = await prisma.spellComponentMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellComponentMapFindFirstArgs>(args?: SelectSubset<T, SpellComponentMapFindFirstArgs<ExtArgs>>): Prisma__SpellComponentMapClient<$Result.GetResult<Prisma.$SpellComponentMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellComponentMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentMapFindFirstOrThrowArgs} args - Arguments to find a SpellComponentMap
     * @example
     * // Get one SpellComponentMap
     * const spellComponentMap = await prisma.spellComponentMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellComponentMapFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellComponentMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellComponentMapClient<$Result.GetResult<Prisma.$SpellComponentMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpellComponentMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellComponentMaps
     * const spellComponentMaps = await prisma.spellComponentMap.findMany()
     * 
     * // Get first 10 SpellComponentMaps
     * const spellComponentMaps = await prisma.spellComponentMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellComponentMapWithIdOnly = await prisma.spellComponentMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpellComponentMapFindManyArgs>(args?: SelectSubset<T, SpellComponentMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellComponentMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpellComponentMap.
     * @param {SpellComponentMapCreateArgs} args - Arguments to create a SpellComponentMap.
     * @example
     * // Create one SpellComponentMap
     * const SpellComponentMap = await prisma.spellComponentMap.create({
     *   data: {
     *     // ... data to create a SpellComponentMap
     *   }
     * })
     * 
     */
    create<T extends SpellComponentMapCreateArgs>(args: SelectSubset<T, SpellComponentMapCreateArgs<ExtArgs>>): Prisma__SpellComponentMapClient<$Result.GetResult<Prisma.$SpellComponentMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpellComponentMaps.
     * @param {SpellComponentMapCreateManyArgs} args - Arguments to create many SpellComponentMaps.
     * @example
     * // Create many SpellComponentMaps
     * const spellComponentMap = await prisma.spellComponentMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellComponentMapCreateManyArgs>(args?: SelectSubset<T, SpellComponentMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellComponentMap.
     * @param {SpellComponentMapDeleteArgs} args - Arguments to delete one SpellComponentMap.
     * @example
     * // Delete one SpellComponentMap
     * const SpellComponentMap = await prisma.spellComponentMap.delete({
     *   where: {
     *     // ... filter to delete one SpellComponentMap
     *   }
     * })
     * 
     */
    delete<T extends SpellComponentMapDeleteArgs>(args: SelectSubset<T, SpellComponentMapDeleteArgs<ExtArgs>>): Prisma__SpellComponentMapClient<$Result.GetResult<Prisma.$SpellComponentMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpellComponentMap.
     * @param {SpellComponentMapUpdateArgs} args - Arguments to update one SpellComponentMap.
     * @example
     * // Update one SpellComponentMap
     * const spellComponentMap = await prisma.spellComponentMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellComponentMapUpdateArgs>(args: SelectSubset<T, SpellComponentMapUpdateArgs<ExtArgs>>): Prisma__SpellComponentMapClient<$Result.GetResult<Prisma.$SpellComponentMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpellComponentMaps.
     * @param {SpellComponentMapDeleteManyArgs} args - Arguments to filter SpellComponentMaps to delete.
     * @example
     * // Delete a few SpellComponentMaps
     * const { count } = await prisma.spellComponentMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellComponentMapDeleteManyArgs>(args?: SelectSubset<T, SpellComponentMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellComponentMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellComponentMaps
     * const spellComponentMap = await prisma.spellComponentMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellComponentMapUpdateManyArgs>(args: SelectSubset<T, SpellComponentMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellComponentMap.
     * @param {SpellComponentMapUpsertArgs} args - Arguments to update or create a SpellComponentMap.
     * @example
     * // Update or create a SpellComponentMap
     * const spellComponentMap = await prisma.spellComponentMap.upsert({
     *   create: {
     *     // ... data to create a SpellComponentMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellComponentMap we want to update
     *   }
     * })
     */
    upsert<T extends SpellComponentMapUpsertArgs>(args: SelectSubset<T, SpellComponentMapUpsertArgs<ExtArgs>>): Prisma__SpellComponentMapClient<$Result.GetResult<Prisma.$SpellComponentMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpellComponentMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentMapCountArgs} args - Arguments to filter SpellComponentMaps to count.
     * @example
     * // Count the number of SpellComponentMaps
     * const count = await prisma.spellComponentMap.count({
     *   where: {
     *     // ... the filter for the SpellComponentMaps we want to count
     *   }
     * })
    **/
    count<T extends SpellComponentMapCountArgs>(
      args?: Subset<T, SpellComponentMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellComponentMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellComponentMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellComponentMapAggregateArgs>(args: Subset<T, SpellComponentMapAggregateArgs>): Prisma.PrismaPromise<GetSpellComponentMapAggregateType<T>>

    /**
     * Group by SpellComponentMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellComponentMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellComponentMapGroupByArgs['orderBy'] }
        : { orderBy?: SpellComponentMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellComponentMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellComponentMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellComponentMap model
   */
  readonly fields: SpellComponentMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellComponentMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellComponentMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpellComponentMap model
   */
  interface SpellComponentMapFieldRefs {
    readonly id: FieldRef<"SpellComponentMap", 'Int'>
    readonly spellId: FieldRef<"SpellComponentMap", 'Int'>
    readonly componentId: FieldRef<"SpellComponentMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpellComponentMap findUnique
   */
  export type SpellComponentMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponentMap
     */
    select?: SpellComponentMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellComponentMap
     */
    omit?: SpellComponentMapOmit<ExtArgs> | null
    /**
     * Filter, which SpellComponentMap to fetch.
     */
    where: SpellComponentMapWhereUniqueInput
  }

  /**
   * SpellComponentMap findUniqueOrThrow
   */
  export type SpellComponentMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponentMap
     */
    select?: SpellComponentMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellComponentMap
     */
    omit?: SpellComponentMapOmit<ExtArgs> | null
    /**
     * Filter, which SpellComponentMap to fetch.
     */
    where: SpellComponentMapWhereUniqueInput
  }

  /**
   * SpellComponentMap findFirst
   */
  export type SpellComponentMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponentMap
     */
    select?: SpellComponentMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellComponentMap
     */
    omit?: SpellComponentMapOmit<ExtArgs> | null
    /**
     * Filter, which SpellComponentMap to fetch.
     */
    where?: SpellComponentMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellComponentMaps to fetch.
     */
    orderBy?: SpellComponentMapOrderByWithRelationInput | SpellComponentMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellComponentMaps.
     */
    cursor?: SpellComponentMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellComponentMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellComponentMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellComponentMaps.
     */
    distinct?: SpellComponentMapScalarFieldEnum | SpellComponentMapScalarFieldEnum[]
  }

  /**
   * SpellComponentMap findFirstOrThrow
   */
  export type SpellComponentMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponentMap
     */
    select?: SpellComponentMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellComponentMap
     */
    omit?: SpellComponentMapOmit<ExtArgs> | null
    /**
     * Filter, which SpellComponentMap to fetch.
     */
    where?: SpellComponentMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellComponentMaps to fetch.
     */
    orderBy?: SpellComponentMapOrderByWithRelationInput | SpellComponentMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellComponentMaps.
     */
    cursor?: SpellComponentMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellComponentMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellComponentMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellComponentMaps.
     */
    distinct?: SpellComponentMapScalarFieldEnum | SpellComponentMapScalarFieldEnum[]
  }

  /**
   * SpellComponentMap findMany
   */
  export type SpellComponentMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponentMap
     */
    select?: SpellComponentMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellComponentMap
     */
    omit?: SpellComponentMapOmit<ExtArgs> | null
    /**
     * Filter, which SpellComponentMaps to fetch.
     */
    where?: SpellComponentMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellComponentMaps to fetch.
     */
    orderBy?: SpellComponentMapOrderByWithRelationInput | SpellComponentMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellComponentMaps.
     */
    cursor?: SpellComponentMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellComponentMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellComponentMaps.
     */
    skip?: number
    distinct?: SpellComponentMapScalarFieldEnum | SpellComponentMapScalarFieldEnum[]
  }

  /**
   * SpellComponentMap create
   */
  export type SpellComponentMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponentMap
     */
    select?: SpellComponentMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellComponentMap
     */
    omit?: SpellComponentMapOmit<ExtArgs> | null
    /**
     * The data needed to create a SpellComponentMap.
     */
    data: XOR<SpellComponentMapCreateInput, SpellComponentMapUncheckedCreateInput>
  }

  /**
   * SpellComponentMap createMany
   */
  export type SpellComponentMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellComponentMaps.
     */
    data: SpellComponentMapCreateManyInput | SpellComponentMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpellComponentMap update
   */
  export type SpellComponentMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponentMap
     */
    select?: SpellComponentMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellComponentMap
     */
    omit?: SpellComponentMapOmit<ExtArgs> | null
    /**
     * The data needed to update a SpellComponentMap.
     */
    data: XOR<SpellComponentMapUpdateInput, SpellComponentMapUncheckedUpdateInput>
    /**
     * Choose, which SpellComponentMap to update.
     */
    where: SpellComponentMapWhereUniqueInput
  }

  /**
   * SpellComponentMap updateMany
   */
  export type SpellComponentMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellComponentMaps.
     */
    data: XOR<SpellComponentMapUpdateManyMutationInput, SpellComponentMapUncheckedUpdateManyInput>
    /**
     * Filter which SpellComponentMaps to update
     */
    where?: SpellComponentMapWhereInput
    /**
     * Limit how many SpellComponentMaps to update.
     */
    limit?: number
  }

  /**
   * SpellComponentMap upsert
   */
  export type SpellComponentMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponentMap
     */
    select?: SpellComponentMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellComponentMap
     */
    omit?: SpellComponentMapOmit<ExtArgs> | null
    /**
     * The filter to search for the SpellComponentMap to update in case it exists.
     */
    where: SpellComponentMapWhereUniqueInput
    /**
     * In case the SpellComponentMap found by the `where` argument doesn't exist, create a new SpellComponentMap with this data.
     */
    create: XOR<SpellComponentMapCreateInput, SpellComponentMapUncheckedCreateInput>
    /**
     * In case the SpellComponentMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellComponentMapUpdateInput, SpellComponentMapUncheckedUpdateInput>
  }

  /**
   * SpellComponentMap delete
   */
  export type SpellComponentMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponentMap
     */
    select?: SpellComponentMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellComponentMap
     */
    omit?: SpellComponentMapOmit<ExtArgs> | null
    /**
     * Filter which SpellComponentMap to delete.
     */
    where: SpellComponentMapWhereUniqueInput
  }

  /**
   * SpellComponentMap deleteMany
   */
  export type SpellComponentMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellComponentMaps to delete
     */
    where?: SpellComponentMapWhereInput
    /**
     * Limit how many SpellComponentMaps to delete.
     */
    limit?: number
  }

  /**
   * SpellComponentMap without action
   */
  export type SpellComponentMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponentMap
     */
    select?: SpellComponentMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellComponentMap
     */
    omit?: SpellComponentMapOmit<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillAvgAggregateOutputType = {
    id: number | null
    abilityId: number | null
    retryTypeId: number | null
  }

  export type SkillSumAggregateOutputType = {
    id: number | null
    abilityId: number | null
    retryTypeId: number | null
  }

  export type SkillMinAggregateOutputType = {
    id: number | null
    name: string | null
    abilityId: number | null
    checkDescription: string | null
    actionDescription: string | null
    retryTypeId: number | null
    retryDescription: string | null
    specialNotes: string | null
    synergyNotes: string | null
    untrainedNotes: string | null
    affectedByArmor: boolean | null
    description: string | null
    trainedOnly: boolean | null
  }

  export type SkillMaxAggregateOutputType = {
    id: number | null
    name: string | null
    abilityId: number | null
    checkDescription: string | null
    actionDescription: string | null
    retryTypeId: number | null
    retryDescription: string | null
    specialNotes: string | null
    synergyNotes: string | null
    untrainedNotes: string | null
    affectedByArmor: boolean | null
    description: string | null
    trainedOnly: boolean | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    abilityId: number
    checkDescription: number
    actionDescription: number
    retryTypeId: number
    retryDescription: number
    specialNotes: number
    synergyNotes: number
    untrainedNotes: number
    affectedByArmor: number
    description: number
    trainedOnly: number
    _all: number
  }


  export type SkillAvgAggregateInputType = {
    id?: true
    abilityId?: true
    retryTypeId?: true
  }

  export type SkillSumAggregateInputType = {
    id?: true
    abilityId?: true
    retryTypeId?: true
  }

  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    abilityId?: true
    checkDescription?: true
    actionDescription?: true
    retryTypeId?: true
    retryDescription?: true
    specialNotes?: true
    synergyNotes?: true
    untrainedNotes?: true
    affectedByArmor?: true
    description?: true
    trainedOnly?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    abilityId?: true
    checkDescription?: true
    actionDescription?: true
    retryTypeId?: true
    retryDescription?: true
    specialNotes?: true
    synergyNotes?: true
    untrainedNotes?: true
    affectedByArmor?: true
    description?: true
    trainedOnly?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    abilityId?: true
    checkDescription?: true
    actionDescription?: true
    retryTypeId?: true
    retryDescription?: true
    specialNotes?: true
    synergyNotes?: true
    untrainedNotes?: true
    affectedByArmor?: true
    description?: true
    trainedOnly?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _avg?: SkillAvgAggregateInputType
    _sum?: SkillSumAggregateInputType
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: number
    name: string
    abilityId: number
    checkDescription: string | null
    actionDescription: string | null
    retryTypeId: number | null
    retryDescription: string | null
    specialNotes: string | null
    synergyNotes: string | null
    untrainedNotes: string | null
    affectedByArmor: boolean
    description: string | null
    trainedOnly: boolean | null
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abilityId?: boolean
    checkDescription?: boolean
    actionDescription?: boolean
    retryTypeId?: boolean
    retryDescription?: boolean
    specialNotes?: boolean
    synergyNotes?: boolean
    untrainedNotes?: boolean
    affectedByArmor?: boolean
    description?: boolean
    trainedOnly?: boolean
    classes?: boolean | Skill$classesArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>



  export type SkillSelectScalar = {
    id?: boolean
    name?: boolean
    abilityId?: boolean
    checkDescription?: boolean
    actionDescription?: boolean
    retryTypeId?: boolean
    retryDescription?: boolean
    specialNotes?: boolean
    synergyNotes?: boolean
    untrainedNotes?: boolean
    affectedByArmor?: boolean
    description?: boolean
    trainedOnly?: boolean
  }

  export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abilityId" | "checkDescription" | "actionDescription" | "retryTypeId" | "retryDescription" | "specialNotes" | "synergyNotes" | "untrainedNotes" | "affectedByArmor" | "description" | "trainedOnly", ExtArgs["result"]["skill"]>
  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | Skill$classesArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      classes: Prisma.$ClassSkillMapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      abilityId: number
      checkDescription: string | null
      actionDescription: string | null
      retryTypeId: number | null
      retryDescription: string | null
      specialNotes: string | null
      synergyNotes: string | null
      untrainedNotes: string | null
      affectedByArmor: boolean
      description: string | null
      trainedOnly: boolean | null
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends Skill$classesArgs<ExtArgs> = {}>(args?: Subset<T, Skill$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSkillMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'Int'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly abilityId: FieldRef<"Skill", 'Int'>
    readonly checkDescription: FieldRef<"Skill", 'String'>
    readonly actionDescription: FieldRef<"Skill", 'String'>
    readonly retryTypeId: FieldRef<"Skill", 'Int'>
    readonly retryDescription: FieldRef<"Skill", 'String'>
    readonly specialNotes: FieldRef<"Skill", 'String'>
    readonly synergyNotes: FieldRef<"Skill", 'String'>
    readonly untrainedNotes: FieldRef<"Skill", 'String'>
    readonly affectedByArmor: FieldRef<"Skill", 'Boolean'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly trainedOnly: FieldRef<"Skill", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skill.classes
   */
  export type Skill$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkillMap
     */
    select?: ClassSkillMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSkillMap
     */
    omit?: ClassSkillMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSkillMapInclude<ExtArgs> | null
    where?: ClassSkillMapWhereInput
    orderBy?: ClassSkillMapOrderByWithRelationInput | ClassSkillMapOrderByWithRelationInput[]
    cursor?: ClassSkillMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSkillMapScalarFieldEnum | ClassSkillMapScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model Feat
   */

  export type AggregateFeat = {
    _count: FeatCountAggregateOutputType | null
    _avg: FeatAvgAggregateOutputType | null
    _sum: FeatSumAggregateOutputType | null
    _min: FeatMinAggregateOutputType | null
    _max: FeatMaxAggregateOutputType | null
  }

  export type FeatAvgAggregateOutputType = {
    id: number | null
    typeId: number | null
  }

  export type FeatSumAggregateOutputType = {
    id: number | null
    typeId: number | null
  }

  export type FeatMinAggregateOutputType = {
    id: number | null
    name: string | null
    typeId: number | null
    description: string | null
    benefit: string | null
    normalEffect: string | null
    specialEffect: string | null
    prerequisites: string | null
    repeatable: boolean | null
    fighterBonus: boolean | null
  }

  export type FeatMaxAggregateOutputType = {
    id: number | null
    name: string | null
    typeId: number | null
    description: string | null
    benefit: string | null
    normalEffect: string | null
    specialEffect: string | null
    prerequisites: string | null
    repeatable: boolean | null
    fighterBonus: boolean | null
  }

  export type FeatCountAggregateOutputType = {
    id: number
    name: number
    typeId: number
    description: number
    benefit: number
    normalEffect: number
    specialEffect: number
    prerequisites: number
    repeatable: number
    fighterBonus: number
    _all: number
  }


  export type FeatAvgAggregateInputType = {
    id?: true
    typeId?: true
  }

  export type FeatSumAggregateInputType = {
    id?: true
    typeId?: true
  }

  export type FeatMinAggregateInputType = {
    id?: true
    name?: true
    typeId?: true
    description?: true
    benefit?: true
    normalEffect?: true
    specialEffect?: true
    prerequisites?: true
    repeatable?: true
    fighterBonus?: true
  }

  export type FeatMaxAggregateInputType = {
    id?: true
    name?: true
    typeId?: true
    description?: true
    benefit?: true
    normalEffect?: true
    specialEffect?: true
    prerequisites?: true
    repeatable?: true
    fighterBonus?: true
  }

  export type FeatCountAggregateInputType = {
    id?: true
    name?: true
    typeId?: true
    description?: true
    benefit?: true
    normalEffect?: true
    specialEffect?: true
    prerequisites?: true
    repeatable?: true
    fighterBonus?: true
    _all?: true
  }

  export type FeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feat to aggregate.
     */
    where?: FeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feats to fetch.
     */
    orderBy?: FeatOrderByWithRelationInput | FeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feats
    **/
    _count?: true | FeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatMaxAggregateInputType
  }

  export type GetFeatAggregateType<T extends FeatAggregateArgs> = {
        [P in keyof T & keyof AggregateFeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeat[P]>
      : GetScalarType<T[P], AggregateFeat[P]>
  }




  export type FeatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatWhereInput
    orderBy?: FeatOrderByWithAggregationInput | FeatOrderByWithAggregationInput[]
    by: FeatScalarFieldEnum[] | FeatScalarFieldEnum
    having?: FeatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatCountAggregateInputType | true
    _avg?: FeatAvgAggregateInputType
    _sum?: FeatSumAggregateInputType
    _min?: FeatMinAggregateInputType
    _max?: FeatMaxAggregateInputType
  }

  export type FeatGroupByOutputType = {
    id: number
    name: string
    typeId: number
    description: string | null
    benefit: string | null
    normalEffect: string | null
    specialEffect: string | null
    prerequisites: string | null
    repeatable: boolean | null
    fighterBonus: boolean | null
    _count: FeatCountAggregateOutputType | null
    _avg: FeatAvgAggregateOutputType | null
    _sum: FeatSumAggregateOutputType | null
    _min: FeatMinAggregateOutputType | null
    _max: FeatMaxAggregateOutputType | null
  }

  type GetFeatGroupByPayload<T extends FeatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatGroupByOutputType[P]>
            : GetScalarType<T[P], FeatGroupByOutputType[P]>
        }
      >
    >


  export type FeatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    typeId?: boolean
    description?: boolean
    benefit?: boolean
    normalEffect?: boolean
    specialEffect?: boolean
    prerequisites?: boolean
    repeatable?: boolean
    fighterBonus?: boolean
    benefits?: boolean | Feat$benefitsArgs<ExtArgs>
    prerequisitesMap?: boolean | Feat$prerequisitesMapArgs<ExtArgs>
    _count?: boolean | FeatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feat"]>



  export type FeatSelectScalar = {
    id?: boolean
    name?: boolean
    typeId?: boolean
    description?: boolean
    benefit?: boolean
    normalEffect?: boolean
    specialEffect?: boolean
    prerequisites?: boolean
    repeatable?: boolean
    fighterBonus?: boolean
  }

  export type FeatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "typeId" | "description" | "benefit" | "normalEffect" | "specialEffect" | "prerequisites" | "repeatable" | "fighterBonus", ExtArgs["result"]["feat"]>
  export type FeatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benefits?: boolean | Feat$benefitsArgs<ExtArgs>
    prerequisitesMap?: boolean | Feat$prerequisitesMapArgs<ExtArgs>
    _count?: boolean | FeatCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FeatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feat"
    objects: {
      benefits: Prisma.$FeatBenefitMapPayload<ExtArgs>[]
      prerequisitesMap: Prisma.$FeatPrerequisiteMapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      typeId: number
      description: string | null
      benefit: string | null
      normalEffect: string | null
      specialEffect: string | null
      prerequisites: string | null
      repeatable: boolean | null
      fighterBonus: boolean | null
    }, ExtArgs["result"]["feat"]>
    composites: {}
  }

  type FeatGetPayload<S extends boolean | null | undefined | FeatDefaultArgs> = $Result.GetResult<Prisma.$FeatPayload, S>

  type FeatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatCountAggregateInputType | true
    }

  export interface FeatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feat'], meta: { name: 'Feat' } }
    /**
     * Find zero or one Feat that matches the filter.
     * @param {FeatFindUniqueArgs} args - Arguments to find a Feat
     * @example
     * // Get one Feat
     * const feat = await prisma.feat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatFindUniqueArgs>(args: SelectSubset<T, FeatFindUniqueArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatFindUniqueOrThrowArgs} args - Arguments to find a Feat
     * @example
     * // Get one Feat
     * const feat = await prisma.feat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFindFirstArgs} args - Arguments to find a Feat
     * @example
     * // Get one Feat
     * const feat = await prisma.feat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatFindFirstArgs>(args?: SelectSubset<T, FeatFindFirstArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFindFirstOrThrowArgs} args - Arguments to find a Feat
     * @example
     * // Get one Feat
     * const feat = await prisma.feat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feats
     * const feats = await prisma.feat.findMany()
     * 
     * // Get first 10 Feats
     * const feats = await prisma.feat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featWithIdOnly = await prisma.feat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatFindManyArgs>(args?: SelectSubset<T, FeatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feat.
     * @param {FeatCreateArgs} args - Arguments to create a Feat.
     * @example
     * // Create one Feat
     * const Feat = await prisma.feat.create({
     *   data: {
     *     // ... data to create a Feat
     *   }
     * })
     * 
     */
    create<T extends FeatCreateArgs>(args: SelectSubset<T, FeatCreateArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feats.
     * @param {FeatCreateManyArgs} args - Arguments to create many Feats.
     * @example
     * // Create many Feats
     * const feat = await prisma.feat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatCreateManyArgs>(args?: SelectSubset<T, FeatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feat.
     * @param {FeatDeleteArgs} args - Arguments to delete one Feat.
     * @example
     * // Delete one Feat
     * const Feat = await prisma.feat.delete({
     *   where: {
     *     // ... filter to delete one Feat
     *   }
     * })
     * 
     */
    delete<T extends FeatDeleteArgs>(args: SelectSubset<T, FeatDeleteArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feat.
     * @param {FeatUpdateArgs} args - Arguments to update one Feat.
     * @example
     * // Update one Feat
     * const feat = await prisma.feat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatUpdateArgs>(args: SelectSubset<T, FeatUpdateArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feats.
     * @param {FeatDeleteManyArgs} args - Arguments to filter Feats to delete.
     * @example
     * // Delete a few Feats
     * const { count } = await prisma.feat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatDeleteManyArgs>(args?: SelectSubset<T, FeatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feats
     * const feat = await prisma.feat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatUpdateManyArgs>(args: SelectSubset<T, FeatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feat.
     * @param {FeatUpsertArgs} args - Arguments to update or create a Feat.
     * @example
     * // Update or create a Feat
     * const feat = await prisma.feat.upsert({
     *   create: {
     *     // ... data to create a Feat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feat we want to update
     *   }
     * })
     */
    upsert<T extends FeatUpsertArgs>(args: SelectSubset<T, FeatUpsertArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatCountArgs} args - Arguments to filter Feats to count.
     * @example
     * // Count the number of Feats
     * const count = await prisma.feat.count({
     *   where: {
     *     // ... the filter for the Feats we want to count
     *   }
     * })
    **/
    count<T extends FeatCountArgs>(
      args?: Subset<T, FeatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatAggregateArgs>(args: Subset<T, FeatAggregateArgs>): Prisma.PrismaPromise<GetFeatAggregateType<T>>

    /**
     * Group by Feat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatGroupByArgs['orderBy'] }
        : { orderBy?: FeatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feat model
   */
  readonly fields: FeatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    benefits<T extends Feat$benefitsArgs<ExtArgs> = {}>(args?: Subset<T, Feat$benefitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatBenefitMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prerequisitesMap<T extends Feat$prerequisitesMapArgs<ExtArgs> = {}>(args?: Subset<T, Feat$prerequisitesMapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatPrerequisiteMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feat model
   */
  interface FeatFieldRefs {
    readonly id: FieldRef<"Feat", 'Int'>
    readonly name: FieldRef<"Feat", 'String'>
    readonly typeId: FieldRef<"Feat", 'Int'>
    readonly description: FieldRef<"Feat", 'String'>
    readonly benefit: FieldRef<"Feat", 'String'>
    readonly normalEffect: FieldRef<"Feat", 'String'>
    readonly specialEffect: FieldRef<"Feat", 'String'>
    readonly prerequisites: FieldRef<"Feat", 'String'>
    readonly repeatable: FieldRef<"Feat", 'Boolean'>
    readonly fighterBonus: FieldRef<"Feat", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Feat findUnique
   */
  export type FeatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter, which Feat to fetch.
     */
    where: FeatWhereUniqueInput
  }

  /**
   * Feat findUniqueOrThrow
   */
  export type FeatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter, which Feat to fetch.
     */
    where: FeatWhereUniqueInput
  }

  /**
   * Feat findFirst
   */
  export type FeatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter, which Feat to fetch.
     */
    where?: FeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feats to fetch.
     */
    orderBy?: FeatOrderByWithRelationInput | FeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feats.
     */
    cursor?: FeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feats.
     */
    distinct?: FeatScalarFieldEnum | FeatScalarFieldEnum[]
  }

  /**
   * Feat findFirstOrThrow
   */
  export type FeatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter, which Feat to fetch.
     */
    where?: FeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feats to fetch.
     */
    orderBy?: FeatOrderByWithRelationInput | FeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feats.
     */
    cursor?: FeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feats.
     */
    distinct?: FeatScalarFieldEnum | FeatScalarFieldEnum[]
  }

  /**
   * Feat findMany
   */
  export type FeatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter, which Feats to fetch.
     */
    where?: FeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feats to fetch.
     */
    orderBy?: FeatOrderByWithRelationInput | FeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feats.
     */
    cursor?: FeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feats.
     */
    skip?: number
    distinct?: FeatScalarFieldEnum | FeatScalarFieldEnum[]
  }

  /**
   * Feat create
   */
  export type FeatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * The data needed to create a Feat.
     */
    data: XOR<FeatCreateInput, FeatUncheckedCreateInput>
  }

  /**
   * Feat createMany
   */
  export type FeatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feats.
     */
    data: FeatCreateManyInput | FeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feat update
   */
  export type FeatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * The data needed to update a Feat.
     */
    data: XOR<FeatUpdateInput, FeatUncheckedUpdateInput>
    /**
     * Choose, which Feat to update.
     */
    where: FeatWhereUniqueInput
  }

  /**
   * Feat updateMany
   */
  export type FeatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feats.
     */
    data: XOR<FeatUpdateManyMutationInput, FeatUncheckedUpdateManyInput>
    /**
     * Filter which Feats to update
     */
    where?: FeatWhereInput
    /**
     * Limit how many Feats to update.
     */
    limit?: number
  }

  /**
   * Feat upsert
   */
  export type FeatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * The filter to search for the Feat to update in case it exists.
     */
    where: FeatWhereUniqueInput
    /**
     * In case the Feat found by the `where` argument doesn't exist, create a new Feat with this data.
     */
    create: XOR<FeatCreateInput, FeatUncheckedCreateInput>
    /**
     * In case the Feat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatUpdateInput, FeatUncheckedUpdateInput>
  }

  /**
   * Feat delete
   */
  export type FeatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter which Feat to delete.
     */
    where: FeatWhereUniqueInput
  }

  /**
   * Feat deleteMany
   */
  export type FeatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feats to delete
     */
    where?: FeatWhereInput
    /**
     * Limit how many Feats to delete.
     */
    limit?: number
  }

  /**
   * Feat.benefits
   */
  export type Feat$benefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatBenefitMap
     */
    select?: FeatBenefitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatBenefitMap
     */
    omit?: FeatBenefitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatBenefitMapInclude<ExtArgs> | null
    where?: FeatBenefitMapWhereInput
    orderBy?: FeatBenefitMapOrderByWithRelationInput | FeatBenefitMapOrderByWithRelationInput[]
    cursor?: FeatBenefitMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatBenefitMapScalarFieldEnum | FeatBenefitMapScalarFieldEnum[]
  }

  /**
   * Feat.prerequisitesMap
   */
  export type Feat$prerequisitesMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatPrerequisiteMap
     */
    select?: FeatPrerequisiteMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatPrerequisiteMap
     */
    omit?: FeatPrerequisiteMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatPrerequisiteMapInclude<ExtArgs> | null
    where?: FeatPrerequisiteMapWhereInput
    orderBy?: FeatPrerequisiteMapOrderByWithRelationInput | FeatPrerequisiteMapOrderByWithRelationInput[]
    cursor?: FeatPrerequisiteMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatPrerequisiteMapScalarFieldEnum | FeatPrerequisiteMapScalarFieldEnum[]
  }

  /**
   * Feat without action
   */
  export type FeatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
  }


  /**
   * Model FeatBenefitMap
   */

  export type AggregateFeatBenefitMap = {
    _count: FeatBenefitMapCountAggregateOutputType | null
    _avg: FeatBenefitMapAvgAggregateOutputType | null
    _sum: FeatBenefitMapSumAggregateOutputType | null
    _min: FeatBenefitMapMinAggregateOutputType | null
    _max: FeatBenefitMapMaxAggregateOutputType | null
  }

  export type FeatBenefitMapAvgAggregateOutputType = {
    featId: number | null
    typeId: number | null
    referenceId: number | null
    amount: number | null
    index: number | null
  }

  export type FeatBenefitMapSumAggregateOutputType = {
    featId: number | null
    typeId: number | null
    referenceId: number | null
    amount: number | null
    index: number | null
  }

  export type FeatBenefitMapMinAggregateOutputType = {
    featId: number | null
    typeId: number | null
    referenceId: number | null
    amount: number | null
    index: number | null
  }

  export type FeatBenefitMapMaxAggregateOutputType = {
    featId: number | null
    typeId: number | null
    referenceId: number | null
    amount: number | null
    index: number | null
  }

  export type FeatBenefitMapCountAggregateOutputType = {
    featId: number
    typeId: number
    referenceId: number
    amount: number
    index: number
    _all: number
  }


  export type FeatBenefitMapAvgAggregateInputType = {
    featId?: true
    typeId?: true
    referenceId?: true
    amount?: true
    index?: true
  }

  export type FeatBenefitMapSumAggregateInputType = {
    featId?: true
    typeId?: true
    referenceId?: true
    amount?: true
    index?: true
  }

  export type FeatBenefitMapMinAggregateInputType = {
    featId?: true
    typeId?: true
    referenceId?: true
    amount?: true
    index?: true
  }

  export type FeatBenefitMapMaxAggregateInputType = {
    featId?: true
    typeId?: true
    referenceId?: true
    amount?: true
    index?: true
  }

  export type FeatBenefitMapCountAggregateInputType = {
    featId?: true
    typeId?: true
    referenceId?: true
    amount?: true
    index?: true
    _all?: true
  }

  export type FeatBenefitMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatBenefitMap to aggregate.
     */
    where?: FeatBenefitMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatBenefitMaps to fetch.
     */
    orderBy?: FeatBenefitMapOrderByWithRelationInput | FeatBenefitMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatBenefitMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatBenefitMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatBenefitMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatBenefitMaps
    **/
    _count?: true | FeatBenefitMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatBenefitMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatBenefitMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatBenefitMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatBenefitMapMaxAggregateInputType
  }

  export type GetFeatBenefitMapAggregateType<T extends FeatBenefitMapAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatBenefitMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatBenefitMap[P]>
      : GetScalarType<T[P], AggregateFeatBenefitMap[P]>
  }




  export type FeatBenefitMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatBenefitMapWhereInput
    orderBy?: FeatBenefitMapOrderByWithAggregationInput | FeatBenefitMapOrderByWithAggregationInput[]
    by: FeatBenefitMapScalarFieldEnum[] | FeatBenefitMapScalarFieldEnum
    having?: FeatBenefitMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatBenefitMapCountAggregateInputType | true
    _avg?: FeatBenefitMapAvgAggregateInputType
    _sum?: FeatBenefitMapSumAggregateInputType
    _min?: FeatBenefitMapMinAggregateInputType
    _max?: FeatBenefitMapMaxAggregateInputType
  }

  export type FeatBenefitMapGroupByOutputType = {
    featId: number
    typeId: number
    referenceId: number | null
    amount: number | null
    index: number
    _count: FeatBenefitMapCountAggregateOutputType | null
    _avg: FeatBenefitMapAvgAggregateOutputType | null
    _sum: FeatBenefitMapSumAggregateOutputType | null
    _min: FeatBenefitMapMinAggregateOutputType | null
    _max: FeatBenefitMapMaxAggregateOutputType | null
  }

  type GetFeatBenefitMapGroupByPayload<T extends FeatBenefitMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatBenefitMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatBenefitMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatBenefitMapGroupByOutputType[P]>
            : GetScalarType<T[P], FeatBenefitMapGroupByOutputType[P]>
        }
      >
    >


  export type FeatBenefitMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featId?: boolean
    typeId?: boolean
    referenceId?: boolean
    amount?: boolean
    index?: boolean
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featBenefitMap"]>



  export type FeatBenefitMapSelectScalar = {
    featId?: boolean
    typeId?: boolean
    referenceId?: boolean
    amount?: boolean
    index?: boolean
  }

  export type FeatBenefitMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"featId" | "typeId" | "referenceId" | "amount" | "index", ExtArgs["result"]["featBenefitMap"]>
  export type FeatBenefitMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }

  export type $FeatBenefitMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatBenefitMap"
    objects: {
      feat: Prisma.$FeatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      featId: number
      typeId: number
      referenceId: number | null
      amount: number | null
      index: number
    }, ExtArgs["result"]["featBenefitMap"]>
    composites: {}
  }

  type FeatBenefitMapGetPayload<S extends boolean | null | undefined | FeatBenefitMapDefaultArgs> = $Result.GetResult<Prisma.$FeatBenefitMapPayload, S>

  type FeatBenefitMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatBenefitMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatBenefitMapCountAggregateInputType | true
    }

  export interface FeatBenefitMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatBenefitMap'], meta: { name: 'FeatBenefitMap' } }
    /**
     * Find zero or one FeatBenefitMap that matches the filter.
     * @param {FeatBenefitMapFindUniqueArgs} args - Arguments to find a FeatBenefitMap
     * @example
     * // Get one FeatBenefitMap
     * const featBenefitMap = await prisma.featBenefitMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatBenefitMapFindUniqueArgs>(args: SelectSubset<T, FeatBenefitMapFindUniqueArgs<ExtArgs>>): Prisma__FeatBenefitMapClient<$Result.GetResult<Prisma.$FeatBenefitMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatBenefitMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatBenefitMapFindUniqueOrThrowArgs} args - Arguments to find a FeatBenefitMap
     * @example
     * // Get one FeatBenefitMap
     * const featBenefitMap = await prisma.featBenefitMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatBenefitMapFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatBenefitMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatBenefitMapClient<$Result.GetResult<Prisma.$FeatBenefitMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatBenefitMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatBenefitMapFindFirstArgs} args - Arguments to find a FeatBenefitMap
     * @example
     * // Get one FeatBenefitMap
     * const featBenefitMap = await prisma.featBenefitMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatBenefitMapFindFirstArgs>(args?: SelectSubset<T, FeatBenefitMapFindFirstArgs<ExtArgs>>): Prisma__FeatBenefitMapClient<$Result.GetResult<Prisma.$FeatBenefitMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatBenefitMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatBenefitMapFindFirstOrThrowArgs} args - Arguments to find a FeatBenefitMap
     * @example
     * // Get one FeatBenefitMap
     * const featBenefitMap = await prisma.featBenefitMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatBenefitMapFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatBenefitMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatBenefitMapClient<$Result.GetResult<Prisma.$FeatBenefitMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatBenefitMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatBenefitMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatBenefitMaps
     * const featBenefitMaps = await prisma.featBenefitMap.findMany()
     * 
     * // Get first 10 FeatBenefitMaps
     * const featBenefitMaps = await prisma.featBenefitMap.findMany({ take: 10 })
     * 
     * // Only select the `featId`
     * const featBenefitMapWithFeatIdOnly = await prisma.featBenefitMap.findMany({ select: { featId: true } })
     * 
     */
    findMany<T extends FeatBenefitMapFindManyArgs>(args?: SelectSubset<T, FeatBenefitMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatBenefitMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatBenefitMap.
     * @param {FeatBenefitMapCreateArgs} args - Arguments to create a FeatBenefitMap.
     * @example
     * // Create one FeatBenefitMap
     * const FeatBenefitMap = await prisma.featBenefitMap.create({
     *   data: {
     *     // ... data to create a FeatBenefitMap
     *   }
     * })
     * 
     */
    create<T extends FeatBenefitMapCreateArgs>(args: SelectSubset<T, FeatBenefitMapCreateArgs<ExtArgs>>): Prisma__FeatBenefitMapClient<$Result.GetResult<Prisma.$FeatBenefitMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatBenefitMaps.
     * @param {FeatBenefitMapCreateManyArgs} args - Arguments to create many FeatBenefitMaps.
     * @example
     * // Create many FeatBenefitMaps
     * const featBenefitMap = await prisma.featBenefitMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatBenefitMapCreateManyArgs>(args?: SelectSubset<T, FeatBenefitMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeatBenefitMap.
     * @param {FeatBenefitMapDeleteArgs} args - Arguments to delete one FeatBenefitMap.
     * @example
     * // Delete one FeatBenefitMap
     * const FeatBenefitMap = await prisma.featBenefitMap.delete({
     *   where: {
     *     // ... filter to delete one FeatBenefitMap
     *   }
     * })
     * 
     */
    delete<T extends FeatBenefitMapDeleteArgs>(args: SelectSubset<T, FeatBenefitMapDeleteArgs<ExtArgs>>): Prisma__FeatBenefitMapClient<$Result.GetResult<Prisma.$FeatBenefitMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatBenefitMap.
     * @param {FeatBenefitMapUpdateArgs} args - Arguments to update one FeatBenefitMap.
     * @example
     * // Update one FeatBenefitMap
     * const featBenefitMap = await prisma.featBenefitMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatBenefitMapUpdateArgs>(args: SelectSubset<T, FeatBenefitMapUpdateArgs<ExtArgs>>): Prisma__FeatBenefitMapClient<$Result.GetResult<Prisma.$FeatBenefitMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatBenefitMaps.
     * @param {FeatBenefitMapDeleteManyArgs} args - Arguments to filter FeatBenefitMaps to delete.
     * @example
     * // Delete a few FeatBenefitMaps
     * const { count } = await prisma.featBenefitMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatBenefitMapDeleteManyArgs>(args?: SelectSubset<T, FeatBenefitMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatBenefitMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatBenefitMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatBenefitMaps
     * const featBenefitMap = await prisma.featBenefitMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatBenefitMapUpdateManyArgs>(args: SelectSubset<T, FeatBenefitMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeatBenefitMap.
     * @param {FeatBenefitMapUpsertArgs} args - Arguments to update or create a FeatBenefitMap.
     * @example
     * // Update or create a FeatBenefitMap
     * const featBenefitMap = await prisma.featBenefitMap.upsert({
     *   create: {
     *     // ... data to create a FeatBenefitMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatBenefitMap we want to update
     *   }
     * })
     */
    upsert<T extends FeatBenefitMapUpsertArgs>(args: SelectSubset<T, FeatBenefitMapUpsertArgs<ExtArgs>>): Prisma__FeatBenefitMapClient<$Result.GetResult<Prisma.$FeatBenefitMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatBenefitMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatBenefitMapCountArgs} args - Arguments to filter FeatBenefitMaps to count.
     * @example
     * // Count the number of FeatBenefitMaps
     * const count = await prisma.featBenefitMap.count({
     *   where: {
     *     // ... the filter for the FeatBenefitMaps we want to count
     *   }
     * })
    **/
    count<T extends FeatBenefitMapCountArgs>(
      args?: Subset<T, FeatBenefitMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatBenefitMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatBenefitMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatBenefitMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatBenefitMapAggregateArgs>(args: Subset<T, FeatBenefitMapAggregateArgs>): Prisma.PrismaPromise<GetFeatBenefitMapAggregateType<T>>

    /**
     * Group by FeatBenefitMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatBenefitMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatBenefitMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatBenefitMapGroupByArgs['orderBy'] }
        : { orderBy?: FeatBenefitMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatBenefitMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatBenefitMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatBenefitMap model
   */
  readonly fields: FeatBenefitMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatBenefitMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatBenefitMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feat<T extends FeatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatDefaultArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatBenefitMap model
   */
  interface FeatBenefitMapFieldRefs {
    readonly featId: FieldRef<"FeatBenefitMap", 'Int'>
    readonly typeId: FieldRef<"FeatBenefitMap", 'Int'>
    readonly referenceId: FieldRef<"FeatBenefitMap", 'Int'>
    readonly amount: FieldRef<"FeatBenefitMap", 'Int'>
    readonly index: FieldRef<"FeatBenefitMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FeatBenefitMap findUnique
   */
  export type FeatBenefitMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatBenefitMap
     */
    select?: FeatBenefitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatBenefitMap
     */
    omit?: FeatBenefitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatBenefitMapInclude<ExtArgs> | null
    /**
     * Filter, which FeatBenefitMap to fetch.
     */
    where: FeatBenefitMapWhereUniqueInput
  }

  /**
   * FeatBenefitMap findUniqueOrThrow
   */
  export type FeatBenefitMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatBenefitMap
     */
    select?: FeatBenefitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatBenefitMap
     */
    omit?: FeatBenefitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatBenefitMapInclude<ExtArgs> | null
    /**
     * Filter, which FeatBenefitMap to fetch.
     */
    where: FeatBenefitMapWhereUniqueInput
  }

  /**
   * FeatBenefitMap findFirst
   */
  export type FeatBenefitMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatBenefitMap
     */
    select?: FeatBenefitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatBenefitMap
     */
    omit?: FeatBenefitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatBenefitMapInclude<ExtArgs> | null
    /**
     * Filter, which FeatBenefitMap to fetch.
     */
    where?: FeatBenefitMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatBenefitMaps to fetch.
     */
    orderBy?: FeatBenefitMapOrderByWithRelationInput | FeatBenefitMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatBenefitMaps.
     */
    cursor?: FeatBenefitMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatBenefitMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatBenefitMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatBenefitMaps.
     */
    distinct?: FeatBenefitMapScalarFieldEnum | FeatBenefitMapScalarFieldEnum[]
  }

  /**
   * FeatBenefitMap findFirstOrThrow
   */
  export type FeatBenefitMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatBenefitMap
     */
    select?: FeatBenefitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatBenefitMap
     */
    omit?: FeatBenefitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatBenefitMapInclude<ExtArgs> | null
    /**
     * Filter, which FeatBenefitMap to fetch.
     */
    where?: FeatBenefitMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatBenefitMaps to fetch.
     */
    orderBy?: FeatBenefitMapOrderByWithRelationInput | FeatBenefitMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatBenefitMaps.
     */
    cursor?: FeatBenefitMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatBenefitMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatBenefitMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatBenefitMaps.
     */
    distinct?: FeatBenefitMapScalarFieldEnum | FeatBenefitMapScalarFieldEnum[]
  }

  /**
   * FeatBenefitMap findMany
   */
  export type FeatBenefitMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatBenefitMap
     */
    select?: FeatBenefitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatBenefitMap
     */
    omit?: FeatBenefitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatBenefitMapInclude<ExtArgs> | null
    /**
     * Filter, which FeatBenefitMaps to fetch.
     */
    where?: FeatBenefitMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatBenefitMaps to fetch.
     */
    orderBy?: FeatBenefitMapOrderByWithRelationInput | FeatBenefitMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatBenefitMaps.
     */
    cursor?: FeatBenefitMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatBenefitMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatBenefitMaps.
     */
    skip?: number
    distinct?: FeatBenefitMapScalarFieldEnum | FeatBenefitMapScalarFieldEnum[]
  }

  /**
   * FeatBenefitMap create
   */
  export type FeatBenefitMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatBenefitMap
     */
    select?: FeatBenefitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatBenefitMap
     */
    omit?: FeatBenefitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatBenefitMapInclude<ExtArgs> | null
    /**
     * The data needed to create a FeatBenefitMap.
     */
    data: XOR<FeatBenefitMapCreateInput, FeatBenefitMapUncheckedCreateInput>
  }

  /**
   * FeatBenefitMap createMany
   */
  export type FeatBenefitMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatBenefitMaps.
     */
    data: FeatBenefitMapCreateManyInput | FeatBenefitMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatBenefitMap update
   */
  export type FeatBenefitMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatBenefitMap
     */
    select?: FeatBenefitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatBenefitMap
     */
    omit?: FeatBenefitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatBenefitMapInclude<ExtArgs> | null
    /**
     * The data needed to update a FeatBenefitMap.
     */
    data: XOR<FeatBenefitMapUpdateInput, FeatBenefitMapUncheckedUpdateInput>
    /**
     * Choose, which FeatBenefitMap to update.
     */
    where: FeatBenefitMapWhereUniqueInput
  }

  /**
   * FeatBenefitMap updateMany
   */
  export type FeatBenefitMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatBenefitMaps.
     */
    data: XOR<FeatBenefitMapUpdateManyMutationInput, FeatBenefitMapUncheckedUpdateManyInput>
    /**
     * Filter which FeatBenefitMaps to update
     */
    where?: FeatBenefitMapWhereInput
    /**
     * Limit how many FeatBenefitMaps to update.
     */
    limit?: number
  }

  /**
   * FeatBenefitMap upsert
   */
  export type FeatBenefitMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatBenefitMap
     */
    select?: FeatBenefitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatBenefitMap
     */
    omit?: FeatBenefitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatBenefitMapInclude<ExtArgs> | null
    /**
     * The filter to search for the FeatBenefitMap to update in case it exists.
     */
    where: FeatBenefitMapWhereUniqueInput
    /**
     * In case the FeatBenefitMap found by the `where` argument doesn't exist, create a new FeatBenefitMap with this data.
     */
    create: XOR<FeatBenefitMapCreateInput, FeatBenefitMapUncheckedCreateInput>
    /**
     * In case the FeatBenefitMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatBenefitMapUpdateInput, FeatBenefitMapUncheckedUpdateInput>
  }

  /**
   * FeatBenefitMap delete
   */
  export type FeatBenefitMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatBenefitMap
     */
    select?: FeatBenefitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatBenefitMap
     */
    omit?: FeatBenefitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatBenefitMapInclude<ExtArgs> | null
    /**
     * Filter which FeatBenefitMap to delete.
     */
    where: FeatBenefitMapWhereUniqueInput
  }

  /**
   * FeatBenefitMap deleteMany
   */
  export type FeatBenefitMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatBenefitMaps to delete
     */
    where?: FeatBenefitMapWhereInput
    /**
     * Limit how many FeatBenefitMaps to delete.
     */
    limit?: number
  }

  /**
   * FeatBenefitMap without action
   */
  export type FeatBenefitMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatBenefitMap
     */
    select?: FeatBenefitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatBenefitMap
     */
    omit?: FeatBenefitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatBenefitMapInclude<ExtArgs> | null
  }


  /**
   * Model FeatPrerequisiteMap
   */

  export type AggregateFeatPrerequisiteMap = {
    _count: FeatPrerequisiteMapCountAggregateOutputType | null
    _avg: FeatPrerequisiteMapAvgAggregateOutputType | null
    _sum: FeatPrerequisiteMapSumAggregateOutputType | null
    _min: FeatPrerequisiteMapMinAggregateOutputType | null
    _max: FeatPrerequisiteMapMaxAggregateOutputType | null
  }

  export type FeatPrerequisiteMapAvgAggregateOutputType = {
    featId: number | null
    typeId: number | null
    referenceId: number | null
    amount: number | null
    index: number | null
  }

  export type FeatPrerequisiteMapSumAggregateOutputType = {
    featId: number | null
    typeId: number | null
    referenceId: number | null
    amount: number | null
    index: number | null
  }

  export type FeatPrerequisiteMapMinAggregateOutputType = {
    featId: number | null
    typeId: number | null
    referenceId: number | null
    amount: number | null
    index: number | null
  }

  export type FeatPrerequisiteMapMaxAggregateOutputType = {
    featId: number | null
    typeId: number | null
    referenceId: number | null
    amount: number | null
    index: number | null
  }

  export type FeatPrerequisiteMapCountAggregateOutputType = {
    featId: number
    typeId: number
    referenceId: number
    amount: number
    index: number
    _all: number
  }


  export type FeatPrerequisiteMapAvgAggregateInputType = {
    featId?: true
    typeId?: true
    referenceId?: true
    amount?: true
    index?: true
  }

  export type FeatPrerequisiteMapSumAggregateInputType = {
    featId?: true
    typeId?: true
    referenceId?: true
    amount?: true
    index?: true
  }

  export type FeatPrerequisiteMapMinAggregateInputType = {
    featId?: true
    typeId?: true
    referenceId?: true
    amount?: true
    index?: true
  }

  export type FeatPrerequisiteMapMaxAggregateInputType = {
    featId?: true
    typeId?: true
    referenceId?: true
    amount?: true
    index?: true
  }

  export type FeatPrerequisiteMapCountAggregateInputType = {
    featId?: true
    typeId?: true
    referenceId?: true
    amount?: true
    index?: true
    _all?: true
  }

  export type FeatPrerequisiteMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatPrerequisiteMap to aggregate.
     */
    where?: FeatPrerequisiteMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatPrerequisiteMaps to fetch.
     */
    orderBy?: FeatPrerequisiteMapOrderByWithRelationInput | FeatPrerequisiteMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatPrerequisiteMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatPrerequisiteMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatPrerequisiteMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatPrerequisiteMaps
    **/
    _count?: true | FeatPrerequisiteMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatPrerequisiteMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatPrerequisiteMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatPrerequisiteMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatPrerequisiteMapMaxAggregateInputType
  }

  export type GetFeatPrerequisiteMapAggregateType<T extends FeatPrerequisiteMapAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatPrerequisiteMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatPrerequisiteMap[P]>
      : GetScalarType<T[P], AggregateFeatPrerequisiteMap[P]>
  }




  export type FeatPrerequisiteMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatPrerequisiteMapWhereInput
    orderBy?: FeatPrerequisiteMapOrderByWithAggregationInput | FeatPrerequisiteMapOrderByWithAggregationInput[]
    by: FeatPrerequisiteMapScalarFieldEnum[] | FeatPrerequisiteMapScalarFieldEnum
    having?: FeatPrerequisiteMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatPrerequisiteMapCountAggregateInputType | true
    _avg?: FeatPrerequisiteMapAvgAggregateInputType
    _sum?: FeatPrerequisiteMapSumAggregateInputType
    _min?: FeatPrerequisiteMapMinAggregateInputType
    _max?: FeatPrerequisiteMapMaxAggregateInputType
  }

  export type FeatPrerequisiteMapGroupByOutputType = {
    featId: number
    typeId: number
    referenceId: number | null
    amount: number | null
    index: number
    _count: FeatPrerequisiteMapCountAggregateOutputType | null
    _avg: FeatPrerequisiteMapAvgAggregateOutputType | null
    _sum: FeatPrerequisiteMapSumAggregateOutputType | null
    _min: FeatPrerequisiteMapMinAggregateOutputType | null
    _max: FeatPrerequisiteMapMaxAggregateOutputType | null
  }

  type GetFeatPrerequisiteMapGroupByPayload<T extends FeatPrerequisiteMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatPrerequisiteMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatPrerequisiteMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatPrerequisiteMapGroupByOutputType[P]>
            : GetScalarType<T[P], FeatPrerequisiteMapGroupByOutputType[P]>
        }
      >
    >


  export type FeatPrerequisiteMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featId?: boolean
    typeId?: boolean
    referenceId?: boolean
    amount?: boolean
    index?: boolean
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featPrerequisiteMap"]>



  export type FeatPrerequisiteMapSelectScalar = {
    featId?: boolean
    typeId?: boolean
    referenceId?: boolean
    amount?: boolean
    index?: boolean
  }

  export type FeatPrerequisiteMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"featId" | "typeId" | "referenceId" | "amount" | "index", ExtArgs["result"]["featPrerequisiteMap"]>
  export type FeatPrerequisiteMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }

  export type $FeatPrerequisiteMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatPrerequisiteMap"
    objects: {
      feat: Prisma.$FeatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      featId: number
      typeId: number
      referenceId: number | null
      amount: number | null
      index: number
    }, ExtArgs["result"]["featPrerequisiteMap"]>
    composites: {}
  }

  type FeatPrerequisiteMapGetPayload<S extends boolean | null | undefined | FeatPrerequisiteMapDefaultArgs> = $Result.GetResult<Prisma.$FeatPrerequisiteMapPayload, S>

  type FeatPrerequisiteMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatPrerequisiteMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatPrerequisiteMapCountAggregateInputType | true
    }

  export interface FeatPrerequisiteMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatPrerequisiteMap'], meta: { name: 'FeatPrerequisiteMap' } }
    /**
     * Find zero or one FeatPrerequisiteMap that matches the filter.
     * @param {FeatPrerequisiteMapFindUniqueArgs} args - Arguments to find a FeatPrerequisiteMap
     * @example
     * // Get one FeatPrerequisiteMap
     * const featPrerequisiteMap = await prisma.featPrerequisiteMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatPrerequisiteMapFindUniqueArgs>(args: SelectSubset<T, FeatPrerequisiteMapFindUniqueArgs<ExtArgs>>): Prisma__FeatPrerequisiteMapClient<$Result.GetResult<Prisma.$FeatPrerequisiteMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatPrerequisiteMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatPrerequisiteMapFindUniqueOrThrowArgs} args - Arguments to find a FeatPrerequisiteMap
     * @example
     * // Get one FeatPrerequisiteMap
     * const featPrerequisiteMap = await prisma.featPrerequisiteMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatPrerequisiteMapFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatPrerequisiteMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatPrerequisiteMapClient<$Result.GetResult<Prisma.$FeatPrerequisiteMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatPrerequisiteMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatPrerequisiteMapFindFirstArgs} args - Arguments to find a FeatPrerequisiteMap
     * @example
     * // Get one FeatPrerequisiteMap
     * const featPrerequisiteMap = await prisma.featPrerequisiteMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatPrerequisiteMapFindFirstArgs>(args?: SelectSubset<T, FeatPrerequisiteMapFindFirstArgs<ExtArgs>>): Prisma__FeatPrerequisiteMapClient<$Result.GetResult<Prisma.$FeatPrerequisiteMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatPrerequisiteMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatPrerequisiteMapFindFirstOrThrowArgs} args - Arguments to find a FeatPrerequisiteMap
     * @example
     * // Get one FeatPrerequisiteMap
     * const featPrerequisiteMap = await prisma.featPrerequisiteMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatPrerequisiteMapFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatPrerequisiteMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatPrerequisiteMapClient<$Result.GetResult<Prisma.$FeatPrerequisiteMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatPrerequisiteMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatPrerequisiteMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatPrerequisiteMaps
     * const featPrerequisiteMaps = await prisma.featPrerequisiteMap.findMany()
     * 
     * // Get first 10 FeatPrerequisiteMaps
     * const featPrerequisiteMaps = await prisma.featPrerequisiteMap.findMany({ take: 10 })
     * 
     * // Only select the `featId`
     * const featPrerequisiteMapWithFeatIdOnly = await prisma.featPrerequisiteMap.findMany({ select: { featId: true } })
     * 
     */
    findMany<T extends FeatPrerequisiteMapFindManyArgs>(args?: SelectSubset<T, FeatPrerequisiteMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatPrerequisiteMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatPrerequisiteMap.
     * @param {FeatPrerequisiteMapCreateArgs} args - Arguments to create a FeatPrerequisiteMap.
     * @example
     * // Create one FeatPrerequisiteMap
     * const FeatPrerequisiteMap = await prisma.featPrerequisiteMap.create({
     *   data: {
     *     // ... data to create a FeatPrerequisiteMap
     *   }
     * })
     * 
     */
    create<T extends FeatPrerequisiteMapCreateArgs>(args: SelectSubset<T, FeatPrerequisiteMapCreateArgs<ExtArgs>>): Prisma__FeatPrerequisiteMapClient<$Result.GetResult<Prisma.$FeatPrerequisiteMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatPrerequisiteMaps.
     * @param {FeatPrerequisiteMapCreateManyArgs} args - Arguments to create many FeatPrerequisiteMaps.
     * @example
     * // Create many FeatPrerequisiteMaps
     * const featPrerequisiteMap = await prisma.featPrerequisiteMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatPrerequisiteMapCreateManyArgs>(args?: SelectSubset<T, FeatPrerequisiteMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeatPrerequisiteMap.
     * @param {FeatPrerequisiteMapDeleteArgs} args - Arguments to delete one FeatPrerequisiteMap.
     * @example
     * // Delete one FeatPrerequisiteMap
     * const FeatPrerequisiteMap = await prisma.featPrerequisiteMap.delete({
     *   where: {
     *     // ... filter to delete one FeatPrerequisiteMap
     *   }
     * })
     * 
     */
    delete<T extends FeatPrerequisiteMapDeleteArgs>(args: SelectSubset<T, FeatPrerequisiteMapDeleteArgs<ExtArgs>>): Prisma__FeatPrerequisiteMapClient<$Result.GetResult<Prisma.$FeatPrerequisiteMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatPrerequisiteMap.
     * @param {FeatPrerequisiteMapUpdateArgs} args - Arguments to update one FeatPrerequisiteMap.
     * @example
     * // Update one FeatPrerequisiteMap
     * const featPrerequisiteMap = await prisma.featPrerequisiteMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatPrerequisiteMapUpdateArgs>(args: SelectSubset<T, FeatPrerequisiteMapUpdateArgs<ExtArgs>>): Prisma__FeatPrerequisiteMapClient<$Result.GetResult<Prisma.$FeatPrerequisiteMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatPrerequisiteMaps.
     * @param {FeatPrerequisiteMapDeleteManyArgs} args - Arguments to filter FeatPrerequisiteMaps to delete.
     * @example
     * // Delete a few FeatPrerequisiteMaps
     * const { count } = await prisma.featPrerequisiteMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatPrerequisiteMapDeleteManyArgs>(args?: SelectSubset<T, FeatPrerequisiteMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatPrerequisiteMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatPrerequisiteMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatPrerequisiteMaps
     * const featPrerequisiteMap = await prisma.featPrerequisiteMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatPrerequisiteMapUpdateManyArgs>(args: SelectSubset<T, FeatPrerequisiteMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeatPrerequisiteMap.
     * @param {FeatPrerequisiteMapUpsertArgs} args - Arguments to update or create a FeatPrerequisiteMap.
     * @example
     * // Update or create a FeatPrerequisiteMap
     * const featPrerequisiteMap = await prisma.featPrerequisiteMap.upsert({
     *   create: {
     *     // ... data to create a FeatPrerequisiteMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatPrerequisiteMap we want to update
     *   }
     * })
     */
    upsert<T extends FeatPrerequisiteMapUpsertArgs>(args: SelectSubset<T, FeatPrerequisiteMapUpsertArgs<ExtArgs>>): Prisma__FeatPrerequisiteMapClient<$Result.GetResult<Prisma.$FeatPrerequisiteMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatPrerequisiteMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatPrerequisiteMapCountArgs} args - Arguments to filter FeatPrerequisiteMaps to count.
     * @example
     * // Count the number of FeatPrerequisiteMaps
     * const count = await prisma.featPrerequisiteMap.count({
     *   where: {
     *     // ... the filter for the FeatPrerequisiteMaps we want to count
     *   }
     * })
    **/
    count<T extends FeatPrerequisiteMapCountArgs>(
      args?: Subset<T, FeatPrerequisiteMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatPrerequisiteMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatPrerequisiteMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatPrerequisiteMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatPrerequisiteMapAggregateArgs>(args: Subset<T, FeatPrerequisiteMapAggregateArgs>): Prisma.PrismaPromise<GetFeatPrerequisiteMapAggregateType<T>>

    /**
     * Group by FeatPrerequisiteMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatPrerequisiteMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatPrerequisiteMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatPrerequisiteMapGroupByArgs['orderBy'] }
        : { orderBy?: FeatPrerequisiteMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatPrerequisiteMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatPrerequisiteMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatPrerequisiteMap model
   */
  readonly fields: FeatPrerequisiteMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatPrerequisiteMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatPrerequisiteMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feat<T extends FeatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatDefaultArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatPrerequisiteMap model
   */
  interface FeatPrerequisiteMapFieldRefs {
    readonly featId: FieldRef<"FeatPrerequisiteMap", 'Int'>
    readonly typeId: FieldRef<"FeatPrerequisiteMap", 'Int'>
    readonly referenceId: FieldRef<"FeatPrerequisiteMap", 'Int'>
    readonly amount: FieldRef<"FeatPrerequisiteMap", 'Int'>
    readonly index: FieldRef<"FeatPrerequisiteMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FeatPrerequisiteMap findUnique
   */
  export type FeatPrerequisiteMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatPrerequisiteMap
     */
    select?: FeatPrerequisiteMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatPrerequisiteMap
     */
    omit?: FeatPrerequisiteMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatPrerequisiteMapInclude<ExtArgs> | null
    /**
     * Filter, which FeatPrerequisiteMap to fetch.
     */
    where: FeatPrerequisiteMapWhereUniqueInput
  }

  /**
   * FeatPrerequisiteMap findUniqueOrThrow
   */
  export type FeatPrerequisiteMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatPrerequisiteMap
     */
    select?: FeatPrerequisiteMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatPrerequisiteMap
     */
    omit?: FeatPrerequisiteMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatPrerequisiteMapInclude<ExtArgs> | null
    /**
     * Filter, which FeatPrerequisiteMap to fetch.
     */
    where: FeatPrerequisiteMapWhereUniqueInput
  }

  /**
   * FeatPrerequisiteMap findFirst
   */
  export type FeatPrerequisiteMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatPrerequisiteMap
     */
    select?: FeatPrerequisiteMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatPrerequisiteMap
     */
    omit?: FeatPrerequisiteMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatPrerequisiteMapInclude<ExtArgs> | null
    /**
     * Filter, which FeatPrerequisiteMap to fetch.
     */
    where?: FeatPrerequisiteMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatPrerequisiteMaps to fetch.
     */
    orderBy?: FeatPrerequisiteMapOrderByWithRelationInput | FeatPrerequisiteMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatPrerequisiteMaps.
     */
    cursor?: FeatPrerequisiteMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatPrerequisiteMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatPrerequisiteMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatPrerequisiteMaps.
     */
    distinct?: FeatPrerequisiteMapScalarFieldEnum | FeatPrerequisiteMapScalarFieldEnum[]
  }

  /**
   * FeatPrerequisiteMap findFirstOrThrow
   */
  export type FeatPrerequisiteMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatPrerequisiteMap
     */
    select?: FeatPrerequisiteMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatPrerequisiteMap
     */
    omit?: FeatPrerequisiteMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatPrerequisiteMapInclude<ExtArgs> | null
    /**
     * Filter, which FeatPrerequisiteMap to fetch.
     */
    where?: FeatPrerequisiteMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatPrerequisiteMaps to fetch.
     */
    orderBy?: FeatPrerequisiteMapOrderByWithRelationInput | FeatPrerequisiteMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatPrerequisiteMaps.
     */
    cursor?: FeatPrerequisiteMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatPrerequisiteMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatPrerequisiteMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatPrerequisiteMaps.
     */
    distinct?: FeatPrerequisiteMapScalarFieldEnum | FeatPrerequisiteMapScalarFieldEnum[]
  }

  /**
   * FeatPrerequisiteMap findMany
   */
  export type FeatPrerequisiteMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatPrerequisiteMap
     */
    select?: FeatPrerequisiteMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatPrerequisiteMap
     */
    omit?: FeatPrerequisiteMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatPrerequisiteMapInclude<ExtArgs> | null
    /**
     * Filter, which FeatPrerequisiteMaps to fetch.
     */
    where?: FeatPrerequisiteMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatPrerequisiteMaps to fetch.
     */
    orderBy?: FeatPrerequisiteMapOrderByWithRelationInput | FeatPrerequisiteMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatPrerequisiteMaps.
     */
    cursor?: FeatPrerequisiteMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatPrerequisiteMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatPrerequisiteMaps.
     */
    skip?: number
    distinct?: FeatPrerequisiteMapScalarFieldEnum | FeatPrerequisiteMapScalarFieldEnum[]
  }

  /**
   * FeatPrerequisiteMap create
   */
  export type FeatPrerequisiteMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatPrerequisiteMap
     */
    select?: FeatPrerequisiteMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatPrerequisiteMap
     */
    omit?: FeatPrerequisiteMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatPrerequisiteMapInclude<ExtArgs> | null
    /**
     * The data needed to create a FeatPrerequisiteMap.
     */
    data: XOR<FeatPrerequisiteMapCreateInput, FeatPrerequisiteMapUncheckedCreateInput>
  }

  /**
   * FeatPrerequisiteMap createMany
   */
  export type FeatPrerequisiteMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatPrerequisiteMaps.
     */
    data: FeatPrerequisiteMapCreateManyInput | FeatPrerequisiteMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatPrerequisiteMap update
   */
  export type FeatPrerequisiteMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatPrerequisiteMap
     */
    select?: FeatPrerequisiteMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatPrerequisiteMap
     */
    omit?: FeatPrerequisiteMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatPrerequisiteMapInclude<ExtArgs> | null
    /**
     * The data needed to update a FeatPrerequisiteMap.
     */
    data: XOR<FeatPrerequisiteMapUpdateInput, FeatPrerequisiteMapUncheckedUpdateInput>
    /**
     * Choose, which FeatPrerequisiteMap to update.
     */
    where: FeatPrerequisiteMapWhereUniqueInput
  }

  /**
   * FeatPrerequisiteMap updateMany
   */
  export type FeatPrerequisiteMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatPrerequisiteMaps.
     */
    data: XOR<FeatPrerequisiteMapUpdateManyMutationInput, FeatPrerequisiteMapUncheckedUpdateManyInput>
    /**
     * Filter which FeatPrerequisiteMaps to update
     */
    where?: FeatPrerequisiteMapWhereInput
    /**
     * Limit how many FeatPrerequisiteMaps to update.
     */
    limit?: number
  }

  /**
   * FeatPrerequisiteMap upsert
   */
  export type FeatPrerequisiteMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatPrerequisiteMap
     */
    select?: FeatPrerequisiteMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatPrerequisiteMap
     */
    omit?: FeatPrerequisiteMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatPrerequisiteMapInclude<ExtArgs> | null
    /**
     * The filter to search for the FeatPrerequisiteMap to update in case it exists.
     */
    where: FeatPrerequisiteMapWhereUniqueInput
    /**
     * In case the FeatPrerequisiteMap found by the `where` argument doesn't exist, create a new FeatPrerequisiteMap with this data.
     */
    create: XOR<FeatPrerequisiteMapCreateInput, FeatPrerequisiteMapUncheckedCreateInput>
    /**
     * In case the FeatPrerequisiteMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatPrerequisiteMapUpdateInput, FeatPrerequisiteMapUncheckedUpdateInput>
  }

  /**
   * FeatPrerequisiteMap delete
   */
  export type FeatPrerequisiteMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatPrerequisiteMap
     */
    select?: FeatPrerequisiteMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatPrerequisiteMap
     */
    omit?: FeatPrerequisiteMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatPrerequisiteMapInclude<ExtArgs> | null
    /**
     * Filter which FeatPrerequisiteMap to delete.
     */
    where: FeatPrerequisiteMapWhereUniqueInput
  }

  /**
   * FeatPrerequisiteMap deleteMany
   */
  export type FeatPrerequisiteMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatPrerequisiteMaps to delete
     */
    where?: FeatPrerequisiteMapWhereInput
    /**
     * Limit how many FeatPrerequisiteMaps to delete.
     */
    limit?: number
  }

  /**
   * FeatPrerequisiteMap without action
   */
  export type FeatPrerequisiteMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatPrerequisiteMap
     */
    select?: FeatPrerequisiteMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatPrerequisiteMap
     */
    omit?: FeatPrerequisiteMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatPrerequisiteMapInclude<ExtArgs> | null
  }


  /**
   * Model Race
   */

  export type AggregateRace = {
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  export type RaceAvgAggregateOutputType = {
    id: number | null
    editionId: number | null
    sizeId: number | null
    speed: number | null
    favoredClassId: number | null
  }

  export type RaceSumAggregateOutputType = {
    id: number | null
    editionId: number | null
    sizeId: number | null
    speed: number | null
    favoredClassId: number | null
  }

  export type RaceMinAggregateOutputType = {
    id: number | null
    name: string | null
    editionId: number | null
    isVisible: boolean | null
    description: string | null
    sizeId: number | null
    speed: number | null
    favoredClassId: number | null
  }

  export type RaceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    editionId: number | null
    isVisible: boolean | null
    description: string | null
    sizeId: number | null
    speed: number | null
    favoredClassId: number | null
  }

  export type RaceCountAggregateOutputType = {
    id: number
    name: number
    editionId: number
    isVisible: number
    description: number
    sizeId: number
    speed: number
    favoredClassId: number
    _all: number
  }


  export type RaceAvgAggregateInputType = {
    id?: true
    editionId?: true
    sizeId?: true
    speed?: true
    favoredClassId?: true
  }

  export type RaceSumAggregateInputType = {
    id?: true
    editionId?: true
    sizeId?: true
    speed?: true
    favoredClassId?: true
  }

  export type RaceMinAggregateInputType = {
    id?: true
    name?: true
    editionId?: true
    isVisible?: true
    description?: true
    sizeId?: true
    speed?: true
    favoredClassId?: true
  }

  export type RaceMaxAggregateInputType = {
    id?: true
    name?: true
    editionId?: true
    isVisible?: true
    description?: true
    sizeId?: true
    speed?: true
    favoredClassId?: true
  }

  export type RaceCountAggregateInputType = {
    id?: true
    name?: true
    editionId?: true
    isVisible?: true
    description?: true
    sizeId?: true
    speed?: true
    favoredClassId?: true
    _all?: true
  }

  export type RaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Race to aggregate.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Races
    **/
    _count?: true | RaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceMaxAggregateInputType
  }

  export type GetRaceAggregateType<T extends RaceAggregateArgs> = {
        [P in keyof T & keyof AggregateRace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRace[P]>
      : GetScalarType<T[P], AggregateRace[P]>
  }




  export type RaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceWhereInput
    orderBy?: RaceOrderByWithAggregationInput | RaceOrderByWithAggregationInput[]
    by: RaceScalarFieldEnum[] | RaceScalarFieldEnum
    having?: RaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceCountAggregateInputType | true
    _avg?: RaceAvgAggregateInputType
    _sum?: RaceSumAggregateInputType
    _min?: RaceMinAggregateInputType
    _max?: RaceMaxAggregateInputType
  }

  export type RaceGroupByOutputType = {
    id: number
    name: string
    editionId: number | null
    isVisible: boolean
    description: string | null
    sizeId: number
    speed: number
    favoredClassId: number
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  type GetRaceGroupByPayload<T extends RaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceGroupByOutputType[P]>
            : GetScalarType<T[P], RaceGroupByOutputType[P]>
        }
      >
    >


  export type RaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    editionId?: boolean
    isVisible?: boolean
    description?: boolean
    sizeId?: boolean
    speed?: boolean
    favoredClassId?: boolean
    abilityAdjustments?: boolean | Race$abilityAdjustmentsArgs<ExtArgs>
    languages?: boolean | Race$languagesArgs<ExtArgs>
    sources?: boolean | Race$sourcesArgs<ExtArgs>
    traits?: boolean | Race$traitsArgs<ExtArgs>
    UserCharacter?: boolean | Race$UserCharacterArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>



  export type RaceSelectScalar = {
    id?: boolean
    name?: boolean
    editionId?: boolean
    isVisible?: boolean
    description?: boolean
    sizeId?: boolean
    speed?: boolean
    favoredClassId?: boolean
  }

  export type RaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "editionId" | "isVisible" | "description" | "sizeId" | "speed" | "favoredClassId", ExtArgs["result"]["race"]>
  export type RaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilityAdjustments?: boolean | Race$abilityAdjustmentsArgs<ExtArgs>
    languages?: boolean | Race$languagesArgs<ExtArgs>
    sources?: boolean | Race$sourcesArgs<ExtArgs>
    traits?: boolean | Race$traitsArgs<ExtArgs>
    UserCharacter?: boolean | Race$UserCharacterArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Race"
    objects: {
      abilityAdjustments: Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>[]
      languages: Prisma.$RaceLanguageMapPayload<ExtArgs>[]
      sources: Prisma.$RaceSourceMapPayload<ExtArgs>[]
      traits: Prisma.$RaceTraitMapPayload<ExtArgs>[]
      UserCharacter: Prisma.$UserCharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      editionId: number | null
      isVisible: boolean
      description: string | null
      sizeId: number
      speed: number
      favoredClassId: number
    }, ExtArgs["result"]["race"]>
    composites: {}
  }

  type RaceGetPayload<S extends boolean | null | undefined | RaceDefaultArgs> = $Result.GetResult<Prisma.$RacePayload, S>

  type RaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceCountAggregateInputType | true
    }

  export interface RaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Race'], meta: { name: 'Race' } }
    /**
     * Find zero or one Race that matches the filter.
     * @param {RaceFindUniqueArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceFindUniqueArgs>(args: SelectSubset<T, RaceFindUniqueArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Race that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceFindUniqueOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Race that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceFindFirstArgs>(args?: SelectSubset<T, RaceFindFirstArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Race that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Races that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Races
     * const races = await prisma.race.findMany()
     * 
     * // Get first 10 Races
     * const races = await prisma.race.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raceWithIdOnly = await prisma.race.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaceFindManyArgs>(args?: SelectSubset<T, RaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Race.
     * @param {RaceCreateArgs} args - Arguments to create a Race.
     * @example
     * // Create one Race
     * const Race = await prisma.race.create({
     *   data: {
     *     // ... data to create a Race
     *   }
     * })
     * 
     */
    create<T extends RaceCreateArgs>(args: SelectSubset<T, RaceCreateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Races.
     * @param {RaceCreateManyArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceCreateManyArgs>(args?: SelectSubset<T, RaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Race.
     * @param {RaceDeleteArgs} args - Arguments to delete one Race.
     * @example
     * // Delete one Race
     * const Race = await prisma.race.delete({
     *   where: {
     *     // ... filter to delete one Race
     *   }
     * })
     * 
     */
    delete<T extends RaceDeleteArgs>(args: SelectSubset<T, RaceDeleteArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Race.
     * @param {RaceUpdateArgs} args - Arguments to update one Race.
     * @example
     * // Update one Race
     * const race = await prisma.race.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceUpdateArgs>(args: SelectSubset<T, RaceUpdateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Races.
     * @param {RaceDeleteManyArgs} args - Arguments to filter Races to delete.
     * @example
     * // Delete a few Races
     * const { count } = await prisma.race.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceDeleteManyArgs>(args?: SelectSubset<T, RaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Races
     * const race = await prisma.race.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceUpdateManyArgs>(args: SelectSubset<T, RaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Race.
     * @param {RaceUpsertArgs} args - Arguments to update or create a Race.
     * @example
     * // Update or create a Race
     * const race = await prisma.race.upsert({
     *   create: {
     *     // ... data to create a Race
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Race we want to update
     *   }
     * })
     */
    upsert<T extends RaceUpsertArgs>(args: SelectSubset<T, RaceUpsertArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceCountArgs} args - Arguments to filter Races to count.
     * @example
     * // Count the number of Races
     * const count = await prisma.race.count({
     *   where: {
     *     // ... the filter for the Races we want to count
     *   }
     * })
    **/
    count<T extends RaceCountArgs>(
      args?: Subset<T, RaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceAggregateArgs>(args: Subset<T, RaceAggregateArgs>): Prisma.PrismaPromise<GetRaceAggregateType<T>>

    /**
     * Group by Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceGroupByArgs['orderBy'] }
        : { orderBy?: RaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Race model
   */
  readonly fields: RaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Race.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    abilityAdjustments<T extends Race$abilityAdjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, Race$abilityAdjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    languages<T extends Race$languagesArgs<ExtArgs> = {}>(args?: Subset<T, Race$languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceLanguageMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sources<T extends Race$sourcesArgs<ExtArgs> = {}>(args?: Subset<T, Race$sourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceSourceMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    traits<T extends Race$traitsArgs<ExtArgs> = {}>(args?: Subset<T, Race$traitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceTraitMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserCharacter<T extends Race$UserCharacterArgs<ExtArgs> = {}>(args?: Subset<T, Race$UserCharacterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Race model
   */
  interface RaceFieldRefs {
    readonly id: FieldRef<"Race", 'Int'>
    readonly name: FieldRef<"Race", 'String'>
    readonly editionId: FieldRef<"Race", 'Int'>
    readonly isVisible: FieldRef<"Race", 'Boolean'>
    readonly description: FieldRef<"Race", 'String'>
    readonly sizeId: FieldRef<"Race", 'Int'>
    readonly speed: FieldRef<"Race", 'Int'>
    readonly favoredClassId: FieldRef<"Race", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Race findUnique
   */
  export type RaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findUniqueOrThrow
   */
  export type RaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findFirst
   */
  export type RaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findFirstOrThrow
   */
  export type RaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findMany
   */
  export type RaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Races to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race create
   */
  export type RaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Race.
     */
    data: XOR<RaceCreateInput, RaceUncheckedCreateInput>
  }

  /**
   * Race createMany
   */
  export type RaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Race update
   */
  export type RaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Race.
     */
    data: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
    /**
     * Choose, which Race to update.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race updateMany
   */
  export type RaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Races.
     */
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyInput>
    /**
     * Filter which Races to update
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to update.
     */
    limit?: number
  }

  /**
   * Race upsert
   */
  export type RaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Race to update in case it exists.
     */
    where: RaceWhereUniqueInput
    /**
     * In case the Race found by the `where` argument doesn't exist, create a new Race with this data.
     */
    create: XOR<RaceCreateInput, RaceUncheckedCreateInput>
    /**
     * In case the Race was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
  }

  /**
   * Race delete
   */
  export type RaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter which Race to delete.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race deleteMany
   */
  export type RaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Races to delete
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to delete.
     */
    limit?: number
  }

  /**
   * Race.abilityAdjustments
   */
  export type Race$abilityAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceAbilityAdjustment
     */
    select?: RaceAbilityAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceAbilityAdjustment
     */
    omit?: RaceAbilityAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceAbilityAdjustmentInclude<ExtArgs> | null
    where?: RaceAbilityAdjustmentWhereInput
    orderBy?: RaceAbilityAdjustmentOrderByWithRelationInput | RaceAbilityAdjustmentOrderByWithRelationInput[]
    cursor?: RaceAbilityAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceAbilityAdjustmentScalarFieldEnum | RaceAbilityAdjustmentScalarFieldEnum[]
  }

  /**
   * Race.languages
   */
  export type Race$languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceLanguageMap
     */
    select?: RaceLanguageMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceLanguageMap
     */
    omit?: RaceLanguageMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceLanguageMapInclude<ExtArgs> | null
    where?: RaceLanguageMapWhereInput
    orderBy?: RaceLanguageMapOrderByWithRelationInput | RaceLanguageMapOrderByWithRelationInput[]
    cursor?: RaceLanguageMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceLanguageMapScalarFieldEnum | RaceLanguageMapScalarFieldEnum[]
  }

  /**
   * Race.sources
   */
  export type Race$sourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
    where?: RaceSourceMapWhereInput
    orderBy?: RaceSourceMapOrderByWithRelationInput | RaceSourceMapOrderByWithRelationInput[]
    cursor?: RaceSourceMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceSourceMapScalarFieldEnum | RaceSourceMapScalarFieldEnum[]
  }

  /**
   * Race.traits
   */
  export type Race$traitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
    where?: RaceTraitMapWhereInput
    orderBy?: RaceTraitMapOrderByWithRelationInput | RaceTraitMapOrderByWithRelationInput[]
    cursor?: RaceTraitMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceTraitMapScalarFieldEnum | RaceTraitMapScalarFieldEnum[]
  }

  /**
   * Race.UserCharacter
   */
  export type Race$UserCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
    where?: UserCharacterWhereInput
    orderBy?: UserCharacterOrderByWithRelationInput | UserCharacterOrderByWithRelationInput[]
    cursor?: UserCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCharacterScalarFieldEnum | UserCharacterScalarFieldEnum[]
  }

  /**
   * Race without action
   */
  export type RaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
  }


  /**
   * Model RaceTrait
   */

  export type AggregateRaceTrait = {
    _count: RaceTraitCountAggregateOutputType | null
    _min: RaceTraitMinAggregateOutputType | null
    _max: RaceTraitMaxAggregateOutputType | null
  }

  export type RaceTraitMinAggregateOutputType = {
    slug: string | null
    name: string | null
    description: string | null
    hasValue: boolean | null
  }

  export type RaceTraitMaxAggregateOutputType = {
    slug: string | null
    name: string | null
    description: string | null
    hasValue: boolean | null
  }

  export type RaceTraitCountAggregateOutputType = {
    slug: number
    name: number
    description: number
    hasValue: number
    _all: number
  }


  export type RaceTraitMinAggregateInputType = {
    slug?: true
    name?: true
    description?: true
    hasValue?: true
  }

  export type RaceTraitMaxAggregateInputType = {
    slug?: true
    name?: true
    description?: true
    hasValue?: true
  }

  export type RaceTraitCountAggregateInputType = {
    slug?: true
    name?: true
    description?: true
    hasValue?: true
    _all?: true
  }

  export type RaceTraitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceTrait to aggregate.
     */
    where?: RaceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraits to fetch.
     */
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceTraits
    **/
    _count?: true | RaceTraitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceTraitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceTraitMaxAggregateInputType
  }

  export type GetRaceTraitAggregateType<T extends RaceTraitAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceTrait]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceTrait[P]>
      : GetScalarType<T[P], AggregateRaceTrait[P]>
  }




  export type RaceTraitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceTraitWhereInput
    orderBy?: RaceTraitOrderByWithAggregationInput | RaceTraitOrderByWithAggregationInput[]
    by: RaceTraitScalarFieldEnum[] | RaceTraitScalarFieldEnum
    having?: RaceTraitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceTraitCountAggregateInputType | true
    _min?: RaceTraitMinAggregateInputType
    _max?: RaceTraitMaxAggregateInputType
  }

  export type RaceTraitGroupByOutputType = {
    slug: string
    name: string | null
    description: string | null
    hasValue: boolean
    _count: RaceTraitCountAggregateOutputType | null
    _min: RaceTraitMinAggregateOutputType | null
    _max: RaceTraitMaxAggregateOutputType | null
  }

  type GetRaceTraitGroupByPayload<T extends RaceTraitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceTraitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceTraitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceTraitGroupByOutputType[P]>
            : GetScalarType<T[P], RaceTraitGroupByOutputType[P]>
        }
      >
    >


  export type RaceTraitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    slug?: boolean
    name?: boolean
    description?: boolean
    hasValue?: boolean
    raceLinks?: boolean | RaceTrait$raceLinksArgs<ExtArgs>
    _count?: boolean | RaceTraitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceTrait"]>



  export type RaceTraitSelectScalar = {
    slug?: boolean
    name?: boolean
    description?: boolean
    hasValue?: boolean
  }

  export type RaceTraitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"slug" | "name" | "description" | "hasValue", ExtArgs["result"]["raceTrait"]>
  export type RaceTraitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raceLinks?: boolean | RaceTrait$raceLinksArgs<ExtArgs>
    _count?: boolean | RaceTraitCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RaceTraitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceTrait"
    objects: {
      raceLinks: Prisma.$RaceTraitMapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      slug: string
      name: string | null
      description: string | null
      hasValue: boolean
    }, ExtArgs["result"]["raceTrait"]>
    composites: {}
  }

  type RaceTraitGetPayload<S extends boolean | null | undefined | RaceTraitDefaultArgs> = $Result.GetResult<Prisma.$RaceTraitPayload, S>

  type RaceTraitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceTraitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceTraitCountAggregateInputType | true
    }

  export interface RaceTraitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceTrait'], meta: { name: 'RaceTrait' } }
    /**
     * Find zero or one RaceTrait that matches the filter.
     * @param {RaceTraitFindUniqueArgs} args - Arguments to find a RaceTrait
     * @example
     * // Get one RaceTrait
     * const raceTrait = await prisma.raceTrait.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceTraitFindUniqueArgs>(args: SelectSubset<T, RaceTraitFindUniqueArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaceTrait that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceTraitFindUniqueOrThrowArgs} args - Arguments to find a RaceTrait
     * @example
     * // Get one RaceTrait
     * const raceTrait = await prisma.raceTrait.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceTraitFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceTraitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceTrait that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitFindFirstArgs} args - Arguments to find a RaceTrait
     * @example
     * // Get one RaceTrait
     * const raceTrait = await prisma.raceTrait.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceTraitFindFirstArgs>(args?: SelectSubset<T, RaceTraitFindFirstArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceTrait that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitFindFirstOrThrowArgs} args - Arguments to find a RaceTrait
     * @example
     * // Get one RaceTrait
     * const raceTrait = await prisma.raceTrait.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceTraitFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceTraitFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaceTraits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceTraits
     * const raceTraits = await prisma.raceTrait.findMany()
     * 
     * // Get first 10 RaceTraits
     * const raceTraits = await prisma.raceTrait.findMany({ take: 10 })
     * 
     * // Only select the `slug`
     * const raceTraitWithSlugOnly = await prisma.raceTrait.findMany({ select: { slug: true } })
     * 
     */
    findMany<T extends RaceTraitFindManyArgs>(args?: SelectSubset<T, RaceTraitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaceTrait.
     * @param {RaceTraitCreateArgs} args - Arguments to create a RaceTrait.
     * @example
     * // Create one RaceTrait
     * const RaceTrait = await prisma.raceTrait.create({
     *   data: {
     *     // ... data to create a RaceTrait
     *   }
     * })
     * 
     */
    create<T extends RaceTraitCreateArgs>(args: SelectSubset<T, RaceTraitCreateArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaceTraits.
     * @param {RaceTraitCreateManyArgs} args - Arguments to create many RaceTraits.
     * @example
     * // Create many RaceTraits
     * const raceTrait = await prisma.raceTrait.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceTraitCreateManyArgs>(args?: SelectSubset<T, RaceTraitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RaceTrait.
     * @param {RaceTraitDeleteArgs} args - Arguments to delete one RaceTrait.
     * @example
     * // Delete one RaceTrait
     * const RaceTrait = await prisma.raceTrait.delete({
     *   where: {
     *     // ... filter to delete one RaceTrait
     *   }
     * })
     * 
     */
    delete<T extends RaceTraitDeleteArgs>(args: SelectSubset<T, RaceTraitDeleteArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaceTrait.
     * @param {RaceTraitUpdateArgs} args - Arguments to update one RaceTrait.
     * @example
     * // Update one RaceTrait
     * const raceTrait = await prisma.raceTrait.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceTraitUpdateArgs>(args: SelectSubset<T, RaceTraitUpdateArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaceTraits.
     * @param {RaceTraitDeleteManyArgs} args - Arguments to filter RaceTraits to delete.
     * @example
     * // Delete a few RaceTraits
     * const { count } = await prisma.raceTrait.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceTraitDeleteManyArgs>(args?: SelectSubset<T, RaceTraitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceTraits
     * const raceTrait = await prisma.raceTrait.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceTraitUpdateManyArgs>(args: SelectSubset<T, RaceTraitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RaceTrait.
     * @param {RaceTraitUpsertArgs} args - Arguments to update or create a RaceTrait.
     * @example
     * // Update or create a RaceTrait
     * const raceTrait = await prisma.raceTrait.upsert({
     *   create: {
     *     // ... data to create a RaceTrait
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceTrait we want to update
     *   }
     * })
     */
    upsert<T extends RaceTraitUpsertArgs>(args: SelectSubset<T, RaceTraitUpsertArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaceTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitCountArgs} args - Arguments to filter RaceTraits to count.
     * @example
     * // Count the number of RaceTraits
     * const count = await prisma.raceTrait.count({
     *   where: {
     *     // ... the filter for the RaceTraits we want to count
     *   }
     * })
    **/
    count<T extends RaceTraitCountArgs>(
      args?: Subset<T, RaceTraitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceTraitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceTraitAggregateArgs>(args: Subset<T, RaceTraitAggregateArgs>): Prisma.PrismaPromise<GetRaceTraitAggregateType<T>>

    /**
     * Group by RaceTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceTraitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceTraitGroupByArgs['orderBy'] }
        : { orderBy?: RaceTraitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceTraitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceTraitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceTrait model
   */
  readonly fields: RaceTraitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceTrait.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceTraitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    raceLinks<T extends RaceTrait$raceLinksArgs<ExtArgs> = {}>(args?: Subset<T, RaceTrait$raceLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceTraitMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaceTrait model
   */
  interface RaceTraitFieldRefs {
    readonly slug: FieldRef<"RaceTrait", 'String'>
    readonly name: FieldRef<"RaceTrait", 'String'>
    readonly description: FieldRef<"RaceTrait", 'String'>
    readonly hasValue: FieldRef<"RaceTrait", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RaceTrait findUnique
   */
  export type RaceTraitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceTrait to fetch.
     */
    where: RaceTraitWhereUniqueInput
  }

  /**
   * RaceTrait findUniqueOrThrow
   */
  export type RaceTraitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceTrait to fetch.
     */
    where: RaceTraitWhereUniqueInput
  }

  /**
   * RaceTrait findFirst
   */
  export type RaceTraitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceTrait to fetch.
     */
    where?: RaceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraits to fetch.
     */
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceTraits.
     */
    cursor?: RaceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceTraits.
     */
    distinct?: RaceTraitScalarFieldEnum | RaceTraitScalarFieldEnum[]
  }

  /**
   * RaceTrait findFirstOrThrow
   */
  export type RaceTraitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceTrait to fetch.
     */
    where?: RaceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraits to fetch.
     */
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceTraits.
     */
    cursor?: RaceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceTraits.
     */
    distinct?: RaceTraitScalarFieldEnum | RaceTraitScalarFieldEnum[]
  }

  /**
   * RaceTrait findMany
   */
  export type RaceTraitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceTraits to fetch.
     */
    where?: RaceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraits to fetch.
     */
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceTraits.
     */
    cursor?: RaceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraits.
     */
    skip?: number
    distinct?: RaceTraitScalarFieldEnum | RaceTraitScalarFieldEnum[]
  }

  /**
   * RaceTrait create
   */
  export type RaceTraitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceTrait.
     */
    data: XOR<RaceTraitCreateInput, RaceTraitUncheckedCreateInput>
  }

  /**
   * RaceTrait createMany
   */
  export type RaceTraitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceTraits.
     */
    data: RaceTraitCreateManyInput | RaceTraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaceTrait update
   */
  export type RaceTraitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceTrait.
     */
    data: XOR<RaceTraitUpdateInput, RaceTraitUncheckedUpdateInput>
    /**
     * Choose, which RaceTrait to update.
     */
    where: RaceTraitWhereUniqueInput
  }

  /**
   * RaceTrait updateMany
   */
  export type RaceTraitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceTraits.
     */
    data: XOR<RaceTraitUpdateManyMutationInput, RaceTraitUncheckedUpdateManyInput>
    /**
     * Filter which RaceTraits to update
     */
    where?: RaceTraitWhereInput
    /**
     * Limit how many RaceTraits to update.
     */
    limit?: number
  }

  /**
   * RaceTrait upsert
   */
  export type RaceTraitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceTrait to update in case it exists.
     */
    where: RaceTraitWhereUniqueInput
    /**
     * In case the RaceTrait found by the `where` argument doesn't exist, create a new RaceTrait with this data.
     */
    create: XOR<RaceTraitCreateInput, RaceTraitUncheckedCreateInput>
    /**
     * In case the RaceTrait was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceTraitUpdateInput, RaceTraitUncheckedUpdateInput>
  }

  /**
   * RaceTrait delete
   */
  export type RaceTraitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter which RaceTrait to delete.
     */
    where: RaceTraitWhereUniqueInput
  }

  /**
   * RaceTrait deleteMany
   */
  export type RaceTraitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceTraits to delete
     */
    where?: RaceTraitWhereInput
    /**
     * Limit how many RaceTraits to delete.
     */
    limit?: number
  }

  /**
   * RaceTrait.raceLinks
   */
  export type RaceTrait$raceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
    where?: RaceTraitMapWhereInput
    orderBy?: RaceTraitMapOrderByWithRelationInput | RaceTraitMapOrderByWithRelationInput[]
    cursor?: RaceTraitMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceTraitMapScalarFieldEnum | RaceTraitMapScalarFieldEnum[]
  }

  /**
   * RaceTrait without action
   */
  export type RaceTraitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
  }


  /**
   * Model RaceTraitMap
   */

  export type AggregateRaceTraitMap = {
    _count: RaceTraitMapCountAggregateOutputType | null
    _avg: RaceTraitMapAvgAggregateOutputType | null
    _sum: RaceTraitMapSumAggregateOutputType | null
    _min: RaceTraitMapMinAggregateOutputType | null
    _max: RaceTraitMapMaxAggregateOutputType | null
  }

  export type RaceTraitMapAvgAggregateOutputType = {
    raceId: number | null
  }

  export type RaceTraitMapSumAggregateOutputType = {
    raceId: number | null
  }

  export type RaceTraitMapMinAggregateOutputType = {
    raceId: number | null
    traitId: string | null
    value: string | null
  }

  export type RaceTraitMapMaxAggregateOutputType = {
    raceId: number | null
    traitId: string | null
    value: string | null
  }

  export type RaceTraitMapCountAggregateOutputType = {
    raceId: number
    traitId: number
    value: number
    _all: number
  }


  export type RaceTraitMapAvgAggregateInputType = {
    raceId?: true
  }

  export type RaceTraitMapSumAggregateInputType = {
    raceId?: true
  }

  export type RaceTraitMapMinAggregateInputType = {
    raceId?: true
    traitId?: true
    value?: true
  }

  export type RaceTraitMapMaxAggregateInputType = {
    raceId?: true
    traitId?: true
    value?: true
  }

  export type RaceTraitMapCountAggregateInputType = {
    raceId?: true
    traitId?: true
    value?: true
    _all?: true
  }

  export type RaceTraitMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceTraitMap to aggregate.
     */
    where?: RaceTraitMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraitMaps to fetch.
     */
    orderBy?: RaceTraitMapOrderByWithRelationInput | RaceTraitMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceTraitMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraitMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraitMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceTraitMaps
    **/
    _count?: true | RaceTraitMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceTraitMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceTraitMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceTraitMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceTraitMapMaxAggregateInputType
  }

  export type GetRaceTraitMapAggregateType<T extends RaceTraitMapAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceTraitMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceTraitMap[P]>
      : GetScalarType<T[P], AggregateRaceTraitMap[P]>
  }




  export type RaceTraitMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceTraitMapWhereInput
    orderBy?: RaceTraitMapOrderByWithAggregationInput | RaceTraitMapOrderByWithAggregationInput[]
    by: RaceTraitMapScalarFieldEnum[] | RaceTraitMapScalarFieldEnum
    having?: RaceTraitMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceTraitMapCountAggregateInputType | true
    _avg?: RaceTraitMapAvgAggregateInputType
    _sum?: RaceTraitMapSumAggregateInputType
    _min?: RaceTraitMapMinAggregateInputType
    _max?: RaceTraitMapMaxAggregateInputType
  }

  export type RaceTraitMapGroupByOutputType = {
    raceId: number
    traitId: string
    value: string | null
    _count: RaceTraitMapCountAggregateOutputType | null
    _avg: RaceTraitMapAvgAggregateOutputType | null
    _sum: RaceTraitMapSumAggregateOutputType | null
    _min: RaceTraitMapMinAggregateOutputType | null
    _max: RaceTraitMapMaxAggregateOutputType | null
  }

  type GetRaceTraitMapGroupByPayload<T extends RaceTraitMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceTraitMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceTraitMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceTraitMapGroupByOutputType[P]>
            : GetScalarType<T[P], RaceTraitMapGroupByOutputType[P]>
        }
      >
    >


  export type RaceTraitMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceId?: boolean
    traitId?: boolean
    value?: boolean
    race?: boolean | RaceDefaultArgs<ExtArgs>
    trait?: boolean | RaceTraitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceTraitMap"]>



  export type RaceTraitMapSelectScalar = {
    raceId?: boolean
    traitId?: boolean
    value?: boolean
  }

  export type RaceTraitMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"raceId" | "traitId" | "value", ExtArgs["result"]["raceTraitMap"]>
  export type RaceTraitMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | RaceDefaultArgs<ExtArgs>
    trait?: boolean | RaceTraitDefaultArgs<ExtArgs>
  }

  export type $RaceTraitMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceTraitMap"
    objects: {
      race: Prisma.$RacePayload<ExtArgs>
      trait: Prisma.$RaceTraitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      raceId: number
      traitId: string
      value: string | null
    }, ExtArgs["result"]["raceTraitMap"]>
    composites: {}
  }

  type RaceTraitMapGetPayload<S extends boolean | null | undefined | RaceTraitMapDefaultArgs> = $Result.GetResult<Prisma.$RaceTraitMapPayload, S>

  type RaceTraitMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceTraitMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceTraitMapCountAggregateInputType | true
    }

  export interface RaceTraitMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceTraitMap'], meta: { name: 'RaceTraitMap' } }
    /**
     * Find zero or one RaceTraitMap that matches the filter.
     * @param {RaceTraitMapFindUniqueArgs} args - Arguments to find a RaceTraitMap
     * @example
     * // Get one RaceTraitMap
     * const raceTraitMap = await prisma.raceTraitMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceTraitMapFindUniqueArgs>(args: SelectSubset<T, RaceTraitMapFindUniqueArgs<ExtArgs>>): Prisma__RaceTraitMapClient<$Result.GetResult<Prisma.$RaceTraitMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaceTraitMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceTraitMapFindUniqueOrThrowArgs} args - Arguments to find a RaceTraitMap
     * @example
     * // Get one RaceTraitMap
     * const raceTraitMap = await prisma.raceTraitMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceTraitMapFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceTraitMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceTraitMapClient<$Result.GetResult<Prisma.$RaceTraitMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceTraitMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitMapFindFirstArgs} args - Arguments to find a RaceTraitMap
     * @example
     * // Get one RaceTraitMap
     * const raceTraitMap = await prisma.raceTraitMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceTraitMapFindFirstArgs>(args?: SelectSubset<T, RaceTraitMapFindFirstArgs<ExtArgs>>): Prisma__RaceTraitMapClient<$Result.GetResult<Prisma.$RaceTraitMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceTraitMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitMapFindFirstOrThrowArgs} args - Arguments to find a RaceTraitMap
     * @example
     * // Get one RaceTraitMap
     * const raceTraitMap = await prisma.raceTraitMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceTraitMapFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceTraitMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceTraitMapClient<$Result.GetResult<Prisma.$RaceTraitMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaceTraitMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceTraitMaps
     * const raceTraitMaps = await prisma.raceTraitMap.findMany()
     * 
     * // Get first 10 RaceTraitMaps
     * const raceTraitMaps = await prisma.raceTraitMap.findMany({ take: 10 })
     * 
     * // Only select the `raceId`
     * const raceTraitMapWithRaceIdOnly = await prisma.raceTraitMap.findMany({ select: { raceId: true } })
     * 
     */
    findMany<T extends RaceTraitMapFindManyArgs>(args?: SelectSubset<T, RaceTraitMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceTraitMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaceTraitMap.
     * @param {RaceTraitMapCreateArgs} args - Arguments to create a RaceTraitMap.
     * @example
     * // Create one RaceTraitMap
     * const RaceTraitMap = await prisma.raceTraitMap.create({
     *   data: {
     *     // ... data to create a RaceTraitMap
     *   }
     * })
     * 
     */
    create<T extends RaceTraitMapCreateArgs>(args: SelectSubset<T, RaceTraitMapCreateArgs<ExtArgs>>): Prisma__RaceTraitMapClient<$Result.GetResult<Prisma.$RaceTraitMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaceTraitMaps.
     * @param {RaceTraitMapCreateManyArgs} args - Arguments to create many RaceTraitMaps.
     * @example
     * // Create many RaceTraitMaps
     * const raceTraitMap = await prisma.raceTraitMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceTraitMapCreateManyArgs>(args?: SelectSubset<T, RaceTraitMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RaceTraitMap.
     * @param {RaceTraitMapDeleteArgs} args - Arguments to delete one RaceTraitMap.
     * @example
     * // Delete one RaceTraitMap
     * const RaceTraitMap = await prisma.raceTraitMap.delete({
     *   where: {
     *     // ... filter to delete one RaceTraitMap
     *   }
     * })
     * 
     */
    delete<T extends RaceTraitMapDeleteArgs>(args: SelectSubset<T, RaceTraitMapDeleteArgs<ExtArgs>>): Prisma__RaceTraitMapClient<$Result.GetResult<Prisma.$RaceTraitMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaceTraitMap.
     * @param {RaceTraitMapUpdateArgs} args - Arguments to update one RaceTraitMap.
     * @example
     * // Update one RaceTraitMap
     * const raceTraitMap = await prisma.raceTraitMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceTraitMapUpdateArgs>(args: SelectSubset<T, RaceTraitMapUpdateArgs<ExtArgs>>): Prisma__RaceTraitMapClient<$Result.GetResult<Prisma.$RaceTraitMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaceTraitMaps.
     * @param {RaceTraitMapDeleteManyArgs} args - Arguments to filter RaceTraitMaps to delete.
     * @example
     * // Delete a few RaceTraitMaps
     * const { count } = await prisma.raceTraitMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceTraitMapDeleteManyArgs>(args?: SelectSubset<T, RaceTraitMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceTraitMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceTraitMaps
     * const raceTraitMap = await prisma.raceTraitMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceTraitMapUpdateManyArgs>(args: SelectSubset<T, RaceTraitMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RaceTraitMap.
     * @param {RaceTraitMapUpsertArgs} args - Arguments to update or create a RaceTraitMap.
     * @example
     * // Update or create a RaceTraitMap
     * const raceTraitMap = await prisma.raceTraitMap.upsert({
     *   create: {
     *     // ... data to create a RaceTraitMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceTraitMap we want to update
     *   }
     * })
     */
    upsert<T extends RaceTraitMapUpsertArgs>(args: SelectSubset<T, RaceTraitMapUpsertArgs<ExtArgs>>): Prisma__RaceTraitMapClient<$Result.GetResult<Prisma.$RaceTraitMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaceTraitMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitMapCountArgs} args - Arguments to filter RaceTraitMaps to count.
     * @example
     * // Count the number of RaceTraitMaps
     * const count = await prisma.raceTraitMap.count({
     *   where: {
     *     // ... the filter for the RaceTraitMaps we want to count
     *   }
     * })
    **/
    count<T extends RaceTraitMapCountArgs>(
      args?: Subset<T, RaceTraitMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceTraitMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceTraitMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceTraitMapAggregateArgs>(args: Subset<T, RaceTraitMapAggregateArgs>): Prisma.PrismaPromise<GetRaceTraitMapAggregateType<T>>

    /**
     * Group by RaceTraitMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceTraitMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceTraitMapGroupByArgs['orderBy'] }
        : { orderBy?: RaceTraitMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceTraitMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceTraitMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceTraitMap model
   */
  readonly fields: RaceTraitMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceTraitMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceTraitMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trait<T extends RaceTraitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceTraitDefaultArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaceTraitMap model
   */
  interface RaceTraitMapFieldRefs {
    readonly raceId: FieldRef<"RaceTraitMap", 'Int'>
    readonly traitId: FieldRef<"RaceTraitMap", 'String'>
    readonly value: FieldRef<"RaceTraitMap", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RaceTraitMap findUnique
   */
  export type RaceTraitMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceTraitMap to fetch.
     */
    where: RaceTraitMapWhereUniqueInput
  }

  /**
   * RaceTraitMap findUniqueOrThrow
   */
  export type RaceTraitMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceTraitMap to fetch.
     */
    where: RaceTraitMapWhereUniqueInput
  }

  /**
   * RaceTraitMap findFirst
   */
  export type RaceTraitMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceTraitMap to fetch.
     */
    where?: RaceTraitMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraitMaps to fetch.
     */
    orderBy?: RaceTraitMapOrderByWithRelationInput | RaceTraitMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceTraitMaps.
     */
    cursor?: RaceTraitMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraitMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraitMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceTraitMaps.
     */
    distinct?: RaceTraitMapScalarFieldEnum | RaceTraitMapScalarFieldEnum[]
  }

  /**
   * RaceTraitMap findFirstOrThrow
   */
  export type RaceTraitMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceTraitMap to fetch.
     */
    where?: RaceTraitMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraitMaps to fetch.
     */
    orderBy?: RaceTraitMapOrderByWithRelationInput | RaceTraitMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceTraitMaps.
     */
    cursor?: RaceTraitMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraitMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraitMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceTraitMaps.
     */
    distinct?: RaceTraitMapScalarFieldEnum | RaceTraitMapScalarFieldEnum[]
  }

  /**
   * RaceTraitMap findMany
   */
  export type RaceTraitMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceTraitMaps to fetch.
     */
    where?: RaceTraitMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraitMaps to fetch.
     */
    orderBy?: RaceTraitMapOrderByWithRelationInput | RaceTraitMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceTraitMaps.
     */
    cursor?: RaceTraitMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraitMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraitMaps.
     */
    skip?: number
    distinct?: RaceTraitMapScalarFieldEnum | RaceTraitMapScalarFieldEnum[]
  }

  /**
   * RaceTraitMap create
   */
  export type RaceTraitMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceTraitMap.
     */
    data: XOR<RaceTraitMapCreateInput, RaceTraitMapUncheckedCreateInput>
  }

  /**
   * RaceTraitMap createMany
   */
  export type RaceTraitMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceTraitMaps.
     */
    data: RaceTraitMapCreateManyInput | RaceTraitMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaceTraitMap update
   */
  export type RaceTraitMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceTraitMap.
     */
    data: XOR<RaceTraitMapUpdateInput, RaceTraitMapUncheckedUpdateInput>
    /**
     * Choose, which RaceTraitMap to update.
     */
    where: RaceTraitMapWhereUniqueInput
  }

  /**
   * RaceTraitMap updateMany
   */
  export type RaceTraitMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceTraitMaps.
     */
    data: XOR<RaceTraitMapUpdateManyMutationInput, RaceTraitMapUncheckedUpdateManyInput>
    /**
     * Filter which RaceTraitMaps to update
     */
    where?: RaceTraitMapWhereInput
    /**
     * Limit how many RaceTraitMaps to update.
     */
    limit?: number
  }

  /**
   * RaceTraitMap upsert
   */
  export type RaceTraitMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceTraitMap to update in case it exists.
     */
    where: RaceTraitMapWhereUniqueInput
    /**
     * In case the RaceTraitMap found by the `where` argument doesn't exist, create a new RaceTraitMap with this data.
     */
    create: XOR<RaceTraitMapCreateInput, RaceTraitMapUncheckedCreateInput>
    /**
     * In case the RaceTraitMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceTraitMapUpdateInput, RaceTraitMapUncheckedUpdateInput>
  }

  /**
   * RaceTraitMap delete
   */
  export type RaceTraitMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
    /**
     * Filter which RaceTraitMap to delete.
     */
    where: RaceTraitMapWhereUniqueInput
  }

  /**
   * RaceTraitMap deleteMany
   */
  export type RaceTraitMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceTraitMaps to delete
     */
    where?: RaceTraitMapWhereInput
    /**
     * Limit how many RaceTraitMaps to delete.
     */
    limit?: number
  }

  /**
   * RaceTraitMap without action
   */
  export type RaceTraitMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitMap
     */
    select?: RaceTraitMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTraitMap
     */
    omit?: RaceTraitMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitMapInclude<ExtArgs> | null
  }


  /**
   * Model RaceAbilityAdjustment
   */

  export type AggregateRaceAbilityAdjustment = {
    _count: RaceAbilityAdjustmentCountAggregateOutputType | null
    _avg: RaceAbilityAdjustmentAvgAggregateOutputType | null
    _sum: RaceAbilityAdjustmentSumAggregateOutputType | null
    _min: RaceAbilityAdjustmentMinAggregateOutputType | null
    _max: RaceAbilityAdjustmentMaxAggregateOutputType | null
  }

  export type RaceAbilityAdjustmentAvgAggregateOutputType = {
    raceId: number | null
    abilityId: number | null
    value: number | null
  }

  export type RaceAbilityAdjustmentSumAggregateOutputType = {
    raceId: number | null
    abilityId: number | null
    value: number | null
  }

  export type RaceAbilityAdjustmentMinAggregateOutputType = {
    raceId: number | null
    abilityId: number | null
    value: number | null
  }

  export type RaceAbilityAdjustmentMaxAggregateOutputType = {
    raceId: number | null
    abilityId: number | null
    value: number | null
  }

  export type RaceAbilityAdjustmentCountAggregateOutputType = {
    raceId: number
    abilityId: number
    value: number
    _all: number
  }


  export type RaceAbilityAdjustmentAvgAggregateInputType = {
    raceId?: true
    abilityId?: true
    value?: true
  }

  export type RaceAbilityAdjustmentSumAggregateInputType = {
    raceId?: true
    abilityId?: true
    value?: true
  }

  export type RaceAbilityAdjustmentMinAggregateInputType = {
    raceId?: true
    abilityId?: true
    value?: true
  }

  export type RaceAbilityAdjustmentMaxAggregateInputType = {
    raceId?: true
    abilityId?: true
    value?: true
  }

  export type RaceAbilityAdjustmentCountAggregateInputType = {
    raceId?: true
    abilityId?: true
    value?: true
    _all?: true
  }

  export type RaceAbilityAdjustmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceAbilityAdjustment to aggregate.
     */
    where?: RaceAbilityAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceAbilityAdjustments to fetch.
     */
    orderBy?: RaceAbilityAdjustmentOrderByWithRelationInput | RaceAbilityAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceAbilityAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceAbilityAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceAbilityAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceAbilityAdjustments
    **/
    _count?: true | RaceAbilityAdjustmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceAbilityAdjustmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceAbilityAdjustmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceAbilityAdjustmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceAbilityAdjustmentMaxAggregateInputType
  }

  export type GetRaceAbilityAdjustmentAggregateType<T extends RaceAbilityAdjustmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceAbilityAdjustment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceAbilityAdjustment[P]>
      : GetScalarType<T[P], AggregateRaceAbilityAdjustment[P]>
  }




  export type RaceAbilityAdjustmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceAbilityAdjustmentWhereInput
    orderBy?: RaceAbilityAdjustmentOrderByWithAggregationInput | RaceAbilityAdjustmentOrderByWithAggregationInput[]
    by: RaceAbilityAdjustmentScalarFieldEnum[] | RaceAbilityAdjustmentScalarFieldEnum
    having?: RaceAbilityAdjustmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceAbilityAdjustmentCountAggregateInputType | true
    _avg?: RaceAbilityAdjustmentAvgAggregateInputType
    _sum?: RaceAbilityAdjustmentSumAggregateInputType
    _min?: RaceAbilityAdjustmentMinAggregateInputType
    _max?: RaceAbilityAdjustmentMaxAggregateInputType
  }

  export type RaceAbilityAdjustmentGroupByOutputType = {
    raceId: number
    abilityId: number
    value: number
    _count: RaceAbilityAdjustmentCountAggregateOutputType | null
    _avg: RaceAbilityAdjustmentAvgAggregateOutputType | null
    _sum: RaceAbilityAdjustmentSumAggregateOutputType | null
    _min: RaceAbilityAdjustmentMinAggregateOutputType | null
    _max: RaceAbilityAdjustmentMaxAggregateOutputType | null
  }

  type GetRaceAbilityAdjustmentGroupByPayload<T extends RaceAbilityAdjustmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceAbilityAdjustmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceAbilityAdjustmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceAbilityAdjustmentGroupByOutputType[P]>
            : GetScalarType<T[P], RaceAbilityAdjustmentGroupByOutputType[P]>
        }
      >
    >


  export type RaceAbilityAdjustmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceId?: boolean
    abilityId?: boolean
    value?: boolean
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceAbilityAdjustment"]>



  export type RaceAbilityAdjustmentSelectScalar = {
    raceId?: boolean
    abilityId?: boolean
    value?: boolean
  }

  export type RaceAbilityAdjustmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"raceId" | "abilityId" | "value", ExtArgs["result"]["raceAbilityAdjustment"]>
  export type RaceAbilityAdjustmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }

  export type $RaceAbilityAdjustmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceAbilityAdjustment"
    objects: {
      race: Prisma.$RacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      raceId: number
      abilityId: number
      value: number
    }, ExtArgs["result"]["raceAbilityAdjustment"]>
    composites: {}
  }

  type RaceAbilityAdjustmentGetPayload<S extends boolean | null | undefined | RaceAbilityAdjustmentDefaultArgs> = $Result.GetResult<Prisma.$RaceAbilityAdjustmentPayload, S>

  type RaceAbilityAdjustmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceAbilityAdjustmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceAbilityAdjustmentCountAggregateInputType | true
    }

  export interface RaceAbilityAdjustmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceAbilityAdjustment'], meta: { name: 'RaceAbilityAdjustment' } }
    /**
     * Find zero or one RaceAbilityAdjustment that matches the filter.
     * @param {RaceAbilityAdjustmentFindUniqueArgs} args - Arguments to find a RaceAbilityAdjustment
     * @example
     * // Get one RaceAbilityAdjustment
     * const raceAbilityAdjustment = await prisma.raceAbilityAdjustment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceAbilityAdjustmentFindUniqueArgs>(args: SelectSubset<T, RaceAbilityAdjustmentFindUniqueArgs<ExtArgs>>): Prisma__RaceAbilityAdjustmentClient<$Result.GetResult<Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaceAbilityAdjustment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceAbilityAdjustmentFindUniqueOrThrowArgs} args - Arguments to find a RaceAbilityAdjustment
     * @example
     * // Get one RaceAbilityAdjustment
     * const raceAbilityAdjustment = await prisma.raceAbilityAdjustment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceAbilityAdjustmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceAbilityAdjustmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceAbilityAdjustmentClient<$Result.GetResult<Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceAbilityAdjustment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAbilityAdjustmentFindFirstArgs} args - Arguments to find a RaceAbilityAdjustment
     * @example
     * // Get one RaceAbilityAdjustment
     * const raceAbilityAdjustment = await prisma.raceAbilityAdjustment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceAbilityAdjustmentFindFirstArgs>(args?: SelectSubset<T, RaceAbilityAdjustmentFindFirstArgs<ExtArgs>>): Prisma__RaceAbilityAdjustmentClient<$Result.GetResult<Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceAbilityAdjustment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAbilityAdjustmentFindFirstOrThrowArgs} args - Arguments to find a RaceAbilityAdjustment
     * @example
     * // Get one RaceAbilityAdjustment
     * const raceAbilityAdjustment = await prisma.raceAbilityAdjustment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceAbilityAdjustmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceAbilityAdjustmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceAbilityAdjustmentClient<$Result.GetResult<Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaceAbilityAdjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAbilityAdjustmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceAbilityAdjustments
     * const raceAbilityAdjustments = await prisma.raceAbilityAdjustment.findMany()
     * 
     * // Get first 10 RaceAbilityAdjustments
     * const raceAbilityAdjustments = await prisma.raceAbilityAdjustment.findMany({ take: 10 })
     * 
     * // Only select the `raceId`
     * const raceAbilityAdjustmentWithRaceIdOnly = await prisma.raceAbilityAdjustment.findMany({ select: { raceId: true } })
     * 
     */
    findMany<T extends RaceAbilityAdjustmentFindManyArgs>(args?: SelectSubset<T, RaceAbilityAdjustmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaceAbilityAdjustment.
     * @param {RaceAbilityAdjustmentCreateArgs} args - Arguments to create a RaceAbilityAdjustment.
     * @example
     * // Create one RaceAbilityAdjustment
     * const RaceAbilityAdjustment = await prisma.raceAbilityAdjustment.create({
     *   data: {
     *     // ... data to create a RaceAbilityAdjustment
     *   }
     * })
     * 
     */
    create<T extends RaceAbilityAdjustmentCreateArgs>(args: SelectSubset<T, RaceAbilityAdjustmentCreateArgs<ExtArgs>>): Prisma__RaceAbilityAdjustmentClient<$Result.GetResult<Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaceAbilityAdjustments.
     * @param {RaceAbilityAdjustmentCreateManyArgs} args - Arguments to create many RaceAbilityAdjustments.
     * @example
     * // Create many RaceAbilityAdjustments
     * const raceAbilityAdjustment = await prisma.raceAbilityAdjustment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceAbilityAdjustmentCreateManyArgs>(args?: SelectSubset<T, RaceAbilityAdjustmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RaceAbilityAdjustment.
     * @param {RaceAbilityAdjustmentDeleteArgs} args - Arguments to delete one RaceAbilityAdjustment.
     * @example
     * // Delete one RaceAbilityAdjustment
     * const RaceAbilityAdjustment = await prisma.raceAbilityAdjustment.delete({
     *   where: {
     *     // ... filter to delete one RaceAbilityAdjustment
     *   }
     * })
     * 
     */
    delete<T extends RaceAbilityAdjustmentDeleteArgs>(args: SelectSubset<T, RaceAbilityAdjustmentDeleteArgs<ExtArgs>>): Prisma__RaceAbilityAdjustmentClient<$Result.GetResult<Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaceAbilityAdjustment.
     * @param {RaceAbilityAdjustmentUpdateArgs} args - Arguments to update one RaceAbilityAdjustment.
     * @example
     * // Update one RaceAbilityAdjustment
     * const raceAbilityAdjustment = await prisma.raceAbilityAdjustment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceAbilityAdjustmentUpdateArgs>(args: SelectSubset<T, RaceAbilityAdjustmentUpdateArgs<ExtArgs>>): Prisma__RaceAbilityAdjustmentClient<$Result.GetResult<Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaceAbilityAdjustments.
     * @param {RaceAbilityAdjustmentDeleteManyArgs} args - Arguments to filter RaceAbilityAdjustments to delete.
     * @example
     * // Delete a few RaceAbilityAdjustments
     * const { count } = await prisma.raceAbilityAdjustment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceAbilityAdjustmentDeleteManyArgs>(args?: SelectSubset<T, RaceAbilityAdjustmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceAbilityAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAbilityAdjustmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceAbilityAdjustments
     * const raceAbilityAdjustment = await prisma.raceAbilityAdjustment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceAbilityAdjustmentUpdateManyArgs>(args: SelectSubset<T, RaceAbilityAdjustmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RaceAbilityAdjustment.
     * @param {RaceAbilityAdjustmentUpsertArgs} args - Arguments to update or create a RaceAbilityAdjustment.
     * @example
     * // Update or create a RaceAbilityAdjustment
     * const raceAbilityAdjustment = await prisma.raceAbilityAdjustment.upsert({
     *   create: {
     *     // ... data to create a RaceAbilityAdjustment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceAbilityAdjustment we want to update
     *   }
     * })
     */
    upsert<T extends RaceAbilityAdjustmentUpsertArgs>(args: SelectSubset<T, RaceAbilityAdjustmentUpsertArgs<ExtArgs>>): Prisma__RaceAbilityAdjustmentClient<$Result.GetResult<Prisma.$RaceAbilityAdjustmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaceAbilityAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAbilityAdjustmentCountArgs} args - Arguments to filter RaceAbilityAdjustments to count.
     * @example
     * // Count the number of RaceAbilityAdjustments
     * const count = await prisma.raceAbilityAdjustment.count({
     *   where: {
     *     // ... the filter for the RaceAbilityAdjustments we want to count
     *   }
     * })
    **/
    count<T extends RaceAbilityAdjustmentCountArgs>(
      args?: Subset<T, RaceAbilityAdjustmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceAbilityAdjustmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceAbilityAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAbilityAdjustmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceAbilityAdjustmentAggregateArgs>(args: Subset<T, RaceAbilityAdjustmentAggregateArgs>): Prisma.PrismaPromise<GetRaceAbilityAdjustmentAggregateType<T>>

    /**
     * Group by RaceAbilityAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAbilityAdjustmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceAbilityAdjustmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceAbilityAdjustmentGroupByArgs['orderBy'] }
        : { orderBy?: RaceAbilityAdjustmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceAbilityAdjustmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceAbilityAdjustmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceAbilityAdjustment model
   */
  readonly fields: RaceAbilityAdjustmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceAbilityAdjustment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceAbilityAdjustmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaceAbilityAdjustment model
   */
  interface RaceAbilityAdjustmentFieldRefs {
    readonly raceId: FieldRef<"RaceAbilityAdjustment", 'Int'>
    readonly abilityId: FieldRef<"RaceAbilityAdjustment", 'Int'>
    readonly value: FieldRef<"RaceAbilityAdjustment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RaceAbilityAdjustment findUnique
   */
  export type RaceAbilityAdjustmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceAbilityAdjustment
     */
    select?: RaceAbilityAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceAbilityAdjustment
     */
    omit?: RaceAbilityAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceAbilityAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which RaceAbilityAdjustment to fetch.
     */
    where: RaceAbilityAdjustmentWhereUniqueInput
  }

  /**
   * RaceAbilityAdjustment findUniqueOrThrow
   */
  export type RaceAbilityAdjustmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceAbilityAdjustment
     */
    select?: RaceAbilityAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceAbilityAdjustment
     */
    omit?: RaceAbilityAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceAbilityAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which RaceAbilityAdjustment to fetch.
     */
    where: RaceAbilityAdjustmentWhereUniqueInput
  }

  /**
   * RaceAbilityAdjustment findFirst
   */
  export type RaceAbilityAdjustmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceAbilityAdjustment
     */
    select?: RaceAbilityAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceAbilityAdjustment
     */
    omit?: RaceAbilityAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceAbilityAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which RaceAbilityAdjustment to fetch.
     */
    where?: RaceAbilityAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceAbilityAdjustments to fetch.
     */
    orderBy?: RaceAbilityAdjustmentOrderByWithRelationInput | RaceAbilityAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceAbilityAdjustments.
     */
    cursor?: RaceAbilityAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceAbilityAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceAbilityAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceAbilityAdjustments.
     */
    distinct?: RaceAbilityAdjustmentScalarFieldEnum | RaceAbilityAdjustmentScalarFieldEnum[]
  }

  /**
   * RaceAbilityAdjustment findFirstOrThrow
   */
  export type RaceAbilityAdjustmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceAbilityAdjustment
     */
    select?: RaceAbilityAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceAbilityAdjustment
     */
    omit?: RaceAbilityAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceAbilityAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which RaceAbilityAdjustment to fetch.
     */
    where?: RaceAbilityAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceAbilityAdjustments to fetch.
     */
    orderBy?: RaceAbilityAdjustmentOrderByWithRelationInput | RaceAbilityAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceAbilityAdjustments.
     */
    cursor?: RaceAbilityAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceAbilityAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceAbilityAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceAbilityAdjustments.
     */
    distinct?: RaceAbilityAdjustmentScalarFieldEnum | RaceAbilityAdjustmentScalarFieldEnum[]
  }

  /**
   * RaceAbilityAdjustment findMany
   */
  export type RaceAbilityAdjustmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceAbilityAdjustment
     */
    select?: RaceAbilityAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceAbilityAdjustment
     */
    omit?: RaceAbilityAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceAbilityAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which RaceAbilityAdjustments to fetch.
     */
    where?: RaceAbilityAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceAbilityAdjustments to fetch.
     */
    orderBy?: RaceAbilityAdjustmentOrderByWithRelationInput | RaceAbilityAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceAbilityAdjustments.
     */
    cursor?: RaceAbilityAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceAbilityAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceAbilityAdjustments.
     */
    skip?: number
    distinct?: RaceAbilityAdjustmentScalarFieldEnum | RaceAbilityAdjustmentScalarFieldEnum[]
  }

  /**
   * RaceAbilityAdjustment create
   */
  export type RaceAbilityAdjustmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceAbilityAdjustment
     */
    select?: RaceAbilityAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceAbilityAdjustment
     */
    omit?: RaceAbilityAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceAbilityAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceAbilityAdjustment.
     */
    data: XOR<RaceAbilityAdjustmentCreateInput, RaceAbilityAdjustmentUncheckedCreateInput>
  }

  /**
   * RaceAbilityAdjustment createMany
   */
  export type RaceAbilityAdjustmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceAbilityAdjustments.
     */
    data: RaceAbilityAdjustmentCreateManyInput | RaceAbilityAdjustmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaceAbilityAdjustment update
   */
  export type RaceAbilityAdjustmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceAbilityAdjustment
     */
    select?: RaceAbilityAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceAbilityAdjustment
     */
    omit?: RaceAbilityAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceAbilityAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceAbilityAdjustment.
     */
    data: XOR<RaceAbilityAdjustmentUpdateInput, RaceAbilityAdjustmentUncheckedUpdateInput>
    /**
     * Choose, which RaceAbilityAdjustment to update.
     */
    where: RaceAbilityAdjustmentWhereUniqueInput
  }

  /**
   * RaceAbilityAdjustment updateMany
   */
  export type RaceAbilityAdjustmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceAbilityAdjustments.
     */
    data: XOR<RaceAbilityAdjustmentUpdateManyMutationInput, RaceAbilityAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which RaceAbilityAdjustments to update
     */
    where?: RaceAbilityAdjustmentWhereInput
    /**
     * Limit how many RaceAbilityAdjustments to update.
     */
    limit?: number
  }

  /**
   * RaceAbilityAdjustment upsert
   */
  export type RaceAbilityAdjustmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceAbilityAdjustment
     */
    select?: RaceAbilityAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceAbilityAdjustment
     */
    omit?: RaceAbilityAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceAbilityAdjustmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceAbilityAdjustment to update in case it exists.
     */
    where: RaceAbilityAdjustmentWhereUniqueInput
    /**
     * In case the RaceAbilityAdjustment found by the `where` argument doesn't exist, create a new RaceAbilityAdjustment with this data.
     */
    create: XOR<RaceAbilityAdjustmentCreateInput, RaceAbilityAdjustmentUncheckedCreateInput>
    /**
     * In case the RaceAbilityAdjustment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceAbilityAdjustmentUpdateInput, RaceAbilityAdjustmentUncheckedUpdateInput>
  }

  /**
   * RaceAbilityAdjustment delete
   */
  export type RaceAbilityAdjustmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceAbilityAdjustment
     */
    select?: RaceAbilityAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceAbilityAdjustment
     */
    omit?: RaceAbilityAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceAbilityAdjustmentInclude<ExtArgs> | null
    /**
     * Filter which RaceAbilityAdjustment to delete.
     */
    where: RaceAbilityAdjustmentWhereUniqueInput
  }

  /**
   * RaceAbilityAdjustment deleteMany
   */
  export type RaceAbilityAdjustmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceAbilityAdjustments to delete
     */
    where?: RaceAbilityAdjustmentWhereInput
    /**
     * Limit how many RaceAbilityAdjustments to delete.
     */
    limit?: number
  }

  /**
   * RaceAbilityAdjustment without action
   */
  export type RaceAbilityAdjustmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceAbilityAdjustment
     */
    select?: RaceAbilityAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceAbilityAdjustment
     */
    omit?: RaceAbilityAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceAbilityAdjustmentInclude<ExtArgs> | null
  }


  /**
   * Model RaceLanguageMap
   */

  export type AggregateRaceLanguageMap = {
    _count: RaceLanguageMapCountAggregateOutputType | null
    _avg: RaceLanguageMapAvgAggregateOutputType | null
    _sum: RaceLanguageMapSumAggregateOutputType | null
    _min: RaceLanguageMapMinAggregateOutputType | null
    _max: RaceLanguageMapMaxAggregateOutputType | null
  }

  export type RaceLanguageMapAvgAggregateOutputType = {
    raceId: number | null
    languageId: number | null
  }

  export type RaceLanguageMapSumAggregateOutputType = {
    raceId: number | null
    languageId: number | null
  }

  export type RaceLanguageMapMinAggregateOutputType = {
    raceId: number | null
    languageId: number | null
    isAutomatic: boolean | null
  }

  export type RaceLanguageMapMaxAggregateOutputType = {
    raceId: number | null
    languageId: number | null
    isAutomatic: boolean | null
  }

  export type RaceLanguageMapCountAggregateOutputType = {
    raceId: number
    languageId: number
    isAutomatic: number
    _all: number
  }


  export type RaceLanguageMapAvgAggregateInputType = {
    raceId?: true
    languageId?: true
  }

  export type RaceLanguageMapSumAggregateInputType = {
    raceId?: true
    languageId?: true
  }

  export type RaceLanguageMapMinAggregateInputType = {
    raceId?: true
    languageId?: true
    isAutomatic?: true
  }

  export type RaceLanguageMapMaxAggregateInputType = {
    raceId?: true
    languageId?: true
    isAutomatic?: true
  }

  export type RaceLanguageMapCountAggregateInputType = {
    raceId?: true
    languageId?: true
    isAutomatic?: true
    _all?: true
  }

  export type RaceLanguageMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceLanguageMap to aggregate.
     */
    where?: RaceLanguageMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceLanguageMaps to fetch.
     */
    orderBy?: RaceLanguageMapOrderByWithRelationInput | RaceLanguageMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceLanguageMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceLanguageMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceLanguageMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceLanguageMaps
    **/
    _count?: true | RaceLanguageMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceLanguageMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceLanguageMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceLanguageMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceLanguageMapMaxAggregateInputType
  }

  export type GetRaceLanguageMapAggregateType<T extends RaceLanguageMapAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceLanguageMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceLanguageMap[P]>
      : GetScalarType<T[P], AggregateRaceLanguageMap[P]>
  }




  export type RaceLanguageMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceLanguageMapWhereInput
    orderBy?: RaceLanguageMapOrderByWithAggregationInput | RaceLanguageMapOrderByWithAggregationInput[]
    by: RaceLanguageMapScalarFieldEnum[] | RaceLanguageMapScalarFieldEnum
    having?: RaceLanguageMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceLanguageMapCountAggregateInputType | true
    _avg?: RaceLanguageMapAvgAggregateInputType
    _sum?: RaceLanguageMapSumAggregateInputType
    _min?: RaceLanguageMapMinAggregateInputType
    _max?: RaceLanguageMapMaxAggregateInputType
  }

  export type RaceLanguageMapGroupByOutputType = {
    raceId: number
    languageId: number
    isAutomatic: boolean
    _count: RaceLanguageMapCountAggregateOutputType | null
    _avg: RaceLanguageMapAvgAggregateOutputType | null
    _sum: RaceLanguageMapSumAggregateOutputType | null
    _min: RaceLanguageMapMinAggregateOutputType | null
    _max: RaceLanguageMapMaxAggregateOutputType | null
  }

  type GetRaceLanguageMapGroupByPayload<T extends RaceLanguageMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceLanguageMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceLanguageMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceLanguageMapGroupByOutputType[P]>
            : GetScalarType<T[P], RaceLanguageMapGroupByOutputType[P]>
        }
      >
    >


  export type RaceLanguageMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceId?: boolean
    languageId?: boolean
    isAutomatic?: boolean
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceLanguageMap"]>



  export type RaceLanguageMapSelectScalar = {
    raceId?: boolean
    languageId?: boolean
    isAutomatic?: boolean
  }

  export type RaceLanguageMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"raceId" | "languageId" | "isAutomatic", ExtArgs["result"]["raceLanguageMap"]>
  export type RaceLanguageMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }

  export type $RaceLanguageMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceLanguageMap"
    objects: {
      race: Prisma.$RacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      raceId: number
      languageId: number
      isAutomatic: boolean
    }, ExtArgs["result"]["raceLanguageMap"]>
    composites: {}
  }

  type RaceLanguageMapGetPayload<S extends boolean | null | undefined | RaceLanguageMapDefaultArgs> = $Result.GetResult<Prisma.$RaceLanguageMapPayload, S>

  type RaceLanguageMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceLanguageMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceLanguageMapCountAggregateInputType | true
    }

  export interface RaceLanguageMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceLanguageMap'], meta: { name: 'RaceLanguageMap' } }
    /**
     * Find zero or one RaceLanguageMap that matches the filter.
     * @param {RaceLanguageMapFindUniqueArgs} args - Arguments to find a RaceLanguageMap
     * @example
     * // Get one RaceLanguageMap
     * const raceLanguageMap = await prisma.raceLanguageMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceLanguageMapFindUniqueArgs>(args: SelectSubset<T, RaceLanguageMapFindUniqueArgs<ExtArgs>>): Prisma__RaceLanguageMapClient<$Result.GetResult<Prisma.$RaceLanguageMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaceLanguageMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceLanguageMapFindUniqueOrThrowArgs} args - Arguments to find a RaceLanguageMap
     * @example
     * // Get one RaceLanguageMap
     * const raceLanguageMap = await prisma.raceLanguageMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceLanguageMapFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceLanguageMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceLanguageMapClient<$Result.GetResult<Prisma.$RaceLanguageMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceLanguageMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceLanguageMapFindFirstArgs} args - Arguments to find a RaceLanguageMap
     * @example
     * // Get one RaceLanguageMap
     * const raceLanguageMap = await prisma.raceLanguageMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceLanguageMapFindFirstArgs>(args?: SelectSubset<T, RaceLanguageMapFindFirstArgs<ExtArgs>>): Prisma__RaceLanguageMapClient<$Result.GetResult<Prisma.$RaceLanguageMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceLanguageMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceLanguageMapFindFirstOrThrowArgs} args - Arguments to find a RaceLanguageMap
     * @example
     * // Get one RaceLanguageMap
     * const raceLanguageMap = await prisma.raceLanguageMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceLanguageMapFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceLanguageMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceLanguageMapClient<$Result.GetResult<Prisma.$RaceLanguageMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaceLanguageMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceLanguageMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceLanguageMaps
     * const raceLanguageMaps = await prisma.raceLanguageMap.findMany()
     * 
     * // Get first 10 RaceLanguageMaps
     * const raceLanguageMaps = await prisma.raceLanguageMap.findMany({ take: 10 })
     * 
     * // Only select the `raceId`
     * const raceLanguageMapWithRaceIdOnly = await prisma.raceLanguageMap.findMany({ select: { raceId: true } })
     * 
     */
    findMany<T extends RaceLanguageMapFindManyArgs>(args?: SelectSubset<T, RaceLanguageMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceLanguageMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaceLanguageMap.
     * @param {RaceLanguageMapCreateArgs} args - Arguments to create a RaceLanguageMap.
     * @example
     * // Create one RaceLanguageMap
     * const RaceLanguageMap = await prisma.raceLanguageMap.create({
     *   data: {
     *     // ... data to create a RaceLanguageMap
     *   }
     * })
     * 
     */
    create<T extends RaceLanguageMapCreateArgs>(args: SelectSubset<T, RaceLanguageMapCreateArgs<ExtArgs>>): Prisma__RaceLanguageMapClient<$Result.GetResult<Prisma.$RaceLanguageMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaceLanguageMaps.
     * @param {RaceLanguageMapCreateManyArgs} args - Arguments to create many RaceLanguageMaps.
     * @example
     * // Create many RaceLanguageMaps
     * const raceLanguageMap = await prisma.raceLanguageMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceLanguageMapCreateManyArgs>(args?: SelectSubset<T, RaceLanguageMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RaceLanguageMap.
     * @param {RaceLanguageMapDeleteArgs} args - Arguments to delete one RaceLanguageMap.
     * @example
     * // Delete one RaceLanguageMap
     * const RaceLanguageMap = await prisma.raceLanguageMap.delete({
     *   where: {
     *     // ... filter to delete one RaceLanguageMap
     *   }
     * })
     * 
     */
    delete<T extends RaceLanguageMapDeleteArgs>(args: SelectSubset<T, RaceLanguageMapDeleteArgs<ExtArgs>>): Prisma__RaceLanguageMapClient<$Result.GetResult<Prisma.$RaceLanguageMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaceLanguageMap.
     * @param {RaceLanguageMapUpdateArgs} args - Arguments to update one RaceLanguageMap.
     * @example
     * // Update one RaceLanguageMap
     * const raceLanguageMap = await prisma.raceLanguageMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceLanguageMapUpdateArgs>(args: SelectSubset<T, RaceLanguageMapUpdateArgs<ExtArgs>>): Prisma__RaceLanguageMapClient<$Result.GetResult<Prisma.$RaceLanguageMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaceLanguageMaps.
     * @param {RaceLanguageMapDeleteManyArgs} args - Arguments to filter RaceLanguageMaps to delete.
     * @example
     * // Delete a few RaceLanguageMaps
     * const { count } = await prisma.raceLanguageMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceLanguageMapDeleteManyArgs>(args?: SelectSubset<T, RaceLanguageMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceLanguageMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceLanguageMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceLanguageMaps
     * const raceLanguageMap = await prisma.raceLanguageMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceLanguageMapUpdateManyArgs>(args: SelectSubset<T, RaceLanguageMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RaceLanguageMap.
     * @param {RaceLanguageMapUpsertArgs} args - Arguments to update or create a RaceLanguageMap.
     * @example
     * // Update or create a RaceLanguageMap
     * const raceLanguageMap = await prisma.raceLanguageMap.upsert({
     *   create: {
     *     // ... data to create a RaceLanguageMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceLanguageMap we want to update
     *   }
     * })
     */
    upsert<T extends RaceLanguageMapUpsertArgs>(args: SelectSubset<T, RaceLanguageMapUpsertArgs<ExtArgs>>): Prisma__RaceLanguageMapClient<$Result.GetResult<Prisma.$RaceLanguageMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaceLanguageMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceLanguageMapCountArgs} args - Arguments to filter RaceLanguageMaps to count.
     * @example
     * // Count the number of RaceLanguageMaps
     * const count = await prisma.raceLanguageMap.count({
     *   where: {
     *     // ... the filter for the RaceLanguageMaps we want to count
     *   }
     * })
    **/
    count<T extends RaceLanguageMapCountArgs>(
      args?: Subset<T, RaceLanguageMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceLanguageMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceLanguageMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceLanguageMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceLanguageMapAggregateArgs>(args: Subset<T, RaceLanguageMapAggregateArgs>): Prisma.PrismaPromise<GetRaceLanguageMapAggregateType<T>>

    /**
     * Group by RaceLanguageMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceLanguageMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceLanguageMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceLanguageMapGroupByArgs['orderBy'] }
        : { orderBy?: RaceLanguageMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceLanguageMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceLanguageMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceLanguageMap model
   */
  readonly fields: RaceLanguageMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceLanguageMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceLanguageMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaceLanguageMap model
   */
  interface RaceLanguageMapFieldRefs {
    readonly raceId: FieldRef<"RaceLanguageMap", 'Int'>
    readonly languageId: FieldRef<"RaceLanguageMap", 'Int'>
    readonly isAutomatic: FieldRef<"RaceLanguageMap", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RaceLanguageMap findUnique
   */
  export type RaceLanguageMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceLanguageMap
     */
    select?: RaceLanguageMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceLanguageMap
     */
    omit?: RaceLanguageMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceLanguageMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceLanguageMap to fetch.
     */
    where: RaceLanguageMapWhereUniqueInput
  }

  /**
   * RaceLanguageMap findUniqueOrThrow
   */
  export type RaceLanguageMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceLanguageMap
     */
    select?: RaceLanguageMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceLanguageMap
     */
    omit?: RaceLanguageMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceLanguageMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceLanguageMap to fetch.
     */
    where: RaceLanguageMapWhereUniqueInput
  }

  /**
   * RaceLanguageMap findFirst
   */
  export type RaceLanguageMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceLanguageMap
     */
    select?: RaceLanguageMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceLanguageMap
     */
    omit?: RaceLanguageMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceLanguageMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceLanguageMap to fetch.
     */
    where?: RaceLanguageMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceLanguageMaps to fetch.
     */
    orderBy?: RaceLanguageMapOrderByWithRelationInput | RaceLanguageMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceLanguageMaps.
     */
    cursor?: RaceLanguageMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceLanguageMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceLanguageMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceLanguageMaps.
     */
    distinct?: RaceLanguageMapScalarFieldEnum | RaceLanguageMapScalarFieldEnum[]
  }

  /**
   * RaceLanguageMap findFirstOrThrow
   */
  export type RaceLanguageMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceLanguageMap
     */
    select?: RaceLanguageMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceLanguageMap
     */
    omit?: RaceLanguageMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceLanguageMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceLanguageMap to fetch.
     */
    where?: RaceLanguageMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceLanguageMaps to fetch.
     */
    orderBy?: RaceLanguageMapOrderByWithRelationInput | RaceLanguageMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceLanguageMaps.
     */
    cursor?: RaceLanguageMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceLanguageMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceLanguageMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceLanguageMaps.
     */
    distinct?: RaceLanguageMapScalarFieldEnum | RaceLanguageMapScalarFieldEnum[]
  }

  /**
   * RaceLanguageMap findMany
   */
  export type RaceLanguageMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceLanguageMap
     */
    select?: RaceLanguageMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceLanguageMap
     */
    omit?: RaceLanguageMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceLanguageMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceLanguageMaps to fetch.
     */
    where?: RaceLanguageMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceLanguageMaps to fetch.
     */
    orderBy?: RaceLanguageMapOrderByWithRelationInput | RaceLanguageMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceLanguageMaps.
     */
    cursor?: RaceLanguageMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceLanguageMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceLanguageMaps.
     */
    skip?: number
    distinct?: RaceLanguageMapScalarFieldEnum | RaceLanguageMapScalarFieldEnum[]
  }

  /**
   * RaceLanguageMap create
   */
  export type RaceLanguageMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceLanguageMap
     */
    select?: RaceLanguageMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceLanguageMap
     */
    omit?: RaceLanguageMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceLanguageMapInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceLanguageMap.
     */
    data: XOR<RaceLanguageMapCreateInput, RaceLanguageMapUncheckedCreateInput>
  }

  /**
   * RaceLanguageMap createMany
   */
  export type RaceLanguageMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceLanguageMaps.
     */
    data: RaceLanguageMapCreateManyInput | RaceLanguageMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaceLanguageMap update
   */
  export type RaceLanguageMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceLanguageMap
     */
    select?: RaceLanguageMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceLanguageMap
     */
    omit?: RaceLanguageMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceLanguageMapInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceLanguageMap.
     */
    data: XOR<RaceLanguageMapUpdateInput, RaceLanguageMapUncheckedUpdateInput>
    /**
     * Choose, which RaceLanguageMap to update.
     */
    where: RaceLanguageMapWhereUniqueInput
  }

  /**
   * RaceLanguageMap updateMany
   */
  export type RaceLanguageMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceLanguageMaps.
     */
    data: XOR<RaceLanguageMapUpdateManyMutationInput, RaceLanguageMapUncheckedUpdateManyInput>
    /**
     * Filter which RaceLanguageMaps to update
     */
    where?: RaceLanguageMapWhereInput
    /**
     * Limit how many RaceLanguageMaps to update.
     */
    limit?: number
  }

  /**
   * RaceLanguageMap upsert
   */
  export type RaceLanguageMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceLanguageMap
     */
    select?: RaceLanguageMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceLanguageMap
     */
    omit?: RaceLanguageMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceLanguageMapInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceLanguageMap to update in case it exists.
     */
    where: RaceLanguageMapWhereUniqueInput
    /**
     * In case the RaceLanguageMap found by the `where` argument doesn't exist, create a new RaceLanguageMap with this data.
     */
    create: XOR<RaceLanguageMapCreateInput, RaceLanguageMapUncheckedCreateInput>
    /**
     * In case the RaceLanguageMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceLanguageMapUpdateInput, RaceLanguageMapUncheckedUpdateInput>
  }

  /**
   * RaceLanguageMap delete
   */
  export type RaceLanguageMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceLanguageMap
     */
    select?: RaceLanguageMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceLanguageMap
     */
    omit?: RaceLanguageMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceLanguageMapInclude<ExtArgs> | null
    /**
     * Filter which RaceLanguageMap to delete.
     */
    where: RaceLanguageMapWhereUniqueInput
  }

  /**
   * RaceLanguageMap deleteMany
   */
  export type RaceLanguageMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceLanguageMaps to delete
     */
    where?: RaceLanguageMapWhereInput
    /**
     * Limit how many RaceLanguageMaps to delete.
     */
    limit?: number
  }

  /**
   * RaceLanguageMap without action
   */
  export type RaceLanguageMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceLanguageMap
     */
    select?: RaceLanguageMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceLanguageMap
     */
    omit?: RaceLanguageMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceLanguageMapInclude<ExtArgs> | null
  }


  /**
   * Model RaceSourceMap
   */

  export type AggregateRaceSourceMap = {
    _count: RaceSourceMapCountAggregateOutputType | null
    _avg: RaceSourceMapAvgAggregateOutputType | null
    _sum: RaceSourceMapSumAggregateOutputType | null
    _min: RaceSourceMapMinAggregateOutputType | null
    _max: RaceSourceMapMaxAggregateOutputType | null
  }

  export type RaceSourceMapAvgAggregateOutputType = {
    id: number | null
    raceId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type RaceSourceMapSumAggregateOutputType = {
    id: number | null
    raceId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type RaceSourceMapMinAggregateOutputType = {
    id: number | null
    raceId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type RaceSourceMapMaxAggregateOutputType = {
    id: number | null
    raceId: number | null
    bookId: number | null
    pageNumber: number | null
    sourceBookId: number | null
  }

  export type RaceSourceMapCountAggregateOutputType = {
    id: number
    raceId: number
    bookId: number
    pageNumber: number
    sourceBookId: number
    _all: number
  }


  export type RaceSourceMapAvgAggregateInputType = {
    id?: true
    raceId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type RaceSourceMapSumAggregateInputType = {
    id?: true
    raceId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type RaceSourceMapMinAggregateInputType = {
    id?: true
    raceId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type RaceSourceMapMaxAggregateInputType = {
    id?: true
    raceId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
  }

  export type RaceSourceMapCountAggregateInputType = {
    id?: true
    raceId?: true
    bookId?: true
    pageNumber?: true
    sourceBookId?: true
    _all?: true
  }

  export type RaceSourceMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceSourceMap to aggregate.
     */
    where?: RaceSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceSourceMaps to fetch.
     */
    orderBy?: RaceSourceMapOrderByWithRelationInput | RaceSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceSourceMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceSourceMaps
    **/
    _count?: true | RaceSourceMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceSourceMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceSourceMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceSourceMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceSourceMapMaxAggregateInputType
  }

  export type GetRaceSourceMapAggregateType<T extends RaceSourceMapAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceSourceMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceSourceMap[P]>
      : GetScalarType<T[P], AggregateRaceSourceMap[P]>
  }




  export type RaceSourceMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceSourceMapWhereInput
    orderBy?: RaceSourceMapOrderByWithAggregationInput | RaceSourceMapOrderByWithAggregationInput[]
    by: RaceSourceMapScalarFieldEnum[] | RaceSourceMapScalarFieldEnum
    having?: RaceSourceMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceSourceMapCountAggregateInputType | true
    _avg?: RaceSourceMapAvgAggregateInputType
    _sum?: RaceSourceMapSumAggregateInputType
    _min?: RaceSourceMapMinAggregateInputType
    _max?: RaceSourceMapMaxAggregateInputType
  }

  export type RaceSourceMapGroupByOutputType = {
    id: number
    raceId: number
    bookId: number
    pageNumber: number | null
    sourceBookId: number | null
    _count: RaceSourceMapCountAggregateOutputType | null
    _avg: RaceSourceMapAvgAggregateOutputType | null
    _sum: RaceSourceMapSumAggregateOutputType | null
    _min: RaceSourceMapMinAggregateOutputType | null
    _max: RaceSourceMapMaxAggregateOutputType | null
  }

  type GetRaceSourceMapGroupByPayload<T extends RaceSourceMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceSourceMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceSourceMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceSourceMapGroupByOutputType[P]>
            : GetScalarType<T[P], RaceSourceMapGroupByOutputType[P]>
        }
      >
    >


  export type RaceSourceMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raceId?: boolean
    bookId?: boolean
    pageNumber?: boolean
    sourceBookId?: boolean
    Race?: boolean | RaceDefaultArgs<ExtArgs>
    SourceBook?: boolean | RaceSourceMap$SourceBookArgs<ExtArgs>
  }, ExtArgs["result"]["raceSourceMap"]>



  export type RaceSourceMapSelectScalar = {
    id?: boolean
    raceId?: boolean
    bookId?: boolean
    pageNumber?: boolean
    sourceBookId?: boolean
  }

  export type RaceSourceMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "raceId" | "bookId" | "pageNumber" | "sourceBookId", ExtArgs["result"]["raceSourceMap"]>
  export type RaceSourceMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Race?: boolean | RaceDefaultArgs<ExtArgs>
    SourceBook?: boolean | RaceSourceMap$SourceBookArgs<ExtArgs>
  }

  export type $RaceSourceMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceSourceMap"
    objects: {
      Race: Prisma.$RacePayload<ExtArgs>
      SourceBook: Prisma.$SourceBookPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      raceId: number
      bookId: number
      pageNumber: number | null
      sourceBookId: number | null
    }, ExtArgs["result"]["raceSourceMap"]>
    composites: {}
  }

  type RaceSourceMapGetPayload<S extends boolean | null | undefined | RaceSourceMapDefaultArgs> = $Result.GetResult<Prisma.$RaceSourceMapPayload, S>

  type RaceSourceMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceSourceMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceSourceMapCountAggregateInputType | true
    }

  export interface RaceSourceMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceSourceMap'], meta: { name: 'RaceSourceMap' } }
    /**
     * Find zero or one RaceSourceMap that matches the filter.
     * @param {RaceSourceMapFindUniqueArgs} args - Arguments to find a RaceSourceMap
     * @example
     * // Get one RaceSourceMap
     * const raceSourceMap = await prisma.raceSourceMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceSourceMapFindUniqueArgs>(args: SelectSubset<T, RaceSourceMapFindUniqueArgs<ExtArgs>>): Prisma__RaceSourceMapClient<$Result.GetResult<Prisma.$RaceSourceMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaceSourceMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceSourceMapFindUniqueOrThrowArgs} args - Arguments to find a RaceSourceMap
     * @example
     * // Get one RaceSourceMap
     * const raceSourceMap = await prisma.raceSourceMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceSourceMapFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceSourceMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceSourceMapClient<$Result.GetResult<Prisma.$RaceSourceMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceSourceMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSourceMapFindFirstArgs} args - Arguments to find a RaceSourceMap
     * @example
     * // Get one RaceSourceMap
     * const raceSourceMap = await prisma.raceSourceMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceSourceMapFindFirstArgs>(args?: SelectSubset<T, RaceSourceMapFindFirstArgs<ExtArgs>>): Prisma__RaceSourceMapClient<$Result.GetResult<Prisma.$RaceSourceMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceSourceMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSourceMapFindFirstOrThrowArgs} args - Arguments to find a RaceSourceMap
     * @example
     * // Get one RaceSourceMap
     * const raceSourceMap = await prisma.raceSourceMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceSourceMapFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceSourceMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceSourceMapClient<$Result.GetResult<Prisma.$RaceSourceMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaceSourceMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSourceMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceSourceMaps
     * const raceSourceMaps = await prisma.raceSourceMap.findMany()
     * 
     * // Get first 10 RaceSourceMaps
     * const raceSourceMaps = await prisma.raceSourceMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raceSourceMapWithIdOnly = await prisma.raceSourceMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaceSourceMapFindManyArgs>(args?: SelectSubset<T, RaceSourceMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceSourceMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaceSourceMap.
     * @param {RaceSourceMapCreateArgs} args - Arguments to create a RaceSourceMap.
     * @example
     * // Create one RaceSourceMap
     * const RaceSourceMap = await prisma.raceSourceMap.create({
     *   data: {
     *     // ... data to create a RaceSourceMap
     *   }
     * })
     * 
     */
    create<T extends RaceSourceMapCreateArgs>(args: SelectSubset<T, RaceSourceMapCreateArgs<ExtArgs>>): Prisma__RaceSourceMapClient<$Result.GetResult<Prisma.$RaceSourceMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaceSourceMaps.
     * @param {RaceSourceMapCreateManyArgs} args - Arguments to create many RaceSourceMaps.
     * @example
     * // Create many RaceSourceMaps
     * const raceSourceMap = await prisma.raceSourceMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceSourceMapCreateManyArgs>(args?: SelectSubset<T, RaceSourceMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RaceSourceMap.
     * @param {RaceSourceMapDeleteArgs} args - Arguments to delete one RaceSourceMap.
     * @example
     * // Delete one RaceSourceMap
     * const RaceSourceMap = await prisma.raceSourceMap.delete({
     *   where: {
     *     // ... filter to delete one RaceSourceMap
     *   }
     * })
     * 
     */
    delete<T extends RaceSourceMapDeleteArgs>(args: SelectSubset<T, RaceSourceMapDeleteArgs<ExtArgs>>): Prisma__RaceSourceMapClient<$Result.GetResult<Prisma.$RaceSourceMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaceSourceMap.
     * @param {RaceSourceMapUpdateArgs} args - Arguments to update one RaceSourceMap.
     * @example
     * // Update one RaceSourceMap
     * const raceSourceMap = await prisma.raceSourceMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceSourceMapUpdateArgs>(args: SelectSubset<T, RaceSourceMapUpdateArgs<ExtArgs>>): Prisma__RaceSourceMapClient<$Result.GetResult<Prisma.$RaceSourceMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaceSourceMaps.
     * @param {RaceSourceMapDeleteManyArgs} args - Arguments to filter RaceSourceMaps to delete.
     * @example
     * // Delete a few RaceSourceMaps
     * const { count } = await prisma.raceSourceMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceSourceMapDeleteManyArgs>(args?: SelectSubset<T, RaceSourceMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceSourceMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSourceMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceSourceMaps
     * const raceSourceMap = await prisma.raceSourceMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceSourceMapUpdateManyArgs>(args: SelectSubset<T, RaceSourceMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RaceSourceMap.
     * @param {RaceSourceMapUpsertArgs} args - Arguments to update or create a RaceSourceMap.
     * @example
     * // Update or create a RaceSourceMap
     * const raceSourceMap = await prisma.raceSourceMap.upsert({
     *   create: {
     *     // ... data to create a RaceSourceMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceSourceMap we want to update
     *   }
     * })
     */
    upsert<T extends RaceSourceMapUpsertArgs>(args: SelectSubset<T, RaceSourceMapUpsertArgs<ExtArgs>>): Prisma__RaceSourceMapClient<$Result.GetResult<Prisma.$RaceSourceMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaceSourceMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSourceMapCountArgs} args - Arguments to filter RaceSourceMaps to count.
     * @example
     * // Count the number of RaceSourceMaps
     * const count = await prisma.raceSourceMap.count({
     *   where: {
     *     // ... the filter for the RaceSourceMaps we want to count
     *   }
     * })
    **/
    count<T extends RaceSourceMapCountArgs>(
      args?: Subset<T, RaceSourceMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceSourceMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceSourceMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSourceMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceSourceMapAggregateArgs>(args: Subset<T, RaceSourceMapAggregateArgs>): Prisma.PrismaPromise<GetRaceSourceMapAggregateType<T>>

    /**
     * Group by RaceSourceMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSourceMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceSourceMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceSourceMapGroupByArgs['orderBy'] }
        : { orderBy?: RaceSourceMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceSourceMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceSourceMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceSourceMap model
   */
  readonly fields: RaceSourceMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceSourceMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceSourceMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SourceBook<T extends RaceSourceMap$SourceBookArgs<ExtArgs> = {}>(args?: Subset<T, RaceSourceMap$SourceBookArgs<ExtArgs>>): Prisma__SourceBookClient<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaceSourceMap model
   */
  interface RaceSourceMapFieldRefs {
    readonly id: FieldRef<"RaceSourceMap", 'Int'>
    readonly raceId: FieldRef<"RaceSourceMap", 'Int'>
    readonly bookId: FieldRef<"RaceSourceMap", 'Int'>
    readonly pageNumber: FieldRef<"RaceSourceMap", 'Int'>
    readonly sourceBookId: FieldRef<"RaceSourceMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RaceSourceMap findUnique
   */
  export type RaceSourceMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceSourceMap to fetch.
     */
    where: RaceSourceMapWhereUniqueInput
  }

  /**
   * RaceSourceMap findUniqueOrThrow
   */
  export type RaceSourceMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceSourceMap to fetch.
     */
    where: RaceSourceMapWhereUniqueInput
  }

  /**
   * RaceSourceMap findFirst
   */
  export type RaceSourceMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceSourceMap to fetch.
     */
    where?: RaceSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceSourceMaps to fetch.
     */
    orderBy?: RaceSourceMapOrderByWithRelationInput | RaceSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceSourceMaps.
     */
    cursor?: RaceSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceSourceMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceSourceMaps.
     */
    distinct?: RaceSourceMapScalarFieldEnum | RaceSourceMapScalarFieldEnum[]
  }

  /**
   * RaceSourceMap findFirstOrThrow
   */
  export type RaceSourceMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceSourceMap to fetch.
     */
    where?: RaceSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceSourceMaps to fetch.
     */
    orderBy?: RaceSourceMapOrderByWithRelationInput | RaceSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceSourceMaps.
     */
    cursor?: RaceSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceSourceMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceSourceMaps.
     */
    distinct?: RaceSourceMapScalarFieldEnum | RaceSourceMapScalarFieldEnum[]
  }

  /**
   * RaceSourceMap findMany
   */
  export type RaceSourceMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
    /**
     * Filter, which RaceSourceMaps to fetch.
     */
    where?: RaceSourceMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceSourceMaps to fetch.
     */
    orderBy?: RaceSourceMapOrderByWithRelationInput | RaceSourceMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceSourceMaps.
     */
    cursor?: RaceSourceMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceSourceMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceSourceMaps.
     */
    skip?: number
    distinct?: RaceSourceMapScalarFieldEnum | RaceSourceMapScalarFieldEnum[]
  }

  /**
   * RaceSourceMap create
   */
  export type RaceSourceMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceSourceMap.
     */
    data: XOR<RaceSourceMapCreateInput, RaceSourceMapUncheckedCreateInput>
  }

  /**
   * RaceSourceMap createMany
   */
  export type RaceSourceMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceSourceMaps.
     */
    data: RaceSourceMapCreateManyInput | RaceSourceMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaceSourceMap update
   */
  export type RaceSourceMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceSourceMap.
     */
    data: XOR<RaceSourceMapUpdateInput, RaceSourceMapUncheckedUpdateInput>
    /**
     * Choose, which RaceSourceMap to update.
     */
    where: RaceSourceMapWhereUniqueInput
  }

  /**
   * RaceSourceMap updateMany
   */
  export type RaceSourceMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceSourceMaps.
     */
    data: XOR<RaceSourceMapUpdateManyMutationInput, RaceSourceMapUncheckedUpdateManyInput>
    /**
     * Filter which RaceSourceMaps to update
     */
    where?: RaceSourceMapWhereInput
    /**
     * Limit how many RaceSourceMaps to update.
     */
    limit?: number
  }

  /**
   * RaceSourceMap upsert
   */
  export type RaceSourceMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceSourceMap to update in case it exists.
     */
    where: RaceSourceMapWhereUniqueInput
    /**
     * In case the RaceSourceMap found by the `where` argument doesn't exist, create a new RaceSourceMap with this data.
     */
    create: XOR<RaceSourceMapCreateInput, RaceSourceMapUncheckedCreateInput>
    /**
     * In case the RaceSourceMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceSourceMapUpdateInput, RaceSourceMapUncheckedUpdateInput>
  }

  /**
   * RaceSourceMap delete
   */
  export type RaceSourceMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
    /**
     * Filter which RaceSourceMap to delete.
     */
    where: RaceSourceMapWhereUniqueInput
  }

  /**
   * RaceSourceMap deleteMany
   */
  export type RaceSourceMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceSourceMaps to delete
     */
    where?: RaceSourceMapWhereInput
    /**
     * Limit how many RaceSourceMaps to delete.
     */
    limit?: number
  }

  /**
   * RaceSourceMap.SourceBook
   */
  export type RaceSourceMap$SourceBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    where?: SourceBookWhereInput
  }

  /**
   * RaceSourceMap without action
   */
  export type RaceSourceMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
  }


  /**
   * Model Armor
   */

  export type AggregateArmor = {
    _count: ArmorCountAggregateOutputType | null
    _avg: ArmorAvgAggregateOutputType | null
    _sum: ArmorSumAggregateOutputType | null
    _min: ArmorMinAggregateOutputType | null
    _max: ArmorMaxAggregateOutputType | null
  }

  export type ArmorAvgAggregateOutputType = {
    id: number | null
    category: number | null
    cost: Decimal | null
    bonus: number | null
    dexterityCap: number | null
    checkPenalty: number | null
    arcaneSpellFailure: number | null
    speedCapThirty: number | null
    speedCapTwenty: number | null
    weight: number | null
  }

  export type ArmorSumAggregateOutputType = {
    id: number | null
    category: number | null
    cost: Decimal | null
    bonus: number | null
    dexterityCap: number | null
    checkPenalty: number | null
    arcaneSpellFailure: number | null
    speedCapThirty: number | null
    speedCapTwenty: number | null
    weight: number | null
  }

  export type ArmorMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: number | null
    cost: Decimal | null
    bonus: number | null
    dexterityCap: number | null
    checkPenalty: number | null
    arcaneSpellFailure: number | null
    speedCapThirty: number | null
    speedCapTwenty: number | null
    weight: number | null
  }

  export type ArmorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: number | null
    cost: Decimal | null
    bonus: number | null
    dexterityCap: number | null
    checkPenalty: number | null
    arcaneSpellFailure: number | null
    speedCapThirty: number | null
    speedCapTwenty: number | null
    weight: number | null
  }

  export type ArmorCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    cost: number
    bonus: number
    dexterityCap: number
    checkPenalty: number
    arcaneSpellFailure: number
    speedCapThirty: number
    speedCapTwenty: number
    weight: number
    _all: number
  }


  export type ArmorAvgAggregateInputType = {
    id?: true
    category?: true
    cost?: true
    bonus?: true
    dexterityCap?: true
    checkPenalty?: true
    arcaneSpellFailure?: true
    speedCapThirty?: true
    speedCapTwenty?: true
    weight?: true
  }

  export type ArmorSumAggregateInputType = {
    id?: true
    category?: true
    cost?: true
    bonus?: true
    dexterityCap?: true
    checkPenalty?: true
    arcaneSpellFailure?: true
    speedCapThirty?: true
    speedCapTwenty?: true
    weight?: true
  }

  export type ArmorMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    cost?: true
    bonus?: true
    dexterityCap?: true
    checkPenalty?: true
    arcaneSpellFailure?: true
    speedCapThirty?: true
    speedCapTwenty?: true
    weight?: true
  }

  export type ArmorMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    cost?: true
    bonus?: true
    dexterityCap?: true
    checkPenalty?: true
    arcaneSpellFailure?: true
    speedCapThirty?: true
    speedCapTwenty?: true
    weight?: true
  }

  export type ArmorCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    cost?: true
    bonus?: true
    dexterityCap?: true
    checkPenalty?: true
    arcaneSpellFailure?: true
    speedCapThirty?: true
    speedCapTwenty?: true
    weight?: true
    _all?: true
  }

  export type ArmorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Armor to aggregate.
     */
    where?: ArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armors to fetch.
     */
    orderBy?: ArmorOrderByWithRelationInput | ArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Armors
    **/
    _count?: true | ArmorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArmorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArmorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArmorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArmorMaxAggregateInputType
  }

  export type GetArmorAggregateType<T extends ArmorAggregateArgs> = {
        [P in keyof T & keyof AggregateArmor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArmor[P]>
      : GetScalarType<T[P], AggregateArmor[P]>
  }




  export type ArmorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArmorWhereInput
    orderBy?: ArmorOrderByWithAggregationInput | ArmorOrderByWithAggregationInput[]
    by: ArmorScalarFieldEnum[] | ArmorScalarFieldEnum
    having?: ArmorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArmorCountAggregateInputType | true
    _avg?: ArmorAvgAggregateInputType
    _sum?: ArmorSumAggregateInputType
    _min?: ArmorMinAggregateInputType
    _max?: ArmorMaxAggregateInputType
  }

  export type ArmorGroupByOutputType = {
    id: number
    name: string
    description: string | null
    category: number
    cost: Decimal | null
    bonus: number | null
    dexterityCap: number | null
    checkPenalty: number | null
    arcaneSpellFailure: number | null
    speedCapThirty: number | null
    speedCapTwenty: number | null
    weight: number | null
    _count: ArmorCountAggregateOutputType | null
    _avg: ArmorAvgAggregateOutputType | null
    _sum: ArmorSumAggregateOutputType | null
    _min: ArmorMinAggregateOutputType | null
    _max: ArmorMaxAggregateOutputType | null
  }

  type GetArmorGroupByPayload<T extends ArmorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArmorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArmorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArmorGroupByOutputType[P]>
            : GetScalarType<T[P], ArmorGroupByOutputType[P]>
        }
      >
    >


  export type ArmorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    cost?: boolean
    bonus?: boolean
    dexterityCap?: boolean
    checkPenalty?: boolean
    arcaneSpellFailure?: boolean
    speedCapThirty?: boolean
    speedCapTwenty?: boolean
    weight?: boolean
  }, ExtArgs["result"]["armor"]>



  export type ArmorSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    cost?: boolean
    bonus?: boolean
    dexterityCap?: boolean
    checkPenalty?: boolean
    arcaneSpellFailure?: boolean
    speedCapThirty?: boolean
    speedCapTwenty?: boolean
    weight?: boolean
  }

  export type ArmorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "cost" | "bonus" | "dexterityCap" | "checkPenalty" | "arcaneSpellFailure" | "speedCapThirty" | "speedCapTwenty" | "weight", ExtArgs["result"]["armor"]>

  export type $ArmorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Armor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      category: number
      cost: Prisma.Decimal | null
      bonus: number | null
      dexterityCap: number | null
      checkPenalty: number | null
      arcaneSpellFailure: number | null
      speedCapThirty: number | null
      speedCapTwenty: number | null
      weight: number | null
    }, ExtArgs["result"]["armor"]>
    composites: {}
  }

  type ArmorGetPayload<S extends boolean | null | undefined | ArmorDefaultArgs> = $Result.GetResult<Prisma.$ArmorPayload, S>

  type ArmorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArmorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArmorCountAggregateInputType | true
    }

  export interface ArmorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Armor'], meta: { name: 'Armor' } }
    /**
     * Find zero or one Armor that matches the filter.
     * @param {ArmorFindUniqueArgs} args - Arguments to find a Armor
     * @example
     * // Get one Armor
     * const armor = await prisma.armor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArmorFindUniqueArgs>(args: SelectSubset<T, ArmorFindUniqueArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Armor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArmorFindUniqueOrThrowArgs} args - Arguments to find a Armor
     * @example
     * // Get one Armor
     * const armor = await prisma.armor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArmorFindUniqueOrThrowArgs>(args: SelectSubset<T, ArmorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Armor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorFindFirstArgs} args - Arguments to find a Armor
     * @example
     * // Get one Armor
     * const armor = await prisma.armor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArmorFindFirstArgs>(args?: SelectSubset<T, ArmorFindFirstArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Armor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorFindFirstOrThrowArgs} args - Arguments to find a Armor
     * @example
     * // Get one Armor
     * const armor = await prisma.armor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArmorFindFirstOrThrowArgs>(args?: SelectSubset<T, ArmorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Armors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Armors
     * const armors = await prisma.armor.findMany()
     * 
     * // Get first 10 Armors
     * const armors = await prisma.armor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const armorWithIdOnly = await prisma.armor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArmorFindManyArgs>(args?: SelectSubset<T, ArmorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Armor.
     * @param {ArmorCreateArgs} args - Arguments to create a Armor.
     * @example
     * // Create one Armor
     * const Armor = await prisma.armor.create({
     *   data: {
     *     // ... data to create a Armor
     *   }
     * })
     * 
     */
    create<T extends ArmorCreateArgs>(args: SelectSubset<T, ArmorCreateArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Armors.
     * @param {ArmorCreateManyArgs} args - Arguments to create many Armors.
     * @example
     * // Create many Armors
     * const armor = await prisma.armor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArmorCreateManyArgs>(args?: SelectSubset<T, ArmorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Armor.
     * @param {ArmorDeleteArgs} args - Arguments to delete one Armor.
     * @example
     * // Delete one Armor
     * const Armor = await prisma.armor.delete({
     *   where: {
     *     // ... filter to delete one Armor
     *   }
     * })
     * 
     */
    delete<T extends ArmorDeleteArgs>(args: SelectSubset<T, ArmorDeleteArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Armor.
     * @param {ArmorUpdateArgs} args - Arguments to update one Armor.
     * @example
     * // Update one Armor
     * const armor = await prisma.armor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArmorUpdateArgs>(args: SelectSubset<T, ArmorUpdateArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Armors.
     * @param {ArmorDeleteManyArgs} args - Arguments to filter Armors to delete.
     * @example
     * // Delete a few Armors
     * const { count } = await prisma.armor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArmorDeleteManyArgs>(args?: SelectSubset<T, ArmorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Armors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Armors
     * const armor = await prisma.armor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArmorUpdateManyArgs>(args: SelectSubset<T, ArmorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Armor.
     * @param {ArmorUpsertArgs} args - Arguments to update or create a Armor.
     * @example
     * // Update or create a Armor
     * const armor = await prisma.armor.upsert({
     *   create: {
     *     // ... data to create a Armor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Armor we want to update
     *   }
     * })
     */
    upsert<T extends ArmorUpsertArgs>(args: SelectSubset<T, ArmorUpsertArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Armors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorCountArgs} args - Arguments to filter Armors to count.
     * @example
     * // Count the number of Armors
     * const count = await prisma.armor.count({
     *   where: {
     *     // ... the filter for the Armors we want to count
     *   }
     * })
    **/
    count<T extends ArmorCountArgs>(
      args?: Subset<T, ArmorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArmorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Armor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArmorAggregateArgs>(args: Subset<T, ArmorAggregateArgs>): Prisma.PrismaPromise<GetArmorAggregateType<T>>

    /**
     * Group by Armor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArmorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArmorGroupByArgs['orderBy'] }
        : { orderBy?: ArmorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArmorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArmorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Armor model
   */
  readonly fields: ArmorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Armor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArmorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Armor model
   */
  interface ArmorFieldRefs {
    readonly id: FieldRef<"Armor", 'Int'>
    readonly name: FieldRef<"Armor", 'String'>
    readonly description: FieldRef<"Armor", 'String'>
    readonly category: FieldRef<"Armor", 'Int'>
    readonly cost: FieldRef<"Armor", 'Decimal'>
    readonly bonus: FieldRef<"Armor", 'Int'>
    readonly dexterityCap: FieldRef<"Armor", 'Int'>
    readonly checkPenalty: FieldRef<"Armor", 'Int'>
    readonly arcaneSpellFailure: FieldRef<"Armor", 'Int'>
    readonly speedCapThirty: FieldRef<"Armor", 'Int'>
    readonly speedCapTwenty: FieldRef<"Armor", 'Int'>
    readonly weight: FieldRef<"Armor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Armor findUnique
   */
  export type ArmorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Filter, which Armor to fetch.
     */
    where: ArmorWhereUniqueInput
  }

  /**
   * Armor findUniqueOrThrow
   */
  export type ArmorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Filter, which Armor to fetch.
     */
    where: ArmorWhereUniqueInput
  }

  /**
   * Armor findFirst
   */
  export type ArmorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Filter, which Armor to fetch.
     */
    where?: ArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armors to fetch.
     */
    orderBy?: ArmorOrderByWithRelationInput | ArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Armors.
     */
    cursor?: ArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Armors.
     */
    distinct?: ArmorScalarFieldEnum | ArmorScalarFieldEnum[]
  }

  /**
   * Armor findFirstOrThrow
   */
  export type ArmorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Filter, which Armor to fetch.
     */
    where?: ArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armors to fetch.
     */
    orderBy?: ArmorOrderByWithRelationInput | ArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Armors.
     */
    cursor?: ArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Armors.
     */
    distinct?: ArmorScalarFieldEnum | ArmorScalarFieldEnum[]
  }

  /**
   * Armor findMany
   */
  export type ArmorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Filter, which Armors to fetch.
     */
    where?: ArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armors to fetch.
     */
    orderBy?: ArmorOrderByWithRelationInput | ArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Armors.
     */
    cursor?: ArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armors.
     */
    skip?: number
    distinct?: ArmorScalarFieldEnum | ArmorScalarFieldEnum[]
  }

  /**
   * Armor create
   */
  export type ArmorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * The data needed to create a Armor.
     */
    data: XOR<ArmorCreateInput, ArmorUncheckedCreateInput>
  }

  /**
   * Armor createMany
   */
  export type ArmorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Armors.
     */
    data: ArmorCreateManyInput | ArmorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Armor update
   */
  export type ArmorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * The data needed to update a Armor.
     */
    data: XOR<ArmorUpdateInput, ArmorUncheckedUpdateInput>
    /**
     * Choose, which Armor to update.
     */
    where: ArmorWhereUniqueInput
  }

  /**
   * Armor updateMany
   */
  export type ArmorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Armors.
     */
    data: XOR<ArmorUpdateManyMutationInput, ArmorUncheckedUpdateManyInput>
    /**
     * Filter which Armors to update
     */
    where?: ArmorWhereInput
    /**
     * Limit how many Armors to update.
     */
    limit?: number
  }

  /**
   * Armor upsert
   */
  export type ArmorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * The filter to search for the Armor to update in case it exists.
     */
    where: ArmorWhereUniqueInput
    /**
     * In case the Armor found by the `where` argument doesn't exist, create a new Armor with this data.
     */
    create: XOR<ArmorCreateInput, ArmorUncheckedCreateInput>
    /**
     * In case the Armor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArmorUpdateInput, ArmorUncheckedUpdateInput>
  }

  /**
   * Armor delete
   */
  export type ArmorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Filter which Armor to delete.
     */
    where: ArmorWhereUniqueInput
  }

  /**
   * Armor deleteMany
   */
  export type ArmorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Armors to delete
     */
    where?: ArmorWhereInput
    /**
     * Limit how many Armors to delete.
     */
    limit?: number
  }

  /**
   * Armor without action
   */
  export type ArmorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
  }


  /**
   * Model Weapon
   */

  export type AggregateWeapon = {
    _count: WeaponCountAggregateOutputType | null
    _avg: WeaponAvgAggregateOutputType | null
    _sum: WeaponSumAggregateOutputType | null
    _min: WeaponMinAggregateOutputType | null
    _max: WeaponMaxAggregateOutputType | null
  }

  export type WeaponAvgAggregateOutputType = {
    id: number | null
    category: number | null
    cost: Decimal | null
    weight: Decimal | null
    damageTypeId: number | null
  }

  export type WeaponSumAggregateOutputType = {
    id: number | null
    category: number | null
    cost: Decimal | null
    weight: Decimal | null
    damageTypeId: number | null
  }

  export type WeaponMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: number | null
    cost: Decimal | null
    damageSmall: string | null
    damageMedium: string | null
    critical: string | null
    range: string | null
    weight: Decimal | null
    damageTypeId: number | null
  }

  export type WeaponMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: number | null
    cost: Decimal | null
    damageSmall: string | null
    damageMedium: string | null
    critical: string | null
    range: string | null
    weight: Decimal | null
    damageTypeId: number | null
  }

  export type WeaponCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    cost: number
    damageSmall: number
    damageMedium: number
    critical: number
    range: number
    weight: number
    damageTypeId: number
    _all: number
  }


  export type WeaponAvgAggregateInputType = {
    id?: true
    category?: true
    cost?: true
    weight?: true
    damageTypeId?: true
  }

  export type WeaponSumAggregateInputType = {
    id?: true
    category?: true
    cost?: true
    weight?: true
    damageTypeId?: true
  }

  export type WeaponMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    cost?: true
    damageSmall?: true
    damageMedium?: true
    critical?: true
    range?: true
    weight?: true
    damageTypeId?: true
  }

  export type WeaponMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    cost?: true
    damageSmall?: true
    damageMedium?: true
    critical?: true
    range?: true
    weight?: true
    damageTypeId?: true
  }

  export type WeaponCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    cost?: true
    damageSmall?: true
    damageMedium?: true
    critical?: true
    range?: true
    weight?: true
    damageTypeId?: true
    _all?: true
  }

  export type WeaponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weapon to aggregate.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weapons
    **/
    _count?: true | WeaponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeaponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeaponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeaponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeaponMaxAggregateInputType
  }

  export type GetWeaponAggregateType<T extends WeaponAggregateArgs> = {
        [P in keyof T & keyof AggregateWeapon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeapon[P]>
      : GetScalarType<T[P], AggregateWeapon[P]>
  }




  export type WeaponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponWhereInput
    orderBy?: WeaponOrderByWithAggregationInput | WeaponOrderByWithAggregationInput[]
    by: WeaponScalarFieldEnum[] | WeaponScalarFieldEnum
    having?: WeaponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeaponCountAggregateInputType | true
    _avg?: WeaponAvgAggregateInputType
    _sum?: WeaponSumAggregateInputType
    _min?: WeaponMinAggregateInputType
    _max?: WeaponMaxAggregateInputType
  }

  export type WeaponGroupByOutputType = {
    id: number
    name: string
    description: string | null
    category: number
    cost: Decimal | null
    damageSmall: string | null
    damageMedium: string | null
    critical: string | null
    range: string | null
    weight: Decimal | null
    damageTypeId: number | null
    _count: WeaponCountAggregateOutputType | null
    _avg: WeaponAvgAggregateOutputType | null
    _sum: WeaponSumAggregateOutputType | null
    _min: WeaponMinAggregateOutputType | null
    _max: WeaponMaxAggregateOutputType | null
  }

  type GetWeaponGroupByPayload<T extends WeaponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeaponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeaponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeaponGroupByOutputType[P]>
            : GetScalarType<T[P], WeaponGroupByOutputType[P]>
        }
      >
    >


  export type WeaponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    cost?: boolean
    damageSmall?: boolean
    damageMedium?: boolean
    critical?: boolean
    range?: boolean
    weight?: boolean
    damageTypeId?: boolean
  }, ExtArgs["result"]["weapon"]>



  export type WeaponSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    cost?: boolean
    damageSmall?: boolean
    damageMedium?: boolean
    critical?: boolean
    range?: boolean
    weight?: boolean
    damageTypeId?: boolean
  }

  export type WeaponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "cost" | "damageSmall" | "damageMedium" | "critical" | "range" | "weight" | "damageTypeId", ExtArgs["result"]["weapon"]>

  export type $WeaponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weapon"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      category: number
      cost: Prisma.Decimal | null
      damageSmall: string | null
      damageMedium: string | null
      critical: string | null
      range: string | null
      weight: Prisma.Decimal | null
      damageTypeId: number | null
    }, ExtArgs["result"]["weapon"]>
    composites: {}
  }

  type WeaponGetPayload<S extends boolean | null | undefined | WeaponDefaultArgs> = $Result.GetResult<Prisma.$WeaponPayload, S>

  type WeaponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeaponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeaponCountAggregateInputType | true
    }

  export interface WeaponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weapon'], meta: { name: 'Weapon' } }
    /**
     * Find zero or one Weapon that matches the filter.
     * @param {WeaponFindUniqueArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeaponFindUniqueArgs>(args: SelectSubset<T, WeaponFindUniqueArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weapon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeaponFindUniqueOrThrowArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeaponFindUniqueOrThrowArgs>(args: SelectSubset<T, WeaponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weapon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponFindFirstArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeaponFindFirstArgs>(args?: SelectSubset<T, WeaponFindFirstArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weapon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponFindFirstOrThrowArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeaponFindFirstOrThrowArgs>(args?: SelectSubset<T, WeaponFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weapons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weapons
     * const weapons = await prisma.weapon.findMany()
     * 
     * // Get first 10 Weapons
     * const weapons = await prisma.weapon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weaponWithIdOnly = await prisma.weapon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeaponFindManyArgs>(args?: SelectSubset<T, WeaponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weapon.
     * @param {WeaponCreateArgs} args - Arguments to create a Weapon.
     * @example
     * // Create one Weapon
     * const Weapon = await prisma.weapon.create({
     *   data: {
     *     // ... data to create a Weapon
     *   }
     * })
     * 
     */
    create<T extends WeaponCreateArgs>(args: SelectSubset<T, WeaponCreateArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weapons.
     * @param {WeaponCreateManyArgs} args - Arguments to create many Weapons.
     * @example
     * // Create many Weapons
     * const weapon = await prisma.weapon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeaponCreateManyArgs>(args?: SelectSubset<T, WeaponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Weapon.
     * @param {WeaponDeleteArgs} args - Arguments to delete one Weapon.
     * @example
     * // Delete one Weapon
     * const Weapon = await prisma.weapon.delete({
     *   where: {
     *     // ... filter to delete one Weapon
     *   }
     * })
     * 
     */
    delete<T extends WeaponDeleteArgs>(args: SelectSubset<T, WeaponDeleteArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weapon.
     * @param {WeaponUpdateArgs} args - Arguments to update one Weapon.
     * @example
     * // Update one Weapon
     * const weapon = await prisma.weapon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeaponUpdateArgs>(args: SelectSubset<T, WeaponUpdateArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weapons.
     * @param {WeaponDeleteManyArgs} args - Arguments to filter Weapons to delete.
     * @example
     * // Delete a few Weapons
     * const { count } = await prisma.weapon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeaponDeleteManyArgs>(args?: SelectSubset<T, WeaponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weapons
     * const weapon = await prisma.weapon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeaponUpdateManyArgs>(args: SelectSubset<T, WeaponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Weapon.
     * @param {WeaponUpsertArgs} args - Arguments to update or create a Weapon.
     * @example
     * // Update or create a Weapon
     * const weapon = await prisma.weapon.upsert({
     *   create: {
     *     // ... data to create a Weapon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weapon we want to update
     *   }
     * })
     */
    upsert<T extends WeaponUpsertArgs>(args: SelectSubset<T, WeaponUpsertArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponCountArgs} args - Arguments to filter Weapons to count.
     * @example
     * // Count the number of Weapons
     * const count = await prisma.weapon.count({
     *   where: {
     *     // ... the filter for the Weapons we want to count
     *   }
     * })
    **/
    count<T extends WeaponCountArgs>(
      args?: Subset<T, WeaponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeaponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeaponAggregateArgs>(args: Subset<T, WeaponAggregateArgs>): Prisma.PrismaPromise<GetWeaponAggregateType<T>>

    /**
     * Group by Weapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeaponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeaponGroupByArgs['orderBy'] }
        : { orderBy?: WeaponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeaponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeaponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weapon model
   */
  readonly fields: WeaponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weapon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeaponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weapon model
   */
  interface WeaponFieldRefs {
    readonly id: FieldRef<"Weapon", 'Int'>
    readonly name: FieldRef<"Weapon", 'String'>
    readonly description: FieldRef<"Weapon", 'String'>
    readonly category: FieldRef<"Weapon", 'Int'>
    readonly cost: FieldRef<"Weapon", 'Decimal'>
    readonly damageSmall: FieldRef<"Weapon", 'String'>
    readonly damageMedium: FieldRef<"Weapon", 'String'>
    readonly critical: FieldRef<"Weapon", 'String'>
    readonly range: FieldRef<"Weapon", 'String'>
    readonly weight: FieldRef<"Weapon", 'Decimal'>
    readonly damageTypeId: FieldRef<"Weapon", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Weapon findUnique
   */
  export type WeaponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon findUniqueOrThrow
   */
  export type WeaponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon findFirst
   */
  export type WeaponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weapons.
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weapons.
     */
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Weapon findFirstOrThrow
   */
  export type WeaponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weapons.
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weapons.
     */
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Weapon findMany
   */
  export type WeaponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Filter, which Weapons to fetch.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weapons.
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Weapon create
   */
  export type WeaponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * The data needed to create a Weapon.
     */
    data: XOR<WeaponCreateInput, WeaponUncheckedCreateInput>
  }

  /**
   * Weapon createMany
   */
  export type WeaponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weapons.
     */
    data: WeaponCreateManyInput | WeaponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weapon update
   */
  export type WeaponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * The data needed to update a Weapon.
     */
    data: XOR<WeaponUpdateInput, WeaponUncheckedUpdateInput>
    /**
     * Choose, which Weapon to update.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon updateMany
   */
  export type WeaponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weapons.
     */
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyInput>
    /**
     * Filter which Weapons to update
     */
    where?: WeaponWhereInput
    /**
     * Limit how many Weapons to update.
     */
    limit?: number
  }

  /**
   * Weapon upsert
   */
  export type WeaponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * The filter to search for the Weapon to update in case it exists.
     */
    where: WeaponWhereUniqueInput
    /**
     * In case the Weapon found by the `where` argument doesn't exist, create a new Weapon with this data.
     */
    create: XOR<WeaponCreateInput, WeaponUncheckedCreateInput>
    /**
     * In case the Weapon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeaponUpdateInput, WeaponUncheckedUpdateInput>
  }

  /**
   * Weapon delete
   */
  export type WeaponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Filter which Weapon to delete.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon deleteMany
   */
  export type WeaponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weapons to delete
     */
    where?: WeaponWhereInput
    /**
     * Limit how many Weapons to delete.
     */
    limit?: number
  }

  /**
   * Weapon without action
   */
  export type WeaponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
  }


  /**
   * Model SourceBook
   */

  export type AggregateSourceBook = {
    _count: SourceBookCountAggregateOutputType | null
    _avg: SourceBookAvgAggregateOutputType | null
    _sum: SourceBookSumAggregateOutputType | null
    _min: SourceBookMinAggregateOutputType | null
    _max: SourceBookMaxAggregateOutputType | null
  }

  export type SourceBookAvgAggregateOutputType = {
    id: number | null
    editionId: number | null
  }

  export type SourceBookSumAggregateOutputType = {
    id: number | null
    editionId: number | null
  }

  export type SourceBookMinAggregateOutputType = {
    id: number | null
    name: string | null
    abbreviation: string | null
    releaseDate: Date | null
    editionId: number | null
    description: string | null
    isVisible: boolean | null
  }

  export type SourceBookMaxAggregateOutputType = {
    id: number | null
    name: string | null
    abbreviation: string | null
    releaseDate: Date | null
    editionId: number | null
    description: string | null
    isVisible: boolean | null
  }

  export type SourceBookCountAggregateOutputType = {
    id: number
    name: number
    abbreviation: number
    releaseDate: number
    editionId: number
    description: number
    isVisible: number
    _all: number
  }


  export type SourceBookAvgAggregateInputType = {
    id?: true
    editionId?: true
  }

  export type SourceBookSumAggregateInputType = {
    id?: true
    editionId?: true
  }

  export type SourceBookMinAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    releaseDate?: true
    editionId?: true
    description?: true
    isVisible?: true
  }

  export type SourceBookMaxAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    releaseDate?: true
    editionId?: true
    description?: true
    isVisible?: true
  }

  export type SourceBookCountAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    releaseDate?: true
    editionId?: true
    description?: true
    isVisible?: true
    _all?: true
  }

  export type SourceBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceBook to aggregate.
     */
    where?: SourceBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceBooks to fetch.
     */
    orderBy?: SourceBookOrderByWithRelationInput | SourceBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SourceBooks
    **/
    _count?: true | SourceBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceBookMaxAggregateInputType
  }

  export type GetSourceBookAggregateType<T extends SourceBookAggregateArgs> = {
        [P in keyof T & keyof AggregateSourceBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSourceBook[P]>
      : GetScalarType<T[P], AggregateSourceBook[P]>
  }




  export type SourceBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceBookWhereInput
    orderBy?: SourceBookOrderByWithAggregationInput | SourceBookOrderByWithAggregationInput[]
    by: SourceBookScalarFieldEnum[] | SourceBookScalarFieldEnum
    having?: SourceBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceBookCountAggregateInputType | true
    _avg?: SourceBookAvgAggregateInputType
    _sum?: SourceBookSumAggregateInputType
    _min?: SourceBookMinAggregateInputType
    _max?: SourceBookMaxAggregateInputType
  }

  export type SourceBookGroupByOutputType = {
    id: number
    name: string
    abbreviation: string
    releaseDate: Date | null
    editionId: number | null
    description: string | null
    isVisible: boolean
    _count: SourceBookCountAggregateOutputType | null
    _avg: SourceBookAvgAggregateOutputType | null
    _sum: SourceBookSumAggregateOutputType | null
    _min: SourceBookMinAggregateOutputType | null
    _max: SourceBookMaxAggregateOutputType | null
  }

  type GetSourceBookGroupByPayload<T extends SourceBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceBookGroupByOutputType[P]>
            : GetScalarType<T[P], SourceBookGroupByOutputType[P]>
        }
      >
    >


  export type SourceBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbreviation?: boolean
    releaseDate?: boolean
    editionId?: boolean
    description?: boolean
    isVisible?: boolean
    classes?: boolean | SourceBook$classesArgs<ExtArgs>
    races?: boolean | SourceBook$racesArgs<ExtArgs>
    spells?: boolean | SourceBook$spellsArgs<ExtArgs>
    _count?: boolean | SourceBookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceBook"]>



  export type SourceBookSelectScalar = {
    id?: boolean
    name?: boolean
    abbreviation?: boolean
    releaseDate?: boolean
    editionId?: boolean
    description?: boolean
    isVisible?: boolean
  }

  export type SourceBookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbreviation" | "releaseDate" | "editionId" | "description" | "isVisible", ExtArgs["result"]["sourceBook"]>
  export type SourceBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | SourceBook$classesArgs<ExtArgs>
    races?: boolean | SourceBook$racesArgs<ExtArgs>
    spells?: boolean | SourceBook$spellsArgs<ExtArgs>
    _count?: boolean | SourceBookCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SourceBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SourceBook"
    objects: {
      classes: Prisma.$ClassSourceMapPayload<ExtArgs>[]
      races: Prisma.$RaceSourceMapPayload<ExtArgs>[]
      spells: Prisma.$SpellSourceMapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      abbreviation: string
      releaseDate: Date | null
      editionId: number | null
      description: string | null
      isVisible: boolean
    }, ExtArgs["result"]["sourceBook"]>
    composites: {}
  }

  type SourceBookGetPayload<S extends boolean | null | undefined | SourceBookDefaultArgs> = $Result.GetResult<Prisma.$SourceBookPayload, S>

  type SourceBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceBookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceBookCountAggregateInputType | true
    }

  export interface SourceBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SourceBook'], meta: { name: 'SourceBook' } }
    /**
     * Find zero or one SourceBook that matches the filter.
     * @param {SourceBookFindUniqueArgs} args - Arguments to find a SourceBook
     * @example
     * // Get one SourceBook
     * const sourceBook = await prisma.sourceBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceBookFindUniqueArgs>(args: SelectSubset<T, SourceBookFindUniqueArgs<ExtArgs>>): Prisma__SourceBookClient<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SourceBook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceBookFindUniqueOrThrowArgs} args - Arguments to find a SourceBook
     * @example
     * // Get one SourceBook
     * const sourceBook = await prisma.sourceBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceBookFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceBookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceBookClient<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceBookFindFirstArgs} args - Arguments to find a SourceBook
     * @example
     * // Get one SourceBook
     * const sourceBook = await prisma.sourceBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceBookFindFirstArgs>(args?: SelectSubset<T, SourceBookFindFirstArgs<ExtArgs>>): Prisma__SourceBookClient<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceBookFindFirstOrThrowArgs} args - Arguments to find a SourceBook
     * @example
     * // Get one SourceBook
     * const sourceBook = await prisma.sourceBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceBookFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceBookFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceBookClient<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SourceBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceBookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SourceBooks
     * const sourceBooks = await prisma.sourceBook.findMany()
     * 
     * // Get first 10 SourceBooks
     * const sourceBooks = await prisma.sourceBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceBookWithIdOnly = await prisma.sourceBook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourceBookFindManyArgs>(args?: SelectSubset<T, SourceBookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SourceBook.
     * @param {SourceBookCreateArgs} args - Arguments to create a SourceBook.
     * @example
     * // Create one SourceBook
     * const SourceBook = await prisma.sourceBook.create({
     *   data: {
     *     // ... data to create a SourceBook
     *   }
     * })
     * 
     */
    create<T extends SourceBookCreateArgs>(args: SelectSubset<T, SourceBookCreateArgs<ExtArgs>>): Prisma__SourceBookClient<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SourceBooks.
     * @param {SourceBookCreateManyArgs} args - Arguments to create many SourceBooks.
     * @example
     * // Create many SourceBooks
     * const sourceBook = await prisma.sourceBook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceBookCreateManyArgs>(args?: SelectSubset<T, SourceBookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SourceBook.
     * @param {SourceBookDeleteArgs} args - Arguments to delete one SourceBook.
     * @example
     * // Delete one SourceBook
     * const SourceBook = await prisma.sourceBook.delete({
     *   where: {
     *     // ... filter to delete one SourceBook
     *   }
     * })
     * 
     */
    delete<T extends SourceBookDeleteArgs>(args: SelectSubset<T, SourceBookDeleteArgs<ExtArgs>>): Prisma__SourceBookClient<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SourceBook.
     * @param {SourceBookUpdateArgs} args - Arguments to update one SourceBook.
     * @example
     * // Update one SourceBook
     * const sourceBook = await prisma.sourceBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceBookUpdateArgs>(args: SelectSubset<T, SourceBookUpdateArgs<ExtArgs>>): Prisma__SourceBookClient<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SourceBooks.
     * @param {SourceBookDeleteManyArgs} args - Arguments to filter SourceBooks to delete.
     * @example
     * // Delete a few SourceBooks
     * const { count } = await prisma.sourceBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceBookDeleteManyArgs>(args?: SelectSubset<T, SourceBookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SourceBooks
     * const sourceBook = await prisma.sourceBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceBookUpdateManyArgs>(args: SelectSubset<T, SourceBookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SourceBook.
     * @param {SourceBookUpsertArgs} args - Arguments to update or create a SourceBook.
     * @example
     * // Update or create a SourceBook
     * const sourceBook = await prisma.sourceBook.upsert({
     *   create: {
     *     // ... data to create a SourceBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SourceBook we want to update
     *   }
     * })
     */
    upsert<T extends SourceBookUpsertArgs>(args: SelectSubset<T, SourceBookUpsertArgs<ExtArgs>>): Prisma__SourceBookClient<$Result.GetResult<Prisma.$SourceBookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SourceBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceBookCountArgs} args - Arguments to filter SourceBooks to count.
     * @example
     * // Count the number of SourceBooks
     * const count = await prisma.sourceBook.count({
     *   where: {
     *     // ... the filter for the SourceBooks we want to count
     *   }
     * })
    **/
    count<T extends SourceBookCountArgs>(
      args?: Subset<T, SourceBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SourceBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceBookAggregateArgs>(args: Subset<T, SourceBookAggregateArgs>): Prisma.PrismaPromise<GetSourceBookAggregateType<T>>

    /**
     * Group by SourceBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceBookGroupByArgs['orderBy'] }
        : { orderBy?: SourceBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SourceBook model
   */
  readonly fields: SourceBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SourceBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends SourceBook$classesArgs<ExtArgs> = {}>(args?: Subset<T, SourceBook$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSourceMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    races<T extends SourceBook$racesArgs<ExtArgs> = {}>(args?: Subset<T, SourceBook$racesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceSourceMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spells<T extends SourceBook$spellsArgs<ExtArgs> = {}>(args?: Subset<T, SourceBook$spellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellSourceMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SourceBook model
   */
  interface SourceBookFieldRefs {
    readonly id: FieldRef<"SourceBook", 'Int'>
    readonly name: FieldRef<"SourceBook", 'String'>
    readonly abbreviation: FieldRef<"SourceBook", 'String'>
    readonly releaseDate: FieldRef<"SourceBook", 'DateTime'>
    readonly editionId: FieldRef<"SourceBook", 'Int'>
    readonly description: FieldRef<"SourceBook", 'String'>
    readonly isVisible: FieldRef<"SourceBook", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SourceBook findUnique
   */
  export type SourceBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    /**
     * Filter, which SourceBook to fetch.
     */
    where: SourceBookWhereUniqueInput
  }

  /**
   * SourceBook findUniqueOrThrow
   */
  export type SourceBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    /**
     * Filter, which SourceBook to fetch.
     */
    where: SourceBookWhereUniqueInput
  }

  /**
   * SourceBook findFirst
   */
  export type SourceBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    /**
     * Filter, which SourceBook to fetch.
     */
    where?: SourceBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceBooks to fetch.
     */
    orderBy?: SourceBookOrderByWithRelationInput | SourceBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceBooks.
     */
    cursor?: SourceBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceBooks.
     */
    distinct?: SourceBookScalarFieldEnum | SourceBookScalarFieldEnum[]
  }

  /**
   * SourceBook findFirstOrThrow
   */
  export type SourceBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    /**
     * Filter, which SourceBook to fetch.
     */
    where?: SourceBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceBooks to fetch.
     */
    orderBy?: SourceBookOrderByWithRelationInput | SourceBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceBooks.
     */
    cursor?: SourceBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceBooks.
     */
    distinct?: SourceBookScalarFieldEnum | SourceBookScalarFieldEnum[]
  }

  /**
   * SourceBook findMany
   */
  export type SourceBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    /**
     * Filter, which SourceBooks to fetch.
     */
    where?: SourceBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceBooks to fetch.
     */
    orderBy?: SourceBookOrderByWithRelationInput | SourceBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SourceBooks.
     */
    cursor?: SourceBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceBooks.
     */
    skip?: number
    distinct?: SourceBookScalarFieldEnum | SourceBookScalarFieldEnum[]
  }

  /**
   * SourceBook create
   */
  export type SourceBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    /**
     * The data needed to create a SourceBook.
     */
    data: XOR<SourceBookCreateInput, SourceBookUncheckedCreateInput>
  }

  /**
   * SourceBook createMany
   */
  export type SourceBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SourceBooks.
     */
    data: SourceBookCreateManyInput | SourceBookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceBook update
   */
  export type SourceBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    /**
     * The data needed to update a SourceBook.
     */
    data: XOR<SourceBookUpdateInput, SourceBookUncheckedUpdateInput>
    /**
     * Choose, which SourceBook to update.
     */
    where: SourceBookWhereUniqueInput
  }

  /**
   * SourceBook updateMany
   */
  export type SourceBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SourceBooks.
     */
    data: XOR<SourceBookUpdateManyMutationInput, SourceBookUncheckedUpdateManyInput>
    /**
     * Filter which SourceBooks to update
     */
    where?: SourceBookWhereInput
    /**
     * Limit how many SourceBooks to update.
     */
    limit?: number
  }

  /**
   * SourceBook upsert
   */
  export type SourceBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    /**
     * The filter to search for the SourceBook to update in case it exists.
     */
    where: SourceBookWhereUniqueInput
    /**
     * In case the SourceBook found by the `where` argument doesn't exist, create a new SourceBook with this data.
     */
    create: XOR<SourceBookCreateInput, SourceBookUncheckedCreateInput>
    /**
     * In case the SourceBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceBookUpdateInput, SourceBookUncheckedUpdateInput>
  }

  /**
   * SourceBook delete
   */
  export type SourceBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
    /**
     * Filter which SourceBook to delete.
     */
    where: SourceBookWhereUniqueInput
  }

  /**
   * SourceBook deleteMany
   */
  export type SourceBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceBooks to delete
     */
    where?: SourceBookWhereInput
    /**
     * Limit how many SourceBooks to delete.
     */
    limit?: number
  }

  /**
   * SourceBook.classes
   */
  export type SourceBook$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSourceMap
     */
    select?: ClassSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSourceMap
     */
    omit?: ClassSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSourceMapInclude<ExtArgs> | null
    where?: ClassSourceMapWhereInput
    orderBy?: ClassSourceMapOrderByWithRelationInput | ClassSourceMapOrderByWithRelationInput[]
    cursor?: ClassSourceMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSourceMapScalarFieldEnum | ClassSourceMapScalarFieldEnum[]
  }

  /**
   * SourceBook.races
   */
  export type SourceBook$racesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSourceMap
     */
    select?: RaceSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceSourceMap
     */
    omit?: RaceSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceSourceMapInclude<ExtArgs> | null
    where?: RaceSourceMapWhereInput
    orderBy?: RaceSourceMapOrderByWithRelationInput | RaceSourceMapOrderByWithRelationInput[]
    cursor?: RaceSourceMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceSourceMapScalarFieldEnum | RaceSourceMapScalarFieldEnum[]
  }

  /**
   * SourceBook.spells
   */
  export type SourceBook$spellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSourceMap
     */
    select?: SpellSourceMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellSourceMap
     */
    omit?: SpellSourceMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellSourceMapInclude<ExtArgs> | null
    where?: SpellSourceMapWhereInput
    orderBy?: SpellSourceMapOrderByWithRelationInput | SpellSourceMapOrderByWithRelationInput[]
    cursor?: SpellSourceMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellSourceMapScalarFieldEnum | SpellSourceMapScalarFieldEnum[]
  }

  /**
   * SourceBook without action
   */
  export type SourceBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceBook
     */
    select?: SourceBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceBook
     */
    omit?: SourceBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceBookInclude<ExtArgs> | null
  }


  /**
   * Model ReferenceTable
   */

  export type AggregateReferenceTable = {
    _count: ReferenceTableCountAggregateOutputType | null
    _min: ReferenceTableMinAggregateOutputType | null
    _max: ReferenceTableMaxAggregateOutputType | null
  }

  export type ReferenceTableMinAggregateOutputType = {
    slug: string | null
    name: string | null
    description: string | null
  }

  export type ReferenceTableMaxAggregateOutputType = {
    slug: string | null
    name: string | null
    description: string | null
  }

  export type ReferenceTableCountAggregateOutputType = {
    slug: number
    name: number
    description: number
    _all: number
  }


  export type ReferenceTableMinAggregateInputType = {
    slug?: true
    name?: true
    description?: true
  }

  export type ReferenceTableMaxAggregateInputType = {
    slug?: true
    name?: true
    description?: true
  }

  export type ReferenceTableCountAggregateInputType = {
    slug?: true
    name?: true
    description?: true
    _all?: true
  }

  export type ReferenceTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceTable to aggregate.
     */
    where?: ReferenceTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTables to fetch.
     */
    orderBy?: ReferenceTableOrderByWithRelationInput | ReferenceTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferenceTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferenceTables
    **/
    _count?: true | ReferenceTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferenceTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferenceTableMaxAggregateInputType
  }

  export type GetReferenceTableAggregateType<T extends ReferenceTableAggregateArgs> = {
        [P in keyof T & keyof AggregateReferenceTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferenceTable[P]>
      : GetScalarType<T[P], AggregateReferenceTable[P]>
  }




  export type ReferenceTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceTableWhereInput
    orderBy?: ReferenceTableOrderByWithAggregationInput | ReferenceTableOrderByWithAggregationInput[]
    by: ReferenceTableScalarFieldEnum[] | ReferenceTableScalarFieldEnum
    having?: ReferenceTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferenceTableCountAggregateInputType | true
    _min?: ReferenceTableMinAggregateInputType
    _max?: ReferenceTableMaxAggregateInputType
  }

  export type ReferenceTableGroupByOutputType = {
    slug: string
    name: string
    description: string | null
    _count: ReferenceTableCountAggregateOutputType | null
    _min: ReferenceTableMinAggregateOutputType | null
    _max: ReferenceTableMaxAggregateOutputType | null
  }

  type GetReferenceTableGroupByPayload<T extends ReferenceTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferenceTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferenceTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferenceTableGroupByOutputType[P]>
            : GetScalarType<T[P], ReferenceTableGroupByOutputType[P]>
        }
      >
    >


  export type ReferenceTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    slug?: boolean
    name?: boolean
    description?: boolean
    columns?: boolean | ReferenceTable$columnsArgs<ExtArgs>
    rows?: boolean | ReferenceTable$rowsArgs<ExtArgs>
    _count?: boolean | ReferenceTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referenceTable"]>



  export type ReferenceTableSelectScalar = {
    slug?: boolean
    name?: boolean
    description?: boolean
  }

  export type ReferenceTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"slug" | "name" | "description", ExtArgs["result"]["referenceTable"]>
  export type ReferenceTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    columns?: boolean | ReferenceTable$columnsArgs<ExtArgs>
    rows?: boolean | ReferenceTable$rowsArgs<ExtArgs>
    _count?: boolean | ReferenceTableCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReferenceTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferenceTable"
    objects: {
      columns: Prisma.$ReferenceTableColumnPayload<ExtArgs>[]
      rows: Prisma.$ReferenceTableRowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      slug: string
      name: string
      description: string | null
    }, ExtArgs["result"]["referenceTable"]>
    composites: {}
  }

  type ReferenceTableGetPayload<S extends boolean | null | undefined | ReferenceTableDefaultArgs> = $Result.GetResult<Prisma.$ReferenceTablePayload, S>

  type ReferenceTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferenceTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferenceTableCountAggregateInputType | true
    }

  export interface ReferenceTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferenceTable'], meta: { name: 'ReferenceTable' } }
    /**
     * Find zero or one ReferenceTable that matches the filter.
     * @param {ReferenceTableFindUniqueArgs} args - Arguments to find a ReferenceTable
     * @example
     * // Get one ReferenceTable
     * const referenceTable = await prisma.referenceTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferenceTableFindUniqueArgs>(args: SelectSubset<T, ReferenceTableFindUniqueArgs<ExtArgs>>): Prisma__ReferenceTableClient<$Result.GetResult<Prisma.$ReferenceTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReferenceTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferenceTableFindUniqueOrThrowArgs} args - Arguments to find a ReferenceTable
     * @example
     * // Get one ReferenceTable
     * const referenceTable = await prisma.referenceTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferenceTableFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferenceTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferenceTableClient<$Result.GetResult<Prisma.$ReferenceTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferenceTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableFindFirstArgs} args - Arguments to find a ReferenceTable
     * @example
     * // Get one ReferenceTable
     * const referenceTable = await prisma.referenceTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferenceTableFindFirstArgs>(args?: SelectSubset<T, ReferenceTableFindFirstArgs<ExtArgs>>): Prisma__ReferenceTableClient<$Result.GetResult<Prisma.$ReferenceTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferenceTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableFindFirstOrThrowArgs} args - Arguments to find a ReferenceTable
     * @example
     * // Get one ReferenceTable
     * const referenceTable = await prisma.referenceTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferenceTableFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferenceTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferenceTableClient<$Result.GetResult<Prisma.$ReferenceTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReferenceTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferenceTables
     * const referenceTables = await prisma.referenceTable.findMany()
     * 
     * // Get first 10 ReferenceTables
     * const referenceTables = await prisma.referenceTable.findMany({ take: 10 })
     * 
     * // Only select the `slug`
     * const referenceTableWithSlugOnly = await prisma.referenceTable.findMany({ select: { slug: true } })
     * 
     */
    findMany<T extends ReferenceTableFindManyArgs>(args?: SelectSubset<T, ReferenceTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReferenceTable.
     * @param {ReferenceTableCreateArgs} args - Arguments to create a ReferenceTable.
     * @example
     * // Create one ReferenceTable
     * const ReferenceTable = await prisma.referenceTable.create({
     *   data: {
     *     // ... data to create a ReferenceTable
     *   }
     * })
     * 
     */
    create<T extends ReferenceTableCreateArgs>(args: SelectSubset<T, ReferenceTableCreateArgs<ExtArgs>>): Prisma__ReferenceTableClient<$Result.GetResult<Prisma.$ReferenceTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReferenceTables.
     * @param {ReferenceTableCreateManyArgs} args - Arguments to create many ReferenceTables.
     * @example
     * // Create many ReferenceTables
     * const referenceTable = await prisma.referenceTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferenceTableCreateManyArgs>(args?: SelectSubset<T, ReferenceTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReferenceTable.
     * @param {ReferenceTableDeleteArgs} args - Arguments to delete one ReferenceTable.
     * @example
     * // Delete one ReferenceTable
     * const ReferenceTable = await prisma.referenceTable.delete({
     *   where: {
     *     // ... filter to delete one ReferenceTable
     *   }
     * })
     * 
     */
    delete<T extends ReferenceTableDeleteArgs>(args: SelectSubset<T, ReferenceTableDeleteArgs<ExtArgs>>): Prisma__ReferenceTableClient<$Result.GetResult<Prisma.$ReferenceTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReferenceTable.
     * @param {ReferenceTableUpdateArgs} args - Arguments to update one ReferenceTable.
     * @example
     * // Update one ReferenceTable
     * const referenceTable = await prisma.referenceTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferenceTableUpdateArgs>(args: SelectSubset<T, ReferenceTableUpdateArgs<ExtArgs>>): Prisma__ReferenceTableClient<$Result.GetResult<Prisma.$ReferenceTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReferenceTables.
     * @param {ReferenceTableDeleteManyArgs} args - Arguments to filter ReferenceTables to delete.
     * @example
     * // Delete a few ReferenceTables
     * const { count } = await prisma.referenceTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferenceTableDeleteManyArgs>(args?: SelectSubset<T, ReferenceTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferenceTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferenceTables
     * const referenceTable = await prisma.referenceTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferenceTableUpdateManyArgs>(args: SelectSubset<T, ReferenceTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferenceTable.
     * @param {ReferenceTableUpsertArgs} args - Arguments to update or create a ReferenceTable.
     * @example
     * // Update or create a ReferenceTable
     * const referenceTable = await prisma.referenceTable.upsert({
     *   create: {
     *     // ... data to create a ReferenceTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferenceTable we want to update
     *   }
     * })
     */
    upsert<T extends ReferenceTableUpsertArgs>(args: SelectSubset<T, ReferenceTableUpsertArgs<ExtArgs>>): Prisma__ReferenceTableClient<$Result.GetResult<Prisma.$ReferenceTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReferenceTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableCountArgs} args - Arguments to filter ReferenceTables to count.
     * @example
     * // Count the number of ReferenceTables
     * const count = await prisma.referenceTable.count({
     *   where: {
     *     // ... the filter for the ReferenceTables we want to count
     *   }
     * })
    **/
    count<T extends ReferenceTableCountArgs>(
      args?: Subset<T, ReferenceTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferenceTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferenceTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferenceTableAggregateArgs>(args: Subset<T, ReferenceTableAggregateArgs>): Prisma.PrismaPromise<GetReferenceTableAggregateType<T>>

    /**
     * Group by ReferenceTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferenceTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferenceTableGroupByArgs['orderBy'] }
        : { orderBy?: ReferenceTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferenceTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferenceTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferenceTable model
   */
  readonly fields: ReferenceTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferenceTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferenceTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    columns<T extends ReferenceTable$columnsArgs<ExtArgs> = {}>(args?: Subset<T, ReferenceTable$columnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceTableColumnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rows<T extends ReferenceTable$rowsArgs<ExtArgs> = {}>(args?: Subset<T, ReferenceTable$rowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceTableRowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferenceTable model
   */
  interface ReferenceTableFieldRefs {
    readonly slug: FieldRef<"ReferenceTable", 'String'>
    readonly name: FieldRef<"ReferenceTable", 'String'>
    readonly description: FieldRef<"ReferenceTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReferenceTable findUnique
   */
  export type ReferenceTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTable
     */
    select?: ReferenceTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTable
     */
    omit?: ReferenceTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTable to fetch.
     */
    where: ReferenceTableWhereUniqueInput
  }

  /**
   * ReferenceTable findUniqueOrThrow
   */
  export type ReferenceTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTable
     */
    select?: ReferenceTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTable
     */
    omit?: ReferenceTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTable to fetch.
     */
    where: ReferenceTableWhereUniqueInput
  }

  /**
   * ReferenceTable findFirst
   */
  export type ReferenceTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTable
     */
    select?: ReferenceTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTable
     */
    omit?: ReferenceTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTable to fetch.
     */
    where?: ReferenceTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTables to fetch.
     */
    orderBy?: ReferenceTableOrderByWithRelationInput | ReferenceTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceTables.
     */
    cursor?: ReferenceTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceTables.
     */
    distinct?: ReferenceTableScalarFieldEnum | ReferenceTableScalarFieldEnum[]
  }

  /**
   * ReferenceTable findFirstOrThrow
   */
  export type ReferenceTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTable
     */
    select?: ReferenceTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTable
     */
    omit?: ReferenceTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTable to fetch.
     */
    where?: ReferenceTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTables to fetch.
     */
    orderBy?: ReferenceTableOrderByWithRelationInput | ReferenceTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceTables.
     */
    cursor?: ReferenceTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceTables.
     */
    distinct?: ReferenceTableScalarFieldEnum | ReferenceTableScalarFieldEnum[]
  }

  /**
   * ReferenceTable findMany
   */
  export type ReferenceTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTable
     */
    select?: ReferenceTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTable
     */
    omit?: ReferenceTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTables to fetch.
     */
    where?: ReferenceTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTables to fetch.
     */
    orderBy?: ReferenceTableOrderByWithRelationInput | ReferenceTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferenceTables.
     */
    cursor?: ReferenceTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTables.
     */
    skip?: number
    distinct?: ReferenceTableScalarFieldEnum | ReferenceTableScalarFieldEnum[]
  }

  /**
   * ReferenceTable create
   */
  export type ReferenceTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTable
     */
    select?: ReferenceTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTable
     */
    omit?: ReferenceTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferenceTable.
     */
    data: XOR<ReferenceTableCreateInput, ReferenceTableUncheckedCreateInput>
  }

  /**
   * ReferenceTable createMany
   */
  export type ReferenceTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferenceTables.
     */
    data: ReferenceTableCreateManyInput | ReferenceTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferenceTable update
   */
  export type ReferenceTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTable
     */
    select?: ReferenceTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTable
     */
    omit?: ReferenceTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferenceTable.
     */
    data: XOR<ReferenceTableUpdateInput, ReferenceTableUncheckedUpdateInput>
    /**
     * Choose, which ReferenceTable to update.
     */
    where: ReferenceTableWhereUniqueInput
  }

  /**
   * ReferenceTable updateMany
   */
  export type ReferenceTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferenceTables.
     */
    data: XOR<ReferenceTableUpdateManyMutationInput, ReferenceTableUncheckedUpdateManyInput>
    /**
     * Filter which ReferenceTables to update
     */
    where?: ReferenceTableWhereInput
    /**
     * Limit how many ReferenceTables to update.
     */
    limit?: number
  }

  /**
   * ReferenceTable upsert
   */
  export type ReferenceTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTable
     */
    select?: ReferenceTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTable
     */
    omit?: ReferenceTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferenceTable to update in case it exists.
     */
    where: ReferenceTableWhereUniqueInput
    /**
     * In case the ReferenceTable found by the `where` argument doesn't exist, create a new ReferenceTable with this data.
     */
    create: XOR<ReferenceTableCreateInput, ReferenceTableUncheckedCreateInput>
    /**
     * In case the ReferenceTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferenceTableUpdateInput, ReferenceTableUncheckedUpdateInput>
  }

  /**
   * ReferenceTable delete
   */
  export type ReferenceTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTable
     */
    select?: ReferenceTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTable
     */
    omit?: ReferenceTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableInclude<ExtArgs> | null
    /**
     * Filter which ReferenceTable to delete.
     */
    where: ReferenceTableWhereUniqueInput
  }

  /**
   * ReferenceTable deleteMany
   */
  export type ReferenceTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceTables to delete
     */
    where?: ReferenceTableWhereInput
    /**
     * Limit how many ReferenceTables to delete.
     */
    limit?: number
  }

  /**
   * ReferenceTable.columns
   */
  export type ReferenceTable$columnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumn
     */
    select?: ReferenceTableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableColumn
     */
    omit?: ReferenceTableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableColumnInclude<ExtArgs> | null
    where?: ReferenceTableColumnWhereInput
    orderBy?: ReferenceTableColumnOrderByWithRelationInput | ReferenceTableColumnOrderByWithRelationInput[]
    cursor?: ReferenceTableColumnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferenceTableColumnScalarFieldEnum | ReferenceTableColumnScalarFieldEnum[]
  }

  /**
   * ReferenceTable.rows
   */
  export type ReferenceTable$rowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRow
     */
    select?: ReferenceTableRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableRow
     */
    omit?: ReferenceTableRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableRowInclude<ExtArgs> | null
    where?: ReferenceTableRowWhereInput
    orderBy?: ReferenceTableRowOrderByWithRelationInput | ReferenceTableRowOrderByWithRelationInput[]
    cursor?: ReferenceTableRowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferenceTableRowScalarFieldEnum | ReferenceTableRowScalarFieldEnum[]
  }

  /**
   * ReferenceTable without action
   */
  export type ReferenceTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTable
     */
    select?: ReferenceTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTable
     */
    omit?: ReferenceTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableInclude<ExtArgs> | null
  }


  /**
   * Model ReferenceTableColumn
   */

  export type AggregateReferenceTableColumn = {
    _count: ReferenceTableColumnCountAggregateOutputType | null
    _avg: ReferenceTableColumnAvgAggregateOutputType | null
    _sum: ReferenceTableColumnSumAggregateOutputType | null
    _min: ReferenceTableColumnMinAggregateOutputType | null
    _max: ReferenceTableColumnMaxAggregateOutputType | null
  }

  export type ReferenceTableColumnAvgAggregateOutputType = {
    id: number | null
    columnIndex: number | null
    span: number | null
  }

  export type ReferenceTableColumnSumAggregateOutputType = {
    id: number | null
    columnIndex: number | null
    span: number | null
  }

  export type ReferenceTableColumnMinAggregateOutputType = {
    id: number | null
    tableSlug: string | null
    columnIndex: number | null
    header: string | null
    span: number | null
    alignment: string | null
  }

  export type ReferenceTableColumnMaxAggregateOutputType = {
    id: number | null
    tableSlug: string | null
    columnIndex: number | null
    header: string | null
    span: number | null
    alignment: string | null
  }

  export type ReferenceTableColumnCountAggregateOutputType = {
    id: number
    tableSlug: number
    columnIndex: number
    header: number
    span: number
    alignment: number
    _all: number
  }


  export type ReferenceTableColumnAvgAggregateInputType = {
    id?: true
    columnIndex?: true
    span?: true
  }

  export type ReferenceTableColumnSumAggregateInputType = {
    id?: true
    columnIndex?: true
    span?: true
  }

  export type ReferenceTableColumnMinAggregateInputType = {
    id?: true
    tableSlug?: true
    columnIndex?: true
    header?: true
    span?: true
    alignment?: true
  }

  export type ReferenceTableColumnMaxAggregateInputType = {
    id?: true
    tableSlug?: true
    columnIndex?: true
    header?: true
    span?: true
    alignment?: true
  }

  export type ReferenceTableColumnCountAggregateInputType = {
    id?: true
    tableSlug?: true
    columnIndex?: true
    header?: true
    span?: true
    alignment?: true
    _all?: true
  }

  export type ReferenceTableColumnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceTableColumn to aggregate.
     */
    where?: ReferenceTableColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableColumns to fetch.
     */
    orderBy?: ReferenceTableColumnOrderByWithRelationInput | ReferenceTableColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferenceTableColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferenceTableColumns
    **/
    _count?: true | ReferenceTableColumnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferenceTableColumnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferenceTableColumnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferenceTableColumnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferenceTableColumnMaxAggregateInputType
  }

  export type GetReferenceTableColumnAggregateType<T extends ReferenceTableColumnAggregateArgs> = {
        [P in keyof T & keyof AggregateReferenceTableColumn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferenceTableColumn[P]>
      : GetScalarType<T[P], AggregateReferenceTableColumn[P]>
  }




  export type ReferenceTableColumnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceTableColumnWhereInput
    orderBy?: ReferenceTableColumnOrderByWithAggregationInput | ReferenceTableColumnOrderByWithAggregationInput[]
    by: ReferenceTableColumnScalarFieldEnum[] | ReferenceTableColumnScalarFieldEnum
    having?: ReferenceTableColumnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferenceTableColumnCountAggregateInputType | true
    _avg?: ReferenceTableColumnAvgAggregateInputType
    _sum?: ReferenceTableColumnSumAggregateInputType
    _min?: ReferenceTableColumnMinAggregateInputType
    _max?: ReferenceTableColumnMaxAggregateInputType
  }

  export type ReferenceTableColumnGroupByOutputType = {
    id: number
    tableSlug: string
    columnIndex: number
    header: string
    span: number | null
    alignment: string | null
    _count: ReferenceTableColumnCountAggregateOutputType | null
    _avg: ReferenceTableColumnAvgAggregateOutputType | null
    _sum: ReferenceTableColumnSumAggregateOutputType | null
    _min: ReferenceTableColumnMinAggregateOutputType | null
    _max: ReferenceTableColumnMaxAggregateOutputType | null
  }

  type GetReferenceTableColumnGroupByPayload<T extends ReferenceTableColumnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferenceTableColumnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferenceTableColumnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferenceTableColumnGroupByOutputType[P]>
            : GetScalarType<T[P], ReferenceTableColumnGroupByOutputType[P]>
        }
      >
    >


  export type ReferenceTableColumnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableSlug?: boolean
    columnIndex?: boolean
    header?: boolean
    span?: boolean
    alignment?: boolean
    cells?: boolean | ReferenceTableColumn$cellsArgs<ExtArgs>
    table?: boolean | ReferenceTableDefaultArgs<ExtArgs>
    _count?: boolean | ReferenceTableColumnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referenceTableColumn"]>



  export type ReferenceTableColumnSelectScalar = {
    id?: boolean
    tableSlug?: boolean
    columnIndex?: boolean
    header?: boolean
    span?: boolean
    alignment?: boolean
  }

  export type ReferenceTableColumnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableSlug" | "columnIndex" | "header" | "span" | "alignment", ExtArgs["result"]["referenceTableColumn"]>
  export type ReferenceTableColumnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cells?: boolean | ReferenceTableColumn$cellsArgs<ExtArgs>
    table?: boolean | ReferenceTableDefaultArgs<ExtArgs>
    _count?: boolean | ReferenceTableColumnCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReferenceTableColumnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferenceTableColumn"
    objects: {
      cells: Prisma.$ReferenceTableCellPayload<ExtArgs>[]
      table: Prisma.$ReferenceTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tableSlug: string
      columnIndex: number
      header: string
      span: number | null
      alignment: string | null
    }, ExtArgs["result"]["referenceTableColumn"]>
    composites: {}
  }

  type ReferenceTableColumnGetPayload<S extends boolean | null | undefined | ReferenceTableColumnDefaultArgs> = $Result.GetResult<Prisma.$ReferenceTableColumnPayload, S>

  type ReferenceTableColumnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferenceTableColumnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferenceTableColumnCountAggregateInputType | true
    }

  export interface ReferenceTableColumnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferenceTableColumn'], meta: { name: 'ReferenceTableColumn' } }
    /**
     * Find zero or one ReferenceTableColumn that matches the filter.
     * @param {ReferenceTableColumnFindUniqueArgs} args - Arguments to find a ReferenceTableColumn
     * @example
     * // Get one ReferenceTableColumn
     * const referenceTableColumn = await prisma.referenceTableColumn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferenceTableColumnFindUniqueArgs>(args: SelectSubset<T, ReferenceTableColumnFindUniqueArgs<ExtArgs>>): Prisma__ReferenceTableColumnClient<$Result.GetResult<Prisma.$ReferenceTableColumnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReferenceTableColumn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferenceTableColumnFindUniqueOrThrowArgs} args - Arguments to find a ReferenceTableColumn
     * @example
     * // Get one ReferenceTableColumn
     * const referenceTableColumn = await prisma.referenceTableColumn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferenceTableColumnFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferenceTableColumnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferenceTableColumnClient<$Result.GetResult<Prisma.$ReferenceTableColumnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferenceTableColumn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableColumnFindFirstArgs} args - Arguments to find a ReferenceTableColumn
     * @example
     * // Get one ReferenceTableColumn
     * const referenceTableColumn = await prisma.referenceTableColumn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferenceTableColumnFindFirstArgs>(args?: SelectSubset<T, ReferenceTableColumnFindFirstArgs<ExtArgs>>): Prisma__ReferenceTableColumnClient<$Result.GetResult<Prisma.$ReferenceTableColumnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferenceTableColumn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableColumnFindFirstOrThrowArgs} args - Arguments to find a ReferenceTableColumn
     * @example
     * // Get one ReferenceTableColumn
     * const referenceTableColumn = await prisma.referenceTableColumn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferenceTableColumnFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferenceTableColumnFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferenceTableColumnClient<$Result.GetResult<Prisma.$ReferenceTableColumnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReferenceTableColumns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableColumnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferenceTableColumns
     * const referenceTableColumns = await prisma.referenceTableColumn.findMany()
     * 
     * // Get first 10 ReferenceTableColumns
     * const referenceTableColumns = await prisma.referenceTableColumn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referenceTableColumnWithIdOnly = await prisma.referenceTableColumn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferenceTableColumnFindManyArgs>(args?: SelectSubset<T, ReferenceTableColumnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceTableColumnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReferenceTableColumn.
     * @param {ReferenceTableColumnCreateArgs} args - Arguments to create a ReferenceTableColumn.
     * @example
     * // Create one ReferenceTableColumn
     * const ReferenceTableColumn = await prisma.referenceTableColumn.create({
     *   data: {
     *     // ... data to create a ReferenceTableColumn
     *   }
     * })
     * 
     */
    create<T extends ReferenceTableColumnCreateArgs>(args: SelectSubset<T, ReferenceTableColumnCreateArgs<ExtArgs>>): Prisma__ReferenceTableColumnClient<$Result.GetResult<Prisma.$ReferenceTableColumnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReferenceTableColumns.
     * @param {ReferenceTableColumnCreateManyArgs} args - Arguments to create many ReferenceTableColumns.
     * @example
     * // Create many ReferenceTableColumns
     * const referenceTableColumn = await prisma.referenceTableColumn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferenceTableColumnCreateManyArgs>(args?: SelectSubset<T, ReferenceTableColumnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReferenceTableColumn.
     * @param {ReferenceTableColumnDeleteArgs} args - Arguments to delete one ReferenceTableColumn.
     * @example
     * // Delete one ReferenceTableColumn
     * const ReferenceTableColumn = await prisma.referenceTableColumn.delete({
     *   where: {
     *     // ... filter to delete one ReferenceTableColumn
     *   }
     * })
     * 
     */
    delete<T extends ReferenceTableColumnDeleteArgs>(args: SelectSubset<T, ReferenceTableColumnDeleteArgs<ExtArgs>>): Prisma__ReferenceTableColumnClient<$Result.GetResult<Prisma.$ReferenceTableColumnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReferenceTableColumn.
     * @param {ReferenceTableColumnUpdateArgs} args - Arguments to update one ReferenceTableColumn.
     * @example
     * // Update one ReferenceTableColumn
     * const referenceTableColumn = await prisma.referenceTableColumn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferenceTableColumnUpdateArgs>(args: SelectSubset<T, ReferenceTableColumnUpdateArgs<ExtArgs>>): Prisma__ReferenceTableColumnClient<$Result.GetResult<Prisma.$ReferenceTableColumnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReferenceTableColumns.
     * @param {ReferenceTableColumnDeleteManyArgs} args - Arguments to filter ReferenceTableColumns to delete.
     * @example
     * // Delete a few ReferenceTableColumns
     * const { count } = await prisma.referenceTableColumn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferenceTableColumnDeleteManyArgs>(args?: SelectSubset<T, ReferenceTableColumnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferenceTableColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableColumnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferenceTableColumns
     * const referenceTableColumn = await prisma.referenceTableColumn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferenceTableColumnUpdateManyArgs>(args: SelectSubset<T, ReferenceTableColumnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferenceTableColumn.
     * @param {ReferenceTableColumnUpsertArgs} args - Arguments to update or create a ReferenceTableColumn.
     * @example
     * // Update or create a ReferenceTableColumn
     * const referenceTableColumn = await prisma.referenceTableColumn.upsert({
     *   create: {
     *     // ... data to create a ReferenceTableColumn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferenceTableColumn we want to update
     *   }
     * })
     */
    upsert<T extends ReferenceTableColumnUpsertArgs>(args: SelectSubset<T, ReferenceTableColumnUpsertArgs<ExtArgs>>): Prisma__ReferenceTableColumnClient<$Result.GetResult<Prisma.$ReferenceTableColumnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReferenceTableColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableColumnCountArgs} args - Arguments to filter ReferenceTableColumns to count.
     * @example
     * // Count the number of ReferenceTableColumns
     * const count = await prisma.referenceTableColumn.count({
     *   where: {
     *     // ... the filter for the ReferenceTableColumns we want to count
     *   }
     * })
    **/
    count<T extends ReferenceTableColumnCountArgs>(
      args?: Subset<T, ReferenceTableColumnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferenceTableColumnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferenceTableColumn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableColumnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferenceTableColumnAggregateArgs>(args: Subset<T, ReferenceTableColumnAggregateArgs>): Prisma.PrismaPromise<GetReferenceTableColumnAggregateType<T>>

    /**
     * Group by ReferenceTableColumn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableColumnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferenceTableColumnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferenceTableColumnGroupByArgs['orderBy'] }
        : { orderBy?: ReferenceTableColumnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferenceTableColumnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferenceTableColumnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferenceTableColumn model
   */
  readonly fields: ReferenceTableColumnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferenceTableColumn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferenceTableColumnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cells<T extends ReferenceTableColumn$cellsArgs<ExtArgs> = {}>(args?: Subset<T, ReferenceTableColumn$cellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceTableCellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    table<T extends ReferenceTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReferenceTableDefaultArgs<ExtArgs>>): Prisma__ReferenceTableClient<$Result.GetResult<Prisma.$ReferenceTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferenceTableColumn model
   */
  interface ReferenceTableColumnFieldRefs {
    readonly id: FieldRef<"ReferenceTableColumn", 'Int'>
    readonly tableSlug: FieldRef<"ReferenceTableColumn", 'String'>
    readonly columnIndex: FieldRef<"ReferenceTableColumn", 'Int'>
    readonly header: FieldRef<"ReferenceTableColumn", 'String'>
    readonly span: FieldRef<"ReferenceTableColumn", 'Int'>
    readonly alignment: FieldRef<"ReferenceTableColumn", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReferenceTableColumn findUnique
   */
  export type ReferenceTableColumnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumn
     */
    select?: ReferenceTableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableColumn
     */
    omit?: ReferenceTableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableColumnInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableColumn to fetch.
     */
    where: ReferenceTableColumnWhereUniqueInput
  }

  /**
   * ReferenceTableColumn findUniqueOrThrow
   */
  export type ReferenceTableColumnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumn
     */
    select?: ReferenceTableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableColumn
     */
    omit?: ReferenceTableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableColumnInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableColumn to fetch.
     */
    where: ReferenceTableColumnWhereUniqueInput
  }

  /**
   * ReferenceTableColumn findFirst
   */
  export type ReferenceTableColumnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumn
     */
    select?: ReferenceTableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableColumn
     */
    omit?: ReferenceTableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableColumnInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableColumn to fetch.
     */
    where?: ReferenceTableColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableColumns to fetch.
     */
    orderBy?: ReferenceTableColumnOrderByWithRelationInput | ReferenceTableColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceTableColumns.
     */
    cursor?: ReferenceTableColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceTableColumns.
     */
    distinct?: ReferenceTableColumnScalarFieldEnum | ReferenceTableColumnScalarFieldEnum[]
  }

  /**
   * ReferenceTableColumn findFirstOrThrow
   */
  export type ReferenceTableColumnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumn
     */
    select?: ReferenceTableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableColumn
     */
    omit?: ReferenceTableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableColumnInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableColumn to fetch.
     */
    where?: ReferenceTableColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableColumns to fetch.
     */
    orderBy?: ReferenceTableColumnOrderByWithRelationInput | ReferenceTableColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceTableColumns.
     */
    cursor?: ReferenceTableColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceTableColumns.
     */
    distinct?: ReferenceTableColumnScalarFieldEnum | ReferenceTableColumnScalarFieldEnum[]
  }

  /**
   * ReferenceTableColumn findMany
   */
  export type ReferenceTableColumnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumn
     */
    select?: ReferenceTableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableColumn
     */
    omit?: ReferenceTableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableColumnInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableColumns to fetch.
     */
    where?: ReferenceTableColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableColumns to fetch.
     */
    orderBy?: ReferenceTableColumnOrderByWithRelationInput | ReferenceTableColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferenceTableColumns.
     */
    cursor?: ReferenceTableColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableColumns.
     */
    skip?: number
    distinct?: ReferenceTableColumnScalarFieldEnum | ReferenceTableColumnScalarFieldEnum[]
  }

  /**
   * ReferenceTableColumn create
   */
  export type ReferenceTableColumnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumn
     */
    select?: ReferenceTableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableColumn
     */
    omit?: ReferenceTableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableColumnInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferenceTableColumn.
     */
    data: XOR<ReferenceTableColumnCreateInput, ReferenceTableColumnUncheckedCreateInput>
  }

  /**
   * ReferenceTableColumn createMany
   */
  export type ReferenceTableColumnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferenceTableColumns.
     */
    data: ReferenceTableColumnCreateManyInput | ReferenceTableColumnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferenceTableColumn update
   */
  export type ReferenceTableColumnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumn
     */
    select?: ReferenceTableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableColumn
     */
    omit?: ReferenceTableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableColumnInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferenceTableColumn.
     */
    data: XOR<ReferenceTableColumnUpdateInput, ReferenceTableColumnUncheckedUpdateInput>
    /**
     * Choose, which ReferenceTableColumn to update.
     */
    where: ReferenceTableColumnWhereUniqueInput
  }

  /**
   * ReferenceTableColumn updateMany
   */
  export type ReferenceTableColumnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferenceTableColumns.
     */
    data: XOR<ReferenceTableColumnUpdateManyMutationInput, ReferenceTableColumnUncheckedUpdateManyInput>
    /**
     * Filter which ReferenceTableColumns to update
     */
    where?: ReferenceTableColumnWhereInput
    /**
     * Limit how many ReferenceTableColumns to update.
     */
    limit?: number
  }

  /**
   * ReferenceTableColumn upsert
   */
  export type ReferenceTableColumnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumn
     */
    select?: ReferenceTableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableColumn
     */
    omit?: ReferenceTableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableColumnInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferenceTableColumn to update in case it exists.
     */
    where: ReferenceTableColumnWhereUniqueInput
    /**
     * In case the ReferenceTableColumn found by the `where` argument doesn't exist, create a new ReferenceTableColumn with this data.
     */
    create: XOR<ReferenceTableColumnCreateInput, ReferenceTableColumnUncheckedCreateInput>
    /**
     * In case the ReferenceTableColumn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferenceTableColumnUpdateInput, ReferenceTableColumnUncheckedUpdateInput>
  }

  /**
   * ReferenceTableColumn delete
   */
  export type ReferenceTableColumnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumn
     */
    select?: ReferenceTableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableColumn
     */
    omit?: ReferenceTableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableColumnInclude<ExtArgs> | null
    /**
     * Filter which ReferenceTableColumn to delete.
     */
    where: ReferenceTableColumnWhereUniqueInput
  }

  /**
   * ReferenceTableColumn deleteMany
   */
  export type ReferenceTableColumnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceTableColumns to delete
     */
    where?: ReferenceTableColumnWhereInput
    /**
     * Limit how many ReferenceTableColumns to delete.
     */
    limit?: number
  }

  /**
   * ReferenceTableColumn.cells
   */
  export type ReferenceTableColumn$cellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
    where?: ReferenceTableCellWhereInput
    orderBy?: ReferenceTableCellOrderByWithRelationInput | ReferenceTableCellOrderByWithRelationInput[]
    cursor?: ReferenceTableCellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferenceTableCellScalarFieldEnum | ReferenceTableCellScalarFieldEnum[]
  }

  /**
   * ReferenceTableColumn without action
   */
  export type ReferenceTableColumnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableColumn
     */
    select?: ReferenceTableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableColumn
     */
    omit?: ReferenceTableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableColumnInclude<ExtArgs> | null
  }


  /**
   * Model ReferenceTableRow
   */

  export type AggregateReferenceTableRow = {
    _count: ReferenceTableRowCountAggregateOutputType | null
    _avg: ReferenceTableRowAvgAggregateOutputType | null
    _sum: ReferenceTableRowSumAggregateOutputType | null
    _min: ReferenceTableRowMinAggregateOutputType | null
    _max: ReferenceTableRowMaxAggregateOutputType | null
  }

  export type ReferenceTableRowAvgAggregateOutputType = {
    id: number | null
    rowIndex: number | null
  }

  export type ReferenceTableRowSumAggregateOutputType = {
    id: number | null
    rowIndex: number | null
  }

  export type ReferenceTableRowMinAggregateOutputType = {
    id: number | null
    tableSlug: string | null
    rowIndex: number | null
    label: string | null
  }

  export type ReferenceTableRowMaxAggregateOutputType = {
    id: number | null
    tableSlug: string | null
    rowIndex: number | null
    label: string | null
  }

  export type ReferenceTableRowCountAggregateOutputType = {
    id: number
    tableSlug: number
    rowIndex: number
    label: number
    _all: number
  }


  export type ReferenceTableRowAvgAggregateInputType = {
    id?: true
    rowIndex?: true
  }

  export type ReferenceTableRowSumAggregateInputType = {
    id?: true
    rowIndex?: true
  }

  export type ReferenceTableRowMinAggregateInputType = {
    id?: true
    tableSlug?: true
    rowIndex?: true
    label?: true
  }

  export type ReferenceTableRowMaxAggregateInputType = {
    id?: true
    tableSlug?: true
    rowIndex?: true
    label?: true
  }

  export type ReferenceTableRowCountAggregateInputType = {
    id?: true
    tableSlug?: true
    rowIndex?: true
    label?: true
    _all?: true
  }

  export type ReferenceTableRowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceTableRow to aggregate.
     */
    where?: ReferenceTableRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableRows to fetch.
     */
    orderBy?: ReferenceTableRowOrderByWithRelationInput | ReferenceTableRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferenceTableRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferenceTableRows
    **/
    _count?: true | ReferenceTableRowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferenceTableRowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferenceTableRowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferenceTableRowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferenceTableRowMaxAggregateInputType
  }

  export type GetReferenceTableRowAggregateType<T extends ReferenceTableRowAggregateArgs> = {
        [P in keyof T & keyof AggregateReferenceTableRow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferenceTableRow[P]>
      : GetScalarType<T[P], AggregateReferenceTableRow[P]>
  }




  export type ReferenceTableRowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceTableRowWhereInput
    orderBy?: ReferenceTableRowOrderByWithAggregationInput | ReferenceTableRowOrderByWithAggregationInput[]
    by: ReferenceTableRowScalarFieldEnum[] | ReferenceTableRowScalarFieldEnum
    having?: ReferenceTableRowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferenceTableRowCountAggregateInputType | true
    _avg?: ReferenceTableRowAvgAggregateInputType
    _sum?: ReferenceTableRowSumAggregateInputType
    _min?: ReferenceTableRowMinAggregateInputType
    _max?: ReferenceTableRowMaxAggregateInputType
  }

  export type ReferenceTableRowGroupByOutputType = {
    id: number
    tableSlug: string
    rowIndex: number
    label: string | null
    _count: ReferenceTableRowCountAggregateOutputType | null
    _avg: ReferenceTableRowAvgAggregateOutputType | null
    _sum: ReferenceTableRowSumAggregateOutputType | null
    _min: ReferenceTableRowMinAggregateOutputType | null
    _max: ReferenceTableRowMaxAggregateOutputType | null
  }

  type GetReferenceTableRowGroupByPayload<T extends ReferenceTableRowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferenceTableRowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferenceTableRowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferenceTableRowGroupByOutputType[P]>
            : GetScalarType<T[P], ReferenceTableRowGroupByOutputType[P]>
        }
      >
    >


  export type ReferenceTableRowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableSlug?: boolean
    rowIndex?: boolean
    label?: boolean
    cells?: boolean | ReferenceTableRow$cellsArgs<ExtArgs>
    table?: boolean | ReferenceTableDefaultArgs<ExtArgs>
    _count?: boolean | ReferenceTableRowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referenceTableRow"]>



  export type ReferenceTableRowSelectScalar = {
    id?: boolean
    tableSlug?: boolean
    rowIndex?: boolean
    label?: boolean
  }

  export type ReferenceTableRowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableSlug" | "rowIndex" | "label", ExtArgs["result"]["referenceTableRow"]>
  export type ReferenceTableRowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cells?: boolean | ReferenceTableRow$cellsArgs<ExtArgs>
    table?: boolean | ReferenceTableDefaultArgs<ExtArgs>
    _count?: boolean | ReferenceTableRowCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReferenceTableRowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferenceTableRow"
    objects: {
      cells: Prisma.$ReferenceTableCellPayload<ExtArgs>[]
      table: Prisma.$ReferenceTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tableSlug: string
      rowIndex: number
      label: string | null
    }, ExtArgs["result"]["referenceTableRow"]>
    composites: {}
  }

  type ReferenceTableRowGetPayload<S extends boolean | null | undefined | ReferenceTableRowDefaultArgs> = $Result.GetResult<Prisma.$ReferenceTableRowPayload, S>

  type ReferenceTableRowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferenceTableRowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferenceTableRowCountAggregateInputType | true
    }

  export interface ReferenceTableRowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferenceTableRow'], meta: { name: 'ReferenceTableRow' } }
    /**
     * Find zero or one ReferenceTableRow that matches the filter.
     * @param {ReferenceTableRowFindUniqueArgs} args - Arguments to find a ReferenceTableRow
     * @example
     * // Get one ReferenceTableRow
     * const referenceTableRow = await prisma.referenceTableRow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferenceTableRowFindUniqueArgs>(args: SelectSubset<T, ReferenceTableRowFindUniqueArgs<ExtArgs>>): Prisma__ReferenceTableRowClient<$Result.GetResult<Prisma.$ReferenceTableRowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReferenceTableRow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferenceTableRowFindUniqueOrThrowArgs} args - Arguments to find a ReferenceTableRow
     * @example
     * // Get one ReferenceTableRow
     * const referenceTableRow = await prisma.referenceTableRow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferenceTableRowFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferenceTableRowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferenceTableRowClient<$Result.GetResult<Prisma.$ReferenceTableRowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferenceTableRow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableRowFindFirstArgs} args - Arguments to find a ReferenceTableRow
     * @example
     * // Get one ReferenceTableRow
     * const referenceTableRow = await prisma.referenceTableRow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferenceTableRowFindFirstArgs>(args?: SelectSubset<T, ReferenceTableRowFindFirstArgs<ExtArgs>>): Prisma__ReferenceTableRowClient<$Result.GetResult<Prisma.$ReferenceTableRowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferenceTableRow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableRowFindFirstOrThrowArgs} args - Arguments to find a ReferenceTableRow
     * @example
     * // Get one ReferenceTableRow
     * const referenceTableRow = await prisma.referenceTableRow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferenceTableRowFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferenceTableRowFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferenceTableRowClient<$Result.GetResult<Prisma.$ReferenceTableRowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReferenceTableRows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableRowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferenceTableRows
     * const referenceTableRows = await prisma.referenceTableRow.findMany()
     * 
     * // Get first 10 ReferenceTableRows
     * const referenceTableRows = await prisma.referenceTableRow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referenceTableRowWithIdOnly = await prisma.referenceTableRow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferenceTableRowFindManyArgs>(args?: SelectSubset<T, ReferenceTableRowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceTableRowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReferenceTableRow.
     * @param {ReferenceTableRowCreateArgs} args - Arguments to create a ReferenceTableRow.
     * @example
     * // Create one ReferenceTableRow
     * const ReferenceTableRow = await prisma.referenceTableRow.create({
     *   data: {
     *     // ... data to create a ReferenceTableRow
     *   }
     * })
     * 
     */
    create<T extends ReferenceTableRowCreateArgs>(args: SelectSubset<T, ReferenceTableRowCreateArgs<ExtArgs>>): Prisma__ReferenceTableRowClient<$Result.GetResult<Prisma.$ReferenceTableRowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReferenceTableRows.
     * @param {ReferenceTableRowCreateManyArgs} args - Arguments to create many ReferenceTableRows.
     * @example
     * // Create many ReferenceTableRows
     * const referenceTableRow = await prisma.referenceTableRow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferenceTableRowCreateManyArgs>(args?: SelectSubset<T, ReferenceTableRowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReferenceTableRow.
     * @param {ReferenceTableRowDeleteArgs} args - Arguments to delete one ReferenceTableRow.
     * @example
     * // Delete one ReferenceTableRow
     * const ReferenceTableRow = await prisma.referenceTableRow.delete({
     *   where: {
     *     // ... filter to delete one ReferenceTableRow
     *   }
     * })
     * 
     */
    delete<T extends ReferenceTableRowDeleteArgs>(args: SelectSubset<T, ReferenceTableRowDeleteArgs<ExtArgs>>): Prisma__ReferenceTableRowClient<$Result.GetResult<Prisma.$ReferenceTableRowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReferenceTableRow.
     * @param {ReferenceTableRowUpdateArgs} args - Arguments to update one ReferenceTableRow.
     * @example
     * // Update one ReferenceTableRow
     * const referenceTableRow = await prisma.referenceTableRow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferenceTableRowUpdateArgs>(args: SelectSubset<T, ReferenceTableRowUpdateArgs<ExtArgs>>): Prisma__ReferenceTableRowClient<$Result.GetResult<Prisma.$ReferenceTableRowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReferenceTableRows.
     * @param {ReferenceTableRowDeleteManyArgs} args - Arguments to filter ReferenceTableRows to delete.
     * @example
     * // Delete a few ReferenceTableRows
     * const { count } = await prisma.referenceTableRow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferenceTableRowDeleteManyArgs>(args?: SelectSubset<T, ReferenceTableRowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferenceTableRows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableRowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferenceTableRows
     * const referenceTableRow = await prisma.referenceTableRow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferenceTableRowUpdateManyArgs>(args: SelectSubset<T, ReferenceTableRowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferenceTableRow.
     * @param {ReferenceTableRowUpsertArgs} args - Arguments to update or create a ReferenceTableRow.
     * @example
     * // Update or create a ReferenceTableRow
     * const referenceTableRow = await prisma.referenceTableRow.upsert({
     *   create: {
     *     // ... data to create a ReferenceTableRow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferenceTableRow we want to update
     *   }
     * })
     */
    upsert<T extends ReferenceTableRowUpsertArgs>(args: SelectSubset<T, ReferenceTableRowUpsertArgs<ExtArgs>>): Prisma__ReferenceTableRowClient<$Result.GetResult<Prisma.$ReferenceTableRowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReferenceTableRows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableRowCountArgs} args - Arguments to filter ReferenceTableRows to count.
     * @example
     * // Count the number of ReferenceTableRows
     * const count = await prisma.referenceTableRow.count({
     *   where: {
     *     // ... the filter for the ReferenceTableRows we want to count
     *   }
     * })
    **/
    count<T extends ReferenceTableRowCountArgs>(
      args?: Subset<T, ReferenceTableRowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferenceTableRowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferenceTableRow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableRowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferenceTableRowAggregateArgs>(args: Subset<T, ReferenceTableRowAggregateArgs>): Prisma.PrismaPromise<GetReferenceTableRowAggregateType<T>>

    /**
     * Group by ReferenceTableRow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableRowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferenceTableRowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferenceTableRowGroupByArgs['orderBy'] }
        : { orderBy?: ReferenceTableRowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferenceTableRowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferenceTableRowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferenceTableRow model
   */
  readonly fields: ReferenceTableRowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferenceTableRow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferenceTableRowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cells<T extends ReferenceTableRow$cellsArgs<ExtArgs> = {}>(args?: Subset<T, ReferenceTableRow$cellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceTableCellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    table<T extends ReferenceTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReferenceTableDefaultArgs<ExtArgs>>): Prisma__ReferenceTableClient<$Result.GetResult<Prisma.$ReferenceTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferenceTableRow model
   */
  interface ReferenceTableRowFieldRefs {
    readonly id: FieldRef<"ReferenceTableRow", 'Int'>
    readonly tableSlug: FieldRef<"ReferenceTableRow", 'String'>
    readonly rowIndex: FieldRef<"ReferenceTableRow", 'Int'>
    readonly label: FieldRef<"ReferenceTableRow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReferenceTableRow findUnique
   */
  export type ReferenceTableRowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRow
     */
    select?: ReferenceTableRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableRow
     */
    omit?: ReferenceTableRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableRowInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableRow to fetch.
     */
    where: ReferenceTableRowWhereUniqueInput
  }

  /**
   * ReferenceTableRow findUniqueOrThrow
   */
  export type ReferenceTableRowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRow
     */
    select?: ReferenceTableRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableRow
     */
    omit?: ReferenceTableRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableRowInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableRow to fetch.
     */
    where: ReferenceTableRowWhereUniqueInput
  }

  /**
   * ReferenceTableRow findFirst
   */
  export type ReferenceTableRowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRow
     */
    select?: ReferenceTableRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableRow
     */
    omit?: ReferenceTableRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableRowInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableRow to fetch.
     */
    where?: ReferenceTableRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableRows to fetch.
     */
    orderBy?: ReferenceTableRowOrderByWithRelationInput | ReferenceTableRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceTableRows.
     */
    cursor?: ReferenceTableRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceTableRows.
     */
    distinct?: ReferenceTableRowScalarFieldEnum | ReferenceTableRowScalarFieldEnum[]
  }

  /**
   * ReferenceTableRow findFirstOrThrow
   */
  export type ReferenceTableRowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRow
     */
    select?: ReferenceTableRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableRow
     */
    omit?: ReferenceTableRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableRowInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableRow to fetch.
     */
    where?: ReferenceTableRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableRows to fetch.
     */
    orderBy?: ReferenceTableRowOrderByWithRelationInput | ReferenceTableRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceTableRows.
     */
    cursor?: ReferenceTableRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceTableRows.
     */
    distinct?: ReferenceTableRowScalarFieldEnum | ReferenceTableRowScalarFieldEnum[]
  }

  /**
   * ReferenceTableRow findMany
   */
  export type ReferenceTableRowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRow
     */
    select?: ReferenceTableRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableRow
     */
    omit?: ReferenceTableRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableRowInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableRows to fetch.
     */
    where?: ReferenceTableRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableRows to fetch.
     */
    orderBy?: ReferenceTableRowOrderByWithRelationInput | ReferenceTableRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferenceTableRows.
     */
    cursor?: ReferenceTableRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableRows.
     */
    skip?: number
    distinct?: ReferenceTableRowScalarFieldEnum | ReferenceTableRowScalarFieldEnum[]
  }

  /**
   * ReferenceTableRow create
   */
  export type ReferenceTableRowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRow
     */
    select?: ReferenceTableRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableRow
     */
    omit?: ReferenceTableRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableRowInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferenceTableRow.
     */
    data: XOR<ReferenceTableRowCreateInput, ReferenceTableRowUncheckedCreateInput>
  }

  /**
   * ReferenceTableRow createMany
   */
  export type ReferenceTableRowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferenceTableRows.
     */
    data: ReferenceTableRowCreateManyInput | ReferenceTableRowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferenceTableRow update
   */
  export type ReferenceTableRowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRow
     */
    select?: ReferenceTableRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableRow
     */
    omit?: ReferenceTableRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableRowInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferenceTableRow.
     */
    data: XOR<ReferenceTableRowUpdateInput, ReferenceTableRowUncheckedUpdateInput>
    /**
     * Choose, which ReferenceTableRow to update.
     */
    where: ReferenceTableRowWhereUniqueInput
  }

  /**
   * ReferenceTableRow updateMany
   */
  export type ReferenceTableRowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferenceTableRows.
     */
    data: XOR<ReferenceTableRowUpdateManyMutationInput, ReferenceTableRowUncheckedUpdateManyInput>
    /**
     * Filter which ReferenceTableRows to update
     */
    where?: ReferenceTableRowWhereInput
    /**
     * Limit how many ReferenceTableRows to update.
     */
    limit?: number
  }

  /**
   * ReferenceTableRow upsert
   */
  export type ReferenceTableRowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRow
     */
    select?: ReferenceTableRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableRow
     */
    omit?: ReferenceTableRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableRowInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferenceTableRow to update in case it exists.
     */
    where: ReferenceTableRowWhereUniqueInput
    /**
     * In case the ReferenceTableRow found by the `where` argument doesn't exist, create a new ReferenceTableRow with this data.
     */
    create: XOR<ReferenceTableRowCreateInput, ReferenceTableRowUncheckedCreateInput>
    /**
     * In case the ReferenceTableRow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferenceTableRowUpdateInput, ReferenceTableRowUncheckedUpdateInput>
  }

  /**
   * ReferenceTableRow delete
   */
  export type ReferenceTableRowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRow
     */
    select?: ReferenceTableRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableRow
     */
    omit?: ReferenceTableRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableRowInclude<ExtArgs> | null
    /**
     * Filter which ReferenceTableRow to delete.
     */
    where: ReferenceTableRowWhereUniqueInput
  }

  /**
   * ReferenceTableRow deleteMany
   */
  export type ReferenceTableRowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceTableRows to delete
     */
    where?: ReferenceTableRowWhereInput
    /**
     * Limit how many ReferenceTableRows to delete.
     */
    limit?: number
  }

  /**
   * ReferenceTableRow.cells
   */
  export type ReferenceTableRow$cellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
    where?: ReferenceTableCellWhereInput
    orderBy?: ReferenceTableCellOrderByWithRelationInput | ReferenceTableCellOrderByWithRelationInput[]
    cursor?: ReferenceTableCellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferenceTableCellScalarFieldEnum | ReferenceTableCellScalarFieldEnum[]
  }

  /**
   * ReferenceTableRow without action
   */
  export type ReferenceTableRowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableRow
     */
    select?: ReferenceTableRowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableRow
     */
    omit?: ReferenceTableRowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableRowInclude<ExtArgs> | null
  }


  /**
   * Model ReferenceTableCell
   */

  export type AggregateReferenceTableCell = {
    _count: ReferenceTableCellCountAggregateOutputType | null
    _avg: ReferenceTableCellAvgAggregateOutputType | null
    _sum: ReferenceTableCellSumAggregateOutputType | null
    _min: ReferenceTableCellMinAggregateOutputType | null
    _max: ReferenceTableCellMaxAggregateOutputType | null
  }

  export type ReferenceTableCellAvgAggregateOutputType = {
    id: number | null
    rowId: number | null
    columnId: number | null
    colSpan: number | null
    rowSpan: number | null
  }

  export type ReferenceTableCellSumAggregateOutputType = {
    id: number | null
    rowId: number | null
    columnId: number | null
    colSpan: number | null
    rowSpan: number | null
  }

  export type ReferenceTableCellMinAggregateOutputType = {
    id: number | null
    rowId: number | null
    columnId: number | null
    value: string | null
    colSpan: number | null
    rowSpan: number | null
  }

  export type ReferenceTableCellMaxAggregateOutputType = {
    id: number | null
    rowId: number | null
    columnId: number | null
    value: string | null
    colSpan: number | null
    rowSpan: number | null
  }

  export type ReferenceTableCellCountAggregateOutputType = {
    id: number
    rowId: number
    columnId: number
    value: number
    colSpan: number
    rowSpan: number
    _all: number
  }


  export type ReferenceTableCellAvgAggregateInputType = {
    id?: true
    rowId?: true
    columnId?: true
    colSpan?: true
    rowSpan?: true
  }

  export type ReferenceTableCellSumAggregateInputType = {
    id?: true
    rowId?: true
    columnId?: true
    colSpan?: true
    rowSpan?: true
  }

  export type ReferenceTableCellMinAggregateInputType = {
    id?: true
    rowId?: true
    columnId?: true
    value?: true
    colSpan?: true
    rowSpan?: true
  }

  export type ReferenceTableCellMaxAggregateInputType = {
    id?: true
    rowId?: true
    columnId?: true
    value?: true
    colSpan?: true
    rowSpan?: true
  }

  export type ReferenceTableCellCountAggregateInputType = {
    id?: true
    rowId?: true
    columnId?: true
    value?: true
    colSpan?: true
    rowSpan?: true
    _all?: true
  }

  export type ReferenceTableCellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceTableCell to aggregate.
     */
    where?: ReferenceTableCellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableCells to fetch.
     */
    orderBy?: ReferenceTableCellOrderByWithRelationInput | ReferenceTableCellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferenceTableCellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableCells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableCells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferenceTableCells
    **/
    _count?: true | ReferenceTableCellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferenceTableCellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferenceTableCellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferenceTableCellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferenceTableCellMaxAggregateInputType
  }

  export type GetReferenceTableCellAggregateType<T extends ReferenceTableCellAggregateArgs> = {
        [P in keyof T & keyof AggregateReferenceTableCell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferenceTableCell[P]>
      : GetScalarType<T[P], AggregateReferenceTableCell[P]>
  }




  export type ReferenceTableCellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceTableCellWhereInput
    orderBy?: ReferenceTableCellOrderByWithAggregationInput | ReferenceTableCellOrderByWithAggregationInput[]
    by: ReferenceTableCellScalarFieldEnum[] | ReferenceTableCellScalarFieldEnum
    having?: ReferenceTableCellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferenceTableCellCountAggregateInputType | true
    _avg?: ReferenceTableCellAvgAggregateInputType
    _sum?: ReferenceTableCellSumAggregateInputType
    _min?: ReferenceTableCellMinAggregateInputType
    _max?: ReferenceTableCellMaxAggregateInputType
  }

  export type ReferenceTableCellGroupByOutputType = {
    id: number
    rowId: number
    columnId: number
    value: string | null
    colSpan: number | null
    rowSpan: number | null
    _count: ReferenceTableCellCountAggregateOutputType | null
    _avg: ReferenceTableCellAvgAggregateOutputType | null
    _sum: ReferenceTableCellSumAggregateOutputType | null
    _min: ReferenceTableCellMinAggregateOutputType | null
    _max: ReferenceTableCellMaxAggregateOutputType | null
  }

  type GetReferenceTableCellGroupByPayload<T extends ReferenceTableCellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferenceTableCellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferenceTableCellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferenceTableCellGroupByOutputType[P]>
            : GetScalarType<T[P], ReferenceTableCellGroupByOutputType[P]>
        }
      >
    >


  export type ReferenceTableCellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rowId?: boolean
    columnId?: boolean
    value?: boolean
    colSpan?: boolean
    rowSpan?: boolean
    column?: boolean | ReferenceTableColumnDefaultArgs<ExtArgs>
    row?: boolean | ReferenceTableRowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referenceTableCell"]>



  export type ReferenceTableCellSelectScalar = {
    id?: boolean
    rowId?: boolean
    columnId?: boolean
    value?: boolean
    colSpan?: boolean
    rowSpan?: boolean
  }

  export type ReferenceTableCellOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rowId" | "columnId" | "value" | "colSpan" | "rowSpan", ExtArgs["result"]["referenceTableCell"]>
  export type ReferenceTableCellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    column?: boolean | ReferenceTableColumnDefaultArgs<ExtArgs>
    row?: boolean | ReferenceTableRowDefaultArgs<ExtArgs>
  }

  export type $ReferenceTableCellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferenceTableCell"
    objects: {
      column: Prisma.$ReferenceTableColumnPayload<ExtArgs>
      row: Prisma.$ReferenceTableRowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rowId: number
      columnId: number
      value: string | null
      colSpan: number | null
      rowSpan: number | null
    }, ExtArgs["result"]["referenceTableCell"]>
    composites: {}
  }

  type ReferenceTableCellGetPayload<S extends boolean | null | undefined | ReferenceTableCellDefaultArgs> = $Result.GetResult<Prisma.$ReferenceTableCellPayload, S>

  type ReferenceTableCellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferenceTableCellFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferenceTableCellCountAggregateInputType | true
    }

  export interface ReferenceTableCellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferenceTableCell'], meta: { name: 'ReferenceTableCell' } }
    /**
     * Find zero or one ReferenceTableCell that matches the filter.
     * @param {ReferenceTableCellFindUniqueArgs} args - Arguments to find a ReferenceTableCell
     * @example
     * // Get one ReferenceTableCell
     * const referenceTableCell = await prisma.referenceTableCell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferenceTableCellFindUniqueArgs>(args: SelectSubset<T, ReferenceTableCellFindUniqueArgs<ExtArgs>>): Prisma__ReferenceTableCellClient<$Result.GetResult<Prisma.$ReferenceTableCellPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReferenceTableCell that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferenceTableCellFindUniqueOrThrowArgs} args - Arguments to find a ReferenceTableCell
     * @example
     * // Get one ReferenceTableCell
     * const referenceTableCell = await prisma.referenceTableCell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferenceTableCellFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferenceTableCellFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferenceTableCellClient<$Result.GetResult<Prisma.$ReferenceTableCellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferenceTableCell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableCellFindFirstArgs} args - Arguments to find a ReferenceTableCell
     * @example
     * // Get one ReferenceTableCell
     * const referenceTableCell = await prisma.referenceTableCell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferenceTableCellFindFirstArgs>(args?: SelectSubset<T, ReferenceTableCellFindFirstArgs<ExtArgs>>): Prisma__ReferenceTableCellClient<$Result.GetResult<Prisma.$ReferenceTableCellPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferenceTableCell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableCellFindFirstOrThrowArgs} args - Arguments to find a ReferenceTableCell
     * @example
     * // Get one ReferenceTableCell
     * const referenceTableCell = await prisma.referenceTableCell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferenceTableCellFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferenceTableCellFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferenceTableCellClient<$Result.GetResult<Prisma.$ReferenceTableCellPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReferenceTableCells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableCellFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferenceTableCells
     * const referenceTableCells = await prisma.referenceTableCell.findMany()
     * 
     * // Get first 10 ReferenceTableCells
     * const referenceTableCells = await prisma.referenceTableCell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referenceTableCellWithIdOnly = await prisma.referenceTableCell.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferenceTableCellFindManyArgs>(args?: SelectSubset<T, ReferenceTableCellFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferenceTableCellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReferenceTableCell.
     * @param {ReferenceTableCellCreateArgs} args - Arguments to create a ReferenceTableCell.
     * @example
     * // Create one ReferenceTableCell
     * const ReferenceTableCell = await prisma.referenceTableCell.create({
     *   data: {
     *     // ... data to create a ReferenceTableCell
     *   }
     * })
     * 
     */
    create<T extends ReferenceTableCellCreateArgs>(args: SelectSubset<T, ReferenceTableCellCreateArgs<ExtArgs>>): Prisma__ReferenceTableCellClient<$Result.GetResult<Prisma.$ReferenceTableCellPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReferenceTableCells.
     * @param {ReferenceTableCellCreateManyArgs} args - Arguments to create many ReferenceTableCells.
     * @example
     * // Create many ReferenceTableCells
     * const referenceTableCell = await prisma.referenceTableCell.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferenceTableCellCreateManyArgs>(args?: SelectSubset<T, ReferenceTableCellCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReferenceTableCell.
     * @param {ReferenceTableCellDeleteArgs} args - Arguments to delete one ReferenceTableCell.
     * @example
     * // Delete one ReferenceTableCell
     * const ReferenceTableCell = await prisma.referenceTableCell.delete({
     *   where: {
     *     // ... filter to delete one ReferenceTableCell
     *   }
     * })
     * 
     */
    delete<T extends ReferenceTableCellDeleteArgs>(args: SelectSubset<T, ReferenceTableCellDeleteArgs<ExtArgs>>): Prisma__ReferenceTableCellClient<$Result.GetResult<Prisma.$ReferenceTableCellPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReferenceTableCell.
     * @param {ReferenceTableCellUpdateArgs} args - Arguments to update one ReferenceTableCell.
     * @example
     * // Update one ReferenceTableCell
     * const referenceTableCell = await prisma.referenceTableCell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferenceTableCellUpdateArgs>(args: SelectSubset<T, ReferenceTableCellUpdateArgs<ExtArgs>>): Prisma__ReferenceTableCellClient<$Result.GetResult<Prisma.$ReferenceTableCellPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReferenceTableCells.
     * @param {ReferenceTableCellDeleteManyArgs} args - Arguments to filter ReferenceTableCells to delete.
     * @example
     * // Delete a few ReferenceTableCells
     * const { count } = await prisma.referenceTableCell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferenceTableCellDeleteManyArgs>(args?: SelectSubset<T, ReferenceTableCellDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferenceTableCells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableCellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferenceTableCells
     * const referenceTableCell = await prisma.referenceTableCell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferenceTableCellUpdateManyArgs>(args: SelectSubset<T, ReferenceTableCellUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferenceTableCell.
     * @param {ReferenceTableCellUpsertArgs} args - Arguments to update or create a ReferenceTableCell.
     * @example
     * // Update or create a ReferenceTableCell
     * const referenceTableCell = await prisma.referenceTableCell.upsert({
     *   create: {
     *     // ... data to create a ReferenceTableCell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferenceTableCell we want to update
     *   }
     * })
     */
    upsert<T extends ReferenceTableCellUpsertArgs>(args: SelectSubset<T, ReferenceTableCellUpsertArgs<ExtArgs>>): Prisma__ReferenceTableCellClient<$Result.GetResult<Prisma.$ReferenceTableCellPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReferenceTableCells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableCellCountArgs} args - Arguments to filter ReferenceTableCells to count.
     * @example
     * // Count the number of ReferenceTableCells
     * const count = await prisma.referenceTableCell.count({
     *   where: {
     *     // ... the filter for the ReferenceTableCells we want to count
     *   }
     * })
    **/
    count<T extends ReferenceTableCellCountArgs>(
      args?: Subset<T, ReferenceTableCellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferenceTableCellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferenceTableCell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableCellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferenceTableCellAggregateArgs>(args: Subset<T, ReferenceTableCellAggregateArgs>): Prisma.PrismaPromise<GetReferenceTableCellAggregateType<T>>

    /**
     * Group by ReferenceTableCell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceTableCellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferenceTableCellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferenceTableCellGroupByArgs['orderBy'] }
        : { orderBy?: ReferenceTableCellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferenceTableCellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferenceTableCellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferenceTableCell model
   */
  readonly fields: ReferenceTableCellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferenceTableCell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferenceTableCellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    column<T extends ReferenceTableColumnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReferenceTableColumnDefaultArgs<ExtArgs>>): Prisma__ReferenceTableColumnClient<$Result.GetResult<Prisma.$ReferenceTableColumnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    row<T extends ReferenceTableRowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReferenceTableRowDefaultArgs<ExtArgs>>): Prisma__ReferenceTableRowClient<$Result.GetResult<Prisma.$ReferenceTableRowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferenceTableCell model
   */
  interface ReferenceTableCellFieldRefs {
    readonly id: FieldRef<"ReferenceTableCell", 'Int'>
    readonly rowId: FieldRef<"ReferenceTableCell", 'Int'>
    readonly columnId: FieldRef<"ReferenceTableCell", 'Int'>
    readonly value: FieldRef<"ReferenceTableCell", 'String'>
    readonly colSpan: FieldRef<"ReferenceTableCell", 'Int'>
    readonly rowSpan: FieldRef<"ReferenceTableCell", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReferenceTableCell findUnique
   */
  export type ReferenceTableCellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableCell to fetch.
     */
    where: ReferenceTableCellWhereUniqueInput
  }

  /**
   * ReferenceTableCell findUniqueOrThrow
   */
  export type ReferenceTableCellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableCell to fetch.
     */
    where: ReferenceTableCellWhereUniqueInput
  }

  /**
   * ReferenceTableCell findFirst
   */
  export type ReferenceTableCellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableCell to fetch.
     */
    where?: ReferenceTableCellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableCells to fetch.
     */
    orderBy?: ReferenceTableCellOrderByWithRelationInput | ReferenceTableCellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceTableCells.
     */
    cursor?: ReferenceTableCellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableCells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableCells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceTableCells.
     */
    distinct?: ReferenceTableCellScalarFieldEnum | ReferenceTableCellScalarFieldEnum[]
  }

  /**
   * ReferenceTableCell findFirstOrThrow
   */
  export type ReferenceTableCellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableCell to fetch.
     */
    where?: ReferenceTableCellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableCells to fetch.
     */
    orderBy?: ReferenceTableCellOrderByWithRelationInput | ReferenceTableCellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceTableCells.
     */
    cursor?: ReferenceTableCellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableCells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableCells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceTableCells.
     */
    distinct?: ReferenceTableCellScalarFieldEnum | ReferenceTableCellScalarFieldEnum[]
  }

  /**
   * ReferenceTableCell findMany
   */
  export type ReferenceTableCellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
    /**
     * Filter, which ReferenceTableCells to fetch.
     */
    where?: ReferenceTableCellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceTableCells to fetch.
     */
    orderBy?: ReferenceTableCellOrderByWithRelationInput | ReferenceTableCellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferenceTableCells.
     */
    cursor?: ReferenceTableCellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceTableCells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceTableCells.
     */
    skip?: number
    distinct?: ReferenceTableCellScalarFieldEnum | ReferenceTableCellScalarFieldEnum[]
  }

  /**
   * ReferenceTableCell create
   */
  export type ReferenceTableCellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferenceTableCell.
     */
    data: XOR<ReferenceTableCellCreateInput, ReferenceTableCellUncheckedCreateInput>
  }

  /**
   * ReferenceTableCell createMany
   */
  export type ReferenceTableCellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferenceTableCells.
     */
    data: ReferenceTableCellCreateManyInput | ReferenceTableCellCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferenceTableCell update
   */
  export type ReferenceTableCellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferenceTableCell.
     */
    data: XOR<ReferenceTableCellUpdateInput, ReferenceTableCellUncheckedUpdateInput>
    /**
     * Choose, which ReferenceTableCell to update.
     */
    where: ReferenceTableCellWhereUniqueInput
  }

  /**
   * ReferenceTableCell updateMany
   */
  export type ReferenceTableCellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferenceTableCells.
     */
    data: XOR<ReferenceTableCellUpdateManyMutationInput, ReferenceTableCellUncheckedUpdateManyInput>
    /**
     * Filter which ReferenceTableCells to update
     */
    where?: ReferenceTableCellWhereInput
    /**
     * Limit how many ReferenceTableCells to update.
     */
    limit?: number
  }

  /**
   * ReferenceTableCell upsert
   */
  export type ReferenceTableCellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferenceTableCell to update in case it exists.
     */
    where: ReferenceTableCellWhereUniqueInput
    /**
     * In case the ReferenceTableCell found by the `where` argument doesn't exist, create a new ReferenceTableCell with this data.
     */
    create: XOR<ReferenceTableCellCreateInput, ReferenceTableCellUncheckedCreateInput>
    /**
     * In case the ReferenceTableCell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferenceTableCellUpdateInput, ReferenceTableCellUncheckedUpdateInput>
  }

  /**
   * ReferenceTableCell delete
   */
  export type ReferenceTableCellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
    /**
     * Filter which ReferenceTableCell to delete.
     */
    where: ReferenceTableCellWhereUniqueInput
  }

  /**
   * ReferenceTableCell deleteMany
   */
  export type ReferenceTableCellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferenceTableCells to delete
     */
    where?: ReferenceTableCellWhereInput
    /**
     * Limit how many ReferenceTableCells to delete.
     */
    limit?: number
  }

  /**
   * ReferenceTableCell without action
   */
  export type ReferenceTableCellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferenceTableCell
     */
    select?: ReferenceTableCellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferenceTableCell
     */
    omit?: ReferenceTableCellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferenceTableCellInclude<ExtArgs> | null
  }


  /**
   * Model UserCharacter
   */

  export type AggregateUserCharacter = {
    _count: UserCharacterCountAggregateOutputType | null
    _avg: UserCharacterAvgAggregateOutputType | null
    _sum: UserCharacterSumAggregateOutputType | null
    _min: UserCharacterMinAggregateOutputType | null
    _max: UserCharacterMaxAggregateOutputType | null
  }

  export type UserCharacterAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    raceId: number | null
    alignmentId: number | null
    age: number | null
    height: number | null
    weight: number | null
  }

  export type UserCharacterSumAggregateOutputType = {
    id: number | null
    userId: number | null
    raceId: number | null
    alignmentId: number | null
    age: number | null
    height: number | null
    weight: number | null
  }

  export type UserCharacterMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    raceId: number | null
    alignmentId: number | null
    age: number | null
    height: number | null
    weight: number | null
    eyes: string | null
    hair: string | null
    gender: string | null
    notes: string | null
  }

  export type UserCharacterMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    raceId: number | null
    alignmentId: number | null
    age: number | null
    height: number | null
    weight: number | null
    eyes: string | null
    hair: string | null
    gender: string | null
    notes: string | null
  }

  export type UserCharacterCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    raceId: number
    alignmentId: number
    age: number
    height: number
    weight: number
    eyes: number
    hair: number
    gender: number
    notes: number
    _all: number
  }


  export type UserCharacterAvgAggregateInputType = {
    id?: true
    userId?: true
    raceId?: true
    alignmentId?: true
    age?: true
    height?: true
    weight?: true
  }

  export type UserCharacterSumAggregateInputType = {
    id?: true
    userId?: true
    raceId?: true
    alignmentId?: true
    age?: true
    height?: true
    weight?: true
  }

  export type UserCharacterMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    raceId?: true
    alignmentId?: true
    age?: true
    height?: true
    weight?: true
    eyes?: true
    hair?: true
    gender?: true
    notes?: true
  }

  export type UserCharacterMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    raceId?: true
    alignmentId?: true
    age?: true
    height?: true
    weight?: true
    eyes?: true
    hair?: true
    gender?: true
    notes?: true
  }

  export type UserCharacterCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    raceId?: true
    alignmentId?: true
    age?: true
    height?: true
    weight?: true
    eyes?: true
    hair?: true
    gender?: true
    notes?: true
    _all?: true
  }

  export type UserCharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCharacter to aggregate.
     */
    where?: UserCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCharacters to fetch.
     */
    orderBy?: UserCharacterOrderByWithRelationInput | UserCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCharacters
    **/
    _count?: true | UserCharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCharacterMaxAggregateInputType
  }

  export type GetUserCharacterAggregateType<T extends UserCharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCharacter[P]>
      : GetScalarType<T[P], AggregateUserCharacter[P]>
  }




  export type UserCharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCharacterWhereInput
    orderBy?: UserCharacterOrderByWithAggregationInput | UserCharacterOrderByWithAggregationInput[]
    by: UserCharacterScalarFieldEnum[] | UserCharacterScalarFieldEnum
    having?: UserCharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCharacterCountAggregateInputType | true
    _avg?: UserCharacterAvgAggregateInputType
    _sum?: UserCharacterSumAggregateInputType
    _min?: UserCharacterMinAggregateInputType
    _max?: UserCharacterMaxAggregateInputType
  }

  export type UserCharacterGroupByOutputType = {
    id: number
    userId: number
    name: string
    raceId: number
    alignmentId: number
    age: number | null
    height: number | null
    weight: number | null
    eyes: string | null
    hair: string | null
    gender: string | null
    notes: string | null
    _count: UserCharacterCountAggregateOutputType | null
    _avg: UserCharacterAvgAggregateOutputType | null
    _sum: UserCharacterSumAggregateOutputType | null
    _min: UserCharacterMinAggregateOutputType | null
    _max: UserCharacterMaxAggregateOutputType | null
  }

  type GetUserCharacterGroupByPayload<T extends UserCharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCharacterGroupByOutputType[P]>
            : GetScalarType<T[P], UserCharacterGroupByOutputType[P]>
        }
      >
    >


  export type UserCharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    raceId?: boolean
    alignmentId?: boolean
    age?: boolean
    height?: boolean
    weight?: boolean
    eyes?: boolean
    hair?: boolean
    gender?: boolean
    notes?: boolean
    attributes?: boolean | UserCharacter$attributesArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | UserCharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCharacter"]>



  export type UserCharacterSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    raceId?: boolean
    alignmentId?: boolean
    age?: boolean
    height?: boolean
    weight?: boolean
    eyes?: boolean
    hair?: boolean
    gender?: boolean
    notes?: boolean
  }

  export type UserCharacterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "raceId" | "alignmentId" | "age" | "height" | "weight" | "eyes" | "hair" | "gender" | "notes", ExtArgs["result"]["userCharacter"]>
  export type UserCharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributes?: boolean | UserCharacter$attributesArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | UserCharacterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserCharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCharacter"
    objects: {
      attributes: Prisma.$UserCharacterAttributePayload<ExtArgs>[]
      race: Prisma.$RacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      name: string
      raceId: number
      alignmentId: number
      age: number | null
      height: number | null
      weight: number | null
      eyes: string | null
      hair: string | null
      gender: string | null
      notes: string | null
    }, ExtArgs["result"]["userCharacter"]>
    composites: {}
  }

  type UserCharacterGetPayload<S extends boolean | null | undefined | UserCharacterDefaultArgs> = $Result.GetResult<Prisma.$UserCharacterPayload, S>

  type UserCharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCharacterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCharacterCountAggregateInputType | true
    }

  export interface UserCharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCharacter'], meta: { name: 'UserCharacter' } }
    /**
     * Find zero or one UserCharacter that matches the filter.
     * @param {UserCharacterFindUniqueArgs} args - Arguments to find a UserCharacter
     * @example
     * // Get one UserCharacter
     * const userCharacter = await prisma.userCharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCharacterFindUniqueArgs>(args: SelectSubset<T, UserCharacterFindUniqueArgs<ExtArgs>>): Prisma__UserCharacterClient<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCharacter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCharacterFindUniqueOrThrowArgs} args - Arguments to find a UserCharacter
     * @example
     * // Get one UserCharacter
     * const userCharacter = await prisma.userCharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCharacterClient<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterFindFirstArgs} args - Arguments to find a UserCharacter
     * @example
     * // Get one UserCharacter
     * const userCharacter = await prisma.userCharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCharacterFindFirstArgs>(args?: SelectSubset<T, UserCharacterFindFirstArgs<ExtArgs>>): Prisma__UserCharacterClient<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterFindFirstOrThrowArgs} args - Arguments to find a UserCharacter
     * @example
     * // Get one UserCharacter
     * const userCharacter = await prisma.userCharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCharacterClient<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCharacters
     * const userCharacters = await prisma.userCharacter.findMany()
     * 
     * // Get first 10 UserCharacters
     * const userCharacters = await prisma.userCharacter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCharacterWithIdOnly = await prisma.userCharacter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCharacterFindManyArgs>(args?: SelectSubset<T, UserCharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCharacter.
     * @param {UserCharacterCreateArgs} args - Arguments to create a UserCharacter.
     * @example
     * // Create one UserCharacter
     * const UserCharacter = await prisma.userCharacter.create({
     *   data: {
     *     // ... data to create a UserCharacter
     *   }
     * })
     * 
     */
    create<T extends UserCharacterCreateArgs>(args: SelectSubset<T, UserCharacterCreateArgs<ExtArgs>>): Prisma__UserCharacterClient<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCharacters.
     * @param {UserCharacterCreateManyArgs} args - Arguments to create many UserCharacters.
     * @example
     * // Create many UserCharacters
     * const userCharacter = await prisma.userCharacter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCharacterCreateManyArgs>(args?: SelectSubset<T, UserCharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserCharacter.
     * @param {UserCharacterDeleteArgs} args - Arguments to delete one UserCharacter.
     * @example
     * // Delete one UserCharacter
     * const UserCharacter = await prisma.userCharacter.delete({
     *   where: {
     *     // ... filter to delete one UserCharacter
     *   }
     * })
     * 
     */
    delete<T extends UserCharacterDeleteArgs>(args: SelectSubset<T, UserCharacterDeleteArgs<ExtArgs>>): Prisma__UserCharacterClient<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCharacter.
     * @param {UserCharacterUpdateArgs} args - Arguments to update one UserCharacter.
     * @example
     * // Update one UserCharacter
     * const userCharacter = await prisma.userCharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCharacterUpdateArgs>(args: SelectSubset<T, UserCharacterUpdateArgs<ExtArgs>>): Prisma__UserCharacterClient<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCharacters.
     * @param {UserCharacterDeleteManyArgs} args - Arguments to filter UserCharacters to delete.
     * @example
     * // Delete a few UserCharacters
     * const { count } = await prisma.userCharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCharacterDeleteManyArgs>(args?: SelectSubset<T, UserCharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCharacters
     * const userCharacter = await prisma.userCharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCharacterUpdateManyArgs>(args: SelectSubset<T, UserCharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCharacter.
     * @param {UserCharacterUpsertArgs} args - Arguments to update or create a UserCharacter.
     * @example
     * // Update or create a UserCharacter
     * const userCharacter = await prisma.userCharacter.upsert({
     *   create: {
     *     // ... data to create a UserCharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCharacter we want to update
     *   }
     * })
     */
    upsert<T extends UserCharacterUpsertArgs>(args: SelectSubset<T, UserCharacterUpsertArgs<ExtArgs>>): Prisma__UserCharacterClient<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterCountArgs} args - Arguments to filter UserCharacters to count.
     * @example
     * // Count the number of UserCharacters
     * const count = await prisma.userCharacter.count({
     *   where: {
     *     // ... the filter for the UserCharacters we want to count
     *   }
     * })
    **/
    count<T extends UserCharacterCountArgs>(
      args?: Subset<T, UserCharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCharacterAggregateArgs>(args: Subset<T, UserCharacterAggregateArgs>): Prisma.PrismaPromise<GetUserCharacterAggregateType<T>>

    /**
     * Group by UserCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCharacterGroupByArgs['orderBy'] }
        : { orderBy?: UserCharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCharacter model
   */
  readonly fields: UserCharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attributes<T extends UserCharacter$attributesArgs<ExtArgs> = {}>(args?: Subset<T, UserCharacter$attributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCharacterAttributePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCharacter model
   */
  interface UserCharacterFieldRefs {
    readonly id: FieldRef<"UserCharacter", 'Int'>
    readonly userId: FieldRef<"UserCharacter", 'Int'>
    readonly name: FieldRef<"UserCharacter", 'String'>
    readonly raceId: FieldRef<"UserCharacter", 'Int'>
    readonly alignmentId: FieldRef<"UserCharacter", 'Int'>
    readonly age: FieldRef<"UserCharacter", 'Int'>
    readonly height: FieldRef<"UserCharacter", 'Int'>
    readonly weight: FieldRef<"UserCharacter", 'Int'>
    readonly eyes: FieldRef<"UserCharacter", 'String'>
    readonly hair: FieldRef<"UserCharacter", 'String'>
    readonly gender: FieldRef<"UserCharacter", 'String'>
    readonly notes: FieldRef<"UserCharacter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserCharacter findUnique
   */
  export type UserCharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
    /**
     * Filter, which UserCharacter to fetch.
     */
    where: UserCharacterWhereUniqueInput
  }

  /**
   * UserCharacter findUniqueOrThrow
   */
  export type UserCharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
    /**
     * Filter, which UserCharacter to fetch.
     */
    where: UserCharacterWhereUniqueInput
  }

  /**
   * UserCharacter findFirst
   */
  export type UserCharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
    /**
     * Filter, which UserCharacter to fetch.
     */
    where?: UserCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCharacters to fetch.
     */
    orderBy?: UserCharacterOrderByWithRelationInput | UserCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCharacters.
     */
    cursor?: UserCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCharacters.
     */
    distinct?: UserCharacterScalarFieldEnum | UserCharacterScalarFieldEnum[]
  }

  /**
   * UserCharacter findFirstOrThrow
   */
  export type UserCharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
    /**
     * Filter, which UserCharacter to fetch.
     */
    where?: UserCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCharacters to fetch.
     */
    orderBy?: UserCharacterOrderByWithRelationInput | UserCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCharacters.
     */
    cursor?: UserCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCharacters.
     */
    distinct?: UserCharacterScalarFieldEnum | UserCharacterScalarFieldEnum[]
  }

  /**
   * UserCharacter findMany
   */
  export type UserCharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
    /**
     * Filter, which UserCharacters to fetch.
     */
    where?: UserCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCharacters to fetch.
     */
    orderBy?: UserCharacterOrderByWithRelationInput | UserCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCharacters.
     */
    cursor?: UserCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCharacters.
     */
    skip?: number
    distinct?: UserCharacterScalarFieldEnum | UserCharacterScalarFieldEnum[]
  }

  /**
   * UserCharacter create
   */
  export type UserCharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCharacter.
     */
    data: XOR<UserCharacterCreateInput, UserCharacterUncheckedCreateInput>
  }

  /**
   * UserCharacter createMany
   */
  export type UserCharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCharacters.
     */
    data: UserCharacterCreateManyInput | UserCharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCharacter update
   */
  export type UserCharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCharacter.
     */
    data: XOR<UserCharacterUpdateInput, UserCharacterUncheckedUpdateInput>
    /**
     * Choose, which UserCharacter to update.
     */
    where: UserCharacterWhereUniqueInput
  }

  /**
   * UserCharacter updateMany
   */
  export type UserCharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCharacters.
     */
    data: XOR<UserCharacterUpdateManyMutationInput, UserCharacterUncheckedUpdateManyInput>
    /**
     * Filter which UserCharacters to update
     */
    where?: UserCharacterWhereInput
    /**
     * Limit how many UserCharacters to update.
     */
    limit?: number
  }

  /**
   * UserCharacter upsert
   */
  export type UserCharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCharacter to update in case it exists.
     */
    where: UserCharacterWhereUniqueInput
    /**
     * In case the UserCharacter found by the `where` argument doesn't exist, create a new UserCharacter with this data.
     */
    create: XOR<UserCharacterCreateInput, UserCharacterUncheckedCreateInput>
    /**
     * In case the UserCharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCharacterUpdateInput, UserCharacterUncheckedUpdateInput>
  }

  /**
   * UserCharacter delete
   */
  export type UserCharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
    /**
     * Filter which UserCharacter to delete.
     */
    where: UserCharacterWhereUniqueInput
  }

  /**
   * UserCharacter deleteMany
   */
  export type UserCharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCharacters to delete
     */
    where?: UserCharacterWhereInput
    /**
     * Limit how many UserCharacters to delete.
     */
    limit?: number
  }

  /**
   * UserCharacter.attributes
   */
  export type UserCharacter$attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterAttribute
     */
    select?: UserCharacterAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacterAttribute
     */
    omit?: UserCharacterAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterAttributeInclude<ExtArgs> | null
    where?: UserCharacterAttributeWhereInput
    orderBy?: UserCharacterAttributeOrderByWithRelationInput | UserCharacterAttributeOrderByWithRelationInput[]
    cursor?: UserCharacterAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCharacterAttributeScalarFieldEnum | UserCharacterAttributeScalarFieldEnum[]
  }

  /**
   * UserCharacter without action
   */
  export type UserCharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
  }


  /**
   * Model UserCharacterAttribute
   */

  export type AggregateUserCharacterAttribute = {
    _count: UserCharacterAttributeCountAggregateOutputType | null
    _avg: UserCharacterAttributeAvgAggregateOutputType | null
    _sum: UserCharacterAttributeSumAggregateOutputType | null
    _min: UserCharacterAttributeMinAggregateOutputType | null
    _max: UserCharacterAttributeMaxAggregateOutputType | null
  }

  export type UserCharacterAttributeAvgAggregateOutputType = {
    id: number | null
    characterId: number | null
    attributeId: number | null
    value: number | null
  }

  export type UserCharacterAttributeSumAggregateOutputType = {
    id: number | null
    characterId: number | null
    attributeId: number | null
    value: number | null
  }

  export type UserCharacterAttributeMinAggregateOutputType = {
    id: number | null
    characterId: number | null
    attributeId: number | null
    value: number | null
  }

  export type UserCharacterAttributeMaxAggregateOutputType = {
    id: number | null
    characterId: number | null
    attributeId: number | null
    value: number | null
  }

  export type UserCharacterAttributeCountAggregateOutputType = {
    id: number
    characterId: number
    attributeId: number
    value: number
    _all: number
  }


  export type UserCharacterAttributeAvgAggregateInputType = {
    id?: true
    characterId?: true
    attributeId?: true
    value?: true
  }

  export type UserCharacterAttributeSumAggregateInputType = {
    id?: true
    characterId?: true
    attributeId?: true
    value?: true
  }

  export type UserCharacterAttributeMinAggregateInputType = {
    id?: true
    characterId?: true
    attributeId?: true
    value?: true
  }

  export type UserCharacterAttributeMaxAggregateInputType = {
    id?: true
    characterId?: true
    attributeId?: true
    value?: true
  }

  export type UserCharacterAttributeCountAggregateInputType = {
    id?: true
    characterId?: true
    attributeId?: true
    value?: true
    _all?: true
  }

  export type UserCharacterAttributeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCharacterAttribute to aggregate.
     */
    where?: UserCharacterAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCharacterAttributes to fetch.
     */
    orderBy?: UserCharacterAttributeOrderByWithRelationInput | UserCharacterAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCharacterAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCharacterAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCharacterAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCharacterAttributes
    **/
    _count?: true | UserCharacterAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCharacterAttributeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCharacterAttributeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCharacterAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCharacterAttributeMaxAggregateInputType
  }

  export type GetUserCharacterAttributeAggregateType<T extends UserCharacterAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCharacterAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCharacterAttribute[P]>
      : GetScalarType<T[P], AggregateUserCharacterAttribute[P]>
  }




  export type UserCharacterAttributeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCharacterAttributeWhereInput
    orderBy?: UserCharacterAttributeOrderByWithAggregationInput | UserCharacterAttributeOrderByWithAggregationInput[]
    by: UserCharacterAttributeScalarFieldEnum[] | UserCharacterAttributeScalarFieldEnum
    having?: UserCharacterAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCharacterAttributeCountAggregateInputType | true
    _avg?: UserCharacterAttributeAvgAggregateInputType
    _sum?: UserCharacterAttributeSumAggregateInputType
    _min?: UserCharacterAttributeMinAggregateInputType
    _max?: UserCharacterAttributeMaxAggregateInputType
  }

  export type UserCharacterAttributeGroupByOutputType = {
    id: number
    characterId: number
    attributeId: number
    value: number
    _count: UserCharacterAttributeCountAggregateOutputType | null
    _avg: UserCharacterAttributeAvgAggregateOutputType | null
    _sum: UserCharacterAttributeSumAggregateOutputType | null
    _min: UserCharacterAttributeMinAggregateOutputType | null
    _max: UserCharacterAttributeMaxAggregateOutputType | null
  }

  type GetUserCharacterAttributeGroupByPayload<T extends UserCharacterAttributeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCharacterAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCharacterAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCharacterAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], UserCharacterAttributeGroupByOutputType[P]>
        }
      >
    >


  export type UserCharacterAttributeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    attributeId?: boolean
    value?: boolean
    character?: boolean | UserCharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCharacterAttribute"]>



  export type UserCharacterAttributeSelectScalar = {
    id?: boolean
    characterId?: boolean
    attributeId?: boolean
    value?: boolean
  }

  export type UserCharacterAttributeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "characterId" | "attributeId" | "value", ExtArgs["result"]["userCharacterAttribute"]>
  export type UserCharacterAttributeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | UserCharacterDefaultArgs<ExtArgs>
  }

  export type $UserCharacterAttributePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCharacterAttribute"
    objects: {
      character: Prisma.$UserCharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      characterId: number
      attributeId: number
      value: number
    }, ExtArgs["result"]["userCharacterAttribute"]>
    composites: {}
  }

  type UserCharacterAttributeGetPayload<S extends boolean | null | undefined | UserCharacterAttributeDefaultArgs> = $Result.GetResult<Prisma.$UserCharacterAttributePayload, S>

  type UserCharacterAttributeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCharacterAttributeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCharacterAttributeCountAggregateInputType | true
    }

  export interface UserCharacterAttributeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCharacterAttribute'], meta: { name: 'UserCharacterAttribute' } }
    /**
     * Find zero or one UserCharacterAttribute that matches the filter.
     * @param {UserCharacterAttributeFindUniqueArgs} args - Arguments to find a UserCharacterAttribute
     * @example
     * // Get one UserCharacterAttribute
     * const userCharacterAttribute = await prisma.userCharacterAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCharacterAttributeFindUniqueArgs>(args: SelectSubset<T, UserCharacterAttributeFindUniqueArgs<ExtArgs>>): Prisma__UserCharacterAttributeClient<$Result.GetResult<Prisma.$UserCharacterAttributePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCharacterAttribute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCharacterAttributeFindUniqueOrThrowArgs} args - Arguments to find a UserCharacterAttribute
     * @example
     * // Get one UserCharacterAttribute
     * const userCharacterAttribute = await prisma.userCharacterAttribute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCharacterAttributeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCharacterAttributeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCharacterAttributeClient<$Result.GetResult<Prisma.$UserCharacterAttributePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCharacterAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterAttributeFindFirstArgs} args - Arguments to find a UserCharacterAttribute
     * @example
     * // Get one UserCharacterAttribute
     * const userCharacterAttribute = await prisma.userCharacterAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCharacterAttributeFindFirstArgs>(args?: SelectSubset<T, UserCharacterAttributeFindFirstArgs<ExtArgs>>): Prisma__UserCharacterAttributeClient<$Result.GetResult<Prisma.$UserCharacterAttributePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCharacterAttribute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterAttributeFindFirstOrThrowArgs} args - Arguments to find a UserCharacterAttribute
     * @example
     * // Get one UserCharacterAttribute
     * const userCharacterAttribute = await prisma.userCharacterAttribute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCharacterAttributeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCharacterAttributeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCharacterAttributeClient<$Result.GetResult<Prisma.$UserCharacterAttributePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCharacterAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterAttributeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCharacterAttributes
     * const userCharacterAttributes = await prisma.userCharacterAttribute.findMany()
     * 
     * // Get first 10 UserCharacterAttributes
     * const userCharacterAttributes = await prisma.userCharacterAttribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCharacterAttributeWithIdOnly = await prisma.userCharacterAttribute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCharacterAttributeFindManyArgs>(args?: SelectSubset<T, UserCharacterAttributeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCharacterAttributePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCharacterAttribute.
     * @param {UserCharacterAttributeCreateArgs} args - Arguments to create a UserCharacterAttribute.
     * @example
     * // Create one UserCharacterAttribute
     * const UserCharacterAttribute = await prisma.userCharacterAttribute.create({
     *   data: {
     *     // ... data to create a UserCharacterAttribute
     *   }
     * })
     * 
     */
    create<T extends UserCharacterAttributeCreateArgs>(args: SelectSubset<T, UserCharacterAttributeCreateArgs<ExtArgs>>): Prisma__UserCharacterAttributeClient<$Result.GetResult<Prisma.$UserCharacterAttributePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCharacterAttributes.
     * @param {UserCharacterAttributeCreateManyArgs} args - Arguments to create many UserCharacterAttributes.
     * @example
     * // Create many UserCharacterAttributes
     * const userCharacterAttribute = await prisma.userCharacterAttribute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCharacterAttributeCreateManyArgs>(args?: SelectSubset<T, UserCharacterAttributeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserCharacterAttribute.
     * @param {UserCharacterAttributeDeleteArgs} args - Arguments to delete one UserCharacterAttribute.
     * @example
     * // Delete one UserCharacterAttribute
     * const UserCharacterAttribute = await prisma.userCharacterAttribute.delete({
     *   where: {
     *     // ... filter to delete one UserCharacterAttribute
     *   }
     * })
     * 
     */
    delete<T extends UserCharacterAttributeDeleteArgs>(args: SelectSubset<T, UserCharacterAttributeDeleteArgs<ExtArgs>>): Prisma__UserCharacterAttributeClient<$Result.GetResult<Prisma.$UserCharacterAttributePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCharacterAttribute.
     * @param {UserCharacterAttributeUpdateArgs} args - Arguments to update one UserCharacterAttribute.
     * @example
     * // Update one UserCharacterAttribute
     * const userCharacterAttribute = await prisma.userCharacterAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCharacterAttributeUpdateArgs>(args: SelectSubset<T, UserCharacterAttributeUpdateArgs<ExtArgs>>): Prisma__UserCharacterAttributeClient<$Result.GetResult<Prisma.$UserCharacterAttributePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCharacterAttributes.
     * @param {UserCharacterAttributeDeleteManyArgs} args - Arguments to filter UserCharacterAttributes to delete.
     * @example
     * // Delete a few UserCharacterAttributes
     * const { count } = await prisma.userCharacterAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCharacterAttributeDeleteManyArgs>(args?: SelectSubset<T, UserCharacterAttributeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCharacterAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCharacterAttributes
     * const userCharacterAttribute = await prisma.userCharacterAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCharacterAttributeUpdateManyArgs>(args: SelectSubset<T, UserCharacterAttributeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCharacterAttribute.
     * @param {UserCharacterAttributeUpsertArgs} args - Arguments to update or create a UserCharacterAttribute.
     * @example
     * // Update or create a UserCharacterAttribute
     * const userCharacterAttribute = await prisma.userCharacterAttribute.upsert({
     *   create: {
     *     // ... data to create a UserCharacterAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCharacterAttribute we want to update
     *   }
     * })
     */
    upsert<T extends UserCharacterAttributeUpsertArgs>(args: SelectSubset<T, UserCharacterAttributeUpsertArgs<ExtArgs>>): Prisma__UserCharacterAttributeClient<$Result.GetResult<Prisma.$UserCharacterAttributePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCharacterAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterAttributeCountArgs} args - Arguments to filter UserCharacterAttributes to count.
     * @example
     * // Count the number of UserCharacterAttributes
     * const count = await prisma.userCharacterAttribute.count({
     *   where: {
     *     // ... the filter for the UserCharacterAttributes we want to count
     *   }
     * })
    **/
    count<T extends UserCharacterAttributeCountArgs>(
      args?: Subset<T, UserCharacterAttributeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCharacterAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCharacterAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCharacterAttributeAggregateArgs>(args: Subset<T, UserCharacterAttributeAggregateArgs>): Prisma.PrismaPromise<GetUserCharacterAttributeAggregateType<T>>

    /**
     * Group by UserCharacterAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCharacterAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCharacterAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCharacterAttributeGroupByArgs['orderBy'] }
        : { orderBy?: UserCharacterAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCharacterAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCharacterAttributeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCharacterAttribute model
   */
  readonly fields: UserCharacterAttributeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCharacterAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCharacterAttributeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends UserCharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserCharacterDefaultArgs<ExtArgs>>): Prisma__UserCharacterClient<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCharacterAttribute model
   */
  interface UserCharacterAttributeFieldRefs {
    readonly id: FieldRef<"UserCharacterAttribute", 'Int'>
    readonly characterId: FieldRef<"UserCharacterAttribute", 'Int'>
    readonly attributeId: FieldRef<"UserCharacterAttribute", 'Int'>
    readonly value: FieldRef<"UserCharacterAttribute", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserCharacterAttribute findUnique
   */
  export type UserCharacterAttributeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterAttribute
     */
    select?: UserCharacterAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacterAttribute
     */
    omit?: UserCharacterAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterAttributeInclude<ExtArgs> | null
    /**
     * Filter, which UserCharacterAttribute to fetch.
     */
    where: UserCharacterAttributeWhereUniqueInput
  }

  /**
   * UserCharacterAttribute findUniqueOrThrow
   */
  export type UserCharacterAttributeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterAttribute
     */
    select?: UserCharacterAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacterAttribute
     */
    omit?: UserCharacterAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterAttributeInclude<ExtArgs> | null
    /**
     * Filter, which UserCharacterAttribute to fetch.
     */
    where: UserCharacterAttributeWhereUniqueInput
  }

  /**
   * UserCharacterAttribute findFirst
   */
  export type UserCharacterAttributeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterAttribute
     */
    select?: UserCharacterAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacterAttribute
     */
    omit?: UserCharacterAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterAttributeInclude<ExtArgs> | null
    /**
     * Filter, which UserCharacterAttribute to fetch.
     */
    where?: UserCharacterAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCharacterAttributes to fetch.
     */
    orderBy?: UserCharacterAttributeOrderByWithRelationInput | UserCharacterAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCharacterAttributes.
     */
    cursor?: UserCharacterAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCharacterAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCharacterAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCharacterAttributes.
     */
    distinct?: UserCharacterAttributeScalarFieldEnum | UserCharacterAttributeScalarFieldEnum[]
  }

  /**
   * UserCharacterAttribute findFirstOrThrow
   */
  export type UserCharacterAttributeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterAttribute
     */
    select?: UserCharacterAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacterAttribute
     */
    omit?: UserCharacterAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterAttributeInclude<ExtArgs> | null
    /**
     * Filter, which UserCharacterAttribute to fetch.
     */
    where?: UserCharacterAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCharacterAttributes to fetch.
     */
    orderBy?: UserCharacterAttributeOrderByWithRelationInput | UserCharacterAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCharacterAttributes.
     */
    cursor?: UserCharacterAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCharacterAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCharacterAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCharacterAttributes.
     */
    distinct?: UserCharacterAttributeScalarFieldEnum | UserCharacterAttributeScalarFieldEnum[]
  }

  /**
   * UserCharacterAttribute findMany
   */
  export type UserCharacterAttributeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterAttribute
     */
    select?: UserCharacterAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacterAttribute
     */
    omit?: UserCharacterAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterAttributeInclude<ExtArgs> | null
    /**
     * Filter, which UserCharacterAttributes to fetch.
     */
    where?: UserCharacterAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCharacterAttributes to fetch.
     */
    orderBy?: UserCharacterAttributeOrderByWithRelationInput | UserCharacterAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCharacterAttributes.
     */
    cursor?: UserCharacterAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCharacterAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCharacterAttributes.
     */
    skip?: number
    distinct?: UserCharacterAttributeScalarFieldEnum | UserCharacterAttributeScalarFieldEnum[]
  }

  /**
   * UserCharacterAttribute create
   */
  export type UserCharacterAttributeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterAttribute
     */
    select?: UserCharacterAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacterAttribute
     */
    omit?: UserCharacterAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterAttributeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCharacterAttribute.
     */
    data: XOR<UserCharacterAttributeCreateInput, UserCharacterAttributeUncheckedCreateInput>
  }

  /**
   * UserCharacterAttribute createMany
   */
  export type UserCharacterAttributeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCharacterAttributes.
     */
    data: UserCharacterAttributeCreateManyInput | UserCharacterAttributeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCharacterAttribute update
   */
  export type UserCharacterAttributeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterAttribute
     */
    select?: UserCharacterAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacterAttribute
     */
    omit?: UserCharacterAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterAttributeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCharacterAttribute.
     */
    data: XOR<UserCharacterAttributeUpdateInput, UserCharacterAttributeUncheckedUpdateInput>
    /**
     * Choose, which UserCharacterAttribute to update.
     */
    where: UserCharacterAttributeWhereUniqueInput
  }

  /**
   * UserCharacterAttribute updateMany
   */
  export type UserCharacterAttributeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCharacterAttributes.
     */
    data: XOR<UserCharacterAttributeUpdateManyMutationInput, UserCharacterAttributeUncheckedUpdateManyInput>
    /**
     * Filter which UserCharacterAttributes to update
     */
    where?: UserCharacterAttributeWhereInput
    /**
     * Limit how many UserCharacterAttributes to update.
     */
    limit?: number
  }

  /**
   * UserCharacterAttribute upsert
   */
  export type UserCharacterAttributeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterAttribute
     */
    select?: UserCharacterAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacterAttribute
     */
    omit?: UserCharacterAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterAttributeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCharacterAttribute to update in case it exists.
     */
    where: UserCharacterAttributeWhereUniqueInput
    /**
     * In case the UserCharacterAttribute found by the `where` argument doesn't exist, create a new UserCharacterAttribute with this data.
     */
    create: XOR<UserCharacterAttributeCreateInput, UserCharacterAttributeUncheckedCreateInput>
    /**
     * In case the UserCharacterAttribute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCharacterAttributeUpdateInput, UserCharacterAttributeUncheckedUpdateInput>
  }

  /**
   * UserCharacterAttribute delete
   */
  export type UserCharacterAttributeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterAttribute
     */
    select?: UserCharacterAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacterAttribute
     */
    omit?: UserCharacterAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterAttributeInclude<ExtArgs> | null
    /**
     * Filter which UserCharacterAttribute to delete.
     */
    where: UserCharacterAttributeWhereUniqueInput
  }

  /**
   * UserCharacterAttribute deleteMany
   */
  export type UserCharacterAttributeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCharacterAttributes to delete
     */
    where?: UserCharacterAttributeWhereInput
    /**
     * Limit how many UserCharacterAttributes to delete.
     */
    limit?: number
  }

  /**
   * UserCharacterAttribute without action
   */
  export type UserCharacterAttributeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacterAttribute
     */
    select?: UserCharacterAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacterAttribute
     */
    omit?: UserCharacterAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterAttributeInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    preferredEditionId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    preferredEditionId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    preferredEditionId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    preferredEditionId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    isAdmin: number
    createdAt: number
    updatedAt: number
    preferredEditionId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    preferredEditionId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    preferredEditionId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    preferredEditionId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    preferredEditionId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    preferredEditionId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    password: string
    isAdmin: boolean
    createdAt: Date
    updatedAt: Date
    preferredEditionId: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferredEditionId?: boolean
    characters?: boolean | User$charactersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferredEditionId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "isAdmin" | "createdAt" | "updatedAt" | "preferredEditionId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | User$charactersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      characters: Prisma.$UserCharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      password: string
      isAdmin: boolean
      createdAt: Date
      updatedAt: Date
      preferredEditionId: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends User$charactersArgs<ExtArgs> = {}>(args?: Subset<T, User$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly preferredEditionId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.characters
   */
  export type User$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCharacter
     */
    select?: UserCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCharacter
     */
    omit?: UserCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCharacterInclude<ExtArgs> | null
    where?: UserCharacterWhereInput
    orderBy?: UserCharacterOrderByWithRelationInput | UserCharacterOrderByWithRelationInput[]
    cursor?: UserCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCharacterScalarFieldEnum | UserCharacterScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbreviation: 'abbreviation',
    editionId: 'editionId',
    isPrestige: 'isPrestige',
    isVisible: 'isVisible',
    canCastSpells: 'canCastSpells',
    hitDie: 'hitDie',
    description: 'description',
    skillPoints: 'skillPoints',
    castingAbilityId: 'castingAbilityId'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const ClassFeatureScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    name: 'name',
    description: 'description',
    level: 'level'
  };

  export type ClassFeatureScalarFieldEnum = (typeof ClassFeatureScalarFieldEnum)[keyof typeof ClassFeatureScalarFieldEnum]


  export const ClassSpellLevelScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    spellLevel: 'spellLevel'
  };

  export type ClassSpellLevelScalarFieldEnum = (typeof ClassSpellLevelScalarFieldEnum)[keyof typeof ClassSpellLevelScalarFieldEnum]


  export const ClassLevelAttributeScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    baseAttackBonus: 'baseAttackBonus',
    fortSave: 'fortSave',
    refSave: 'refSave',
    willSave: 'willSave'
  };

  export type ClassLevelAttributeScalarFieldEnum = (typeof ClassLevelAttributeScalarFieldEnum)[keyof typeof ClassLevelAttributeScalarFieldEnum]


  export const ClassSkillMapScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    skillId: 'skillId'
  };

  export type ClassSkillMapScalarFieldEnum = (typeof ClassSkillMapScalarFieldEnum)[keyof typeof ClassSkillMapScalarFieldEnum]


  export const ClassSourceMapScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    bookId: 'bookId',
    pageNumber: 'pageNumber',
    sourceBookId: 'sourceBookId'
  };

  export type ClassSourceMapScalarFieldEnum = (typeof ClassSourceMapScalarFieldEnum)[keyof typeof ClassSourceMapScalarFieldEnum]


  export const SpellLevelMapScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    spellId: 'spellId',
    level: 'level',
    isVisible: 'isVisible'
  };

  export type SpellLevelMapScalarFieldEnum = (typeof SpellLevelMapScalarFieldEnum)[keyof typeof SpellLevelMapScalarFieldEnum]


  export const SpellScalarFieldEnum: {
    id: 'id',
    name: 'name',
    summary: 'summary',
    description: 'description',
    castingTime: 'castingTime',
    range: 'range',
    rangeTypeId: 'rangeTypeId',
    rangeValue: 'rangeValue',
    area: 'area',
    duration: 'duration',
    savingThrow: 'savingThrow',
    spellResistance: 'spellResistance',
    editionId: 'editionId',
    baseLevel: 'baseLevel',
    effect: 'effect',
    target: 'target'
  };

  export type SpellScalarFieldEnum = (typeof SpellScalarFieldEnum)[keyof typeof SpellScalarFieldEnum]


  export const SpellDescriptorMapScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    descriptorId: 'descriptorId'
  };

  export type SpellDescriptorMapScalarFieldEnum = (typeof SpellDescriptorMapScalarFieldEnum)[keyof typeof SpellDescriptorMapScalarFieldEnum]


  export const SpellSchoolMapScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    schoolId: 'schoolId'
  };

  export type SpellSchoolMapScalarFieldEnum = (typeof SpellSchoolMapScalarFieldEnum)[keyof typeof SpellSchoolMapScalarFieldEnum]


  export const SpellSourceMapScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    bookId: 'bookId',
    pageNumber: 'pageNumber',
    sourceBookId: 'sourceBookId'
  };

  export type SpellSourceMapScalarFieldEnum = (typeof SpellSourceMapScalarFieldEnum)[keyof typeof SpellSourceMapScalarFieldEnum]


  export const SpellSubschoolMapScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    schoolId: 'schoolId'
  };

  export type SpellSubschoolMapScalarFieldEnum = (typeof SpellSubschoolMapScalarFieldEnum)[keyof typeof SpellSubschoolMapScalarFieldEnum]


  export const SpellComponentMapScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    componentId: 'componentId'
  };

  export type SpellComponentMapScalarFieldEnum = (typeof SpellComponentMapScalarFieldEnum)[keyof typeof SpellComponentMapScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abilityId: 'abilityId',
    checkDescription: 'checkDescription',
    actionDescription: 'actionDescription',
    retryTypeId: 'retryTypeId',
    retryDescription: 'retryDescription',
    specialNotes: 'specialNotes',
    synergyNotes: 'synergyNotes',
    untrainedNotes: 'untrainedNotes',
    affectedByArmor: 'affectedByArmor',
    description: 'description',
    trainedOnly: 'trainedOnly'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const FeatScalarFieldEnum: {
    id: 'id',
    name: 'name',
    typeId: 'typeId',
    description: 'description',
    benefit: 'benefit',
    normalEffect: 'normalEffect',
    specialEffect: 'specialEffect',
    prerequisites: 'prerequisites',
    repeatable: 'repeatable',
    fighterBonus: 'fighterBonus'
  };

  export type FeatScalarFieldEnum = (typeof FeatScalarFieldEnum)[keyof typeof FeatScalarFieldEnum]


  export const FeatBenefitMapScalarFieldEnum: {
    featId: 'featId',
    typeId: 'typeId',
    referenceId: 'referenceId',
    amount: 'amount',
    index: 'index'
  };

  export type FeatBenefitMapScalarFieldEnum = (typeof FeatBenefitMapScalarFieldEnum)[keyof typeof FeatBenefitMapScalarFieldEnum]


  export const FeatPrerequisiteMapScalarFieldEnum: {
    featId: 'featId',
    typeId: 'typeId',
    referenceId: 'referenceId',
    amount: 'amount',
    index: 'index'
  };

  export type FeatPrerequisiteMapScalarFieldEnum = (typeof FeatPrerequisiteMapScalarFieldEnum)[keyof typeof FeatPrerequisiteMapScalarFieldEnum]


  export const RaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    editionId: 'editionId',
    isVisible: 'isVisible',
    description: 'description',
    sizeId: 'sizeId',
    speed: 'speed',
    favoredClassId: 'favoredClassId'
  };

  export type RaceScalarFieldEnum = (typeof RaceScalarFieldEnum)[keyof typeof RaceScalarFieldEnum]


  export const RaceTraitScalarFieldEnum: {
    slug: 'slug',
    name: 'name',
    description: 'description',
    hasValue: 'hasValue'
  };

  export type RaceTraitScalarFieldEnum = (typeof RaceTraitScalarFieldEnum)[keyof typeof RaceTraitScalarFieldEnum]


  export const RaceTraitMapScalarFieldEnum: {
    raceId: 'raceId',
    traitId: 'traitId',
    value: 'value'
  };

  export type RaceTraitMapScalarFieldEnum = (typeof RaceTraitMapScalarFieldEnum)[keyof typeof RaceTraitMapScalarFieldEnum]


  export const RaceAbilityAdjustmentScalarFieldEnum: {
    raceId: 'raceId',
    abilityId: 'abilityId',
    value: 'value'
  };

  export type RaceAbilityAdjustmentScalarFieldEnum = (typeof RaceAbilityAdjustmentScalarFieldEnum)[keyof typeof RaceAbilityAdjustmentScalarFieldEnum]


  export const RaceLanguageMapScalarFieldEnum: {
    raceId: 'raceId',
    languageId: 'languageId',
    isAutomatic: 'isAutomatic'
  };

  export type RaceLanguageMapScalarFieldEnum = (typeof RaceLanguageMapScalarFieldEnum)[keyof typeof RaceLanguageMapScalarFieldEnum]


  export const RaceSourceMapScalarFieldEnum: {
    id: 'id',
    raceId: 'raceId',
    bookId: 'bookId',
    pageNumber: 'pageNumber',
    sourceBookId: 'sourceBookId'
  };

  export type RaceSourceMapScalarFieldEnum = (typeof RaceSourceMapScalarFieldEnum)[keyof typeof RaceSourceMapScalarFieldEnum]


  export const ArmorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    cost: 'cost',
    bonus: 'bonus',
    dexterityCap: 'dexterityCap',
    checkPenalty: 'checkPenalty',
    arcaneSpellFailure: 'arcaneSpellFailure',
    speedCapThirty: 'speedCapThirty',
    speedCapTwenty: 'speedCapTwenty',
    weight: 'weight'
  };

  export type ArmorScalarFieldEnum = (typeof ArmorScalarFieldEnum)[keyof typeof ArmorScalarFieldEnum]


  export const WeaponScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    cost: 'cost',
    damageSmall: 'damageSmall',
    damageMedium: 'damageMedium',
    critical: 'critical',
    range: 'range',
    weight: 'weight',
    damageTypeId: 'damageTypeId'
  };

  export type WeaponScalarFieldEnum = (typeof WeaponScalarFieldEnum)[keyof typeof WeaponScalarFieldEnum]


  export const SourceBookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbreviation: 'abbreviation',
    releaseDate: 'releaseDate',
    editionId: 'editionId',
    description: 'description',
    isVisible: 'isVisible'
  };

  export type SourceBookScalarFieldEnum = (typeof SourceBookScalarFieldEnum)[keyof typeof SourceBookScalarFieldEnum]


  export const ReferenceTableScalarFieldEnum: {
    slug: 'slug',
    name: 'name',
    description: 'description'
  };

  export type ReferenceTableScalarFieldEnum = (typeof ReferenceTableScalarFieldEnum)[keyof typeof ReferenceTableScalarFieldEnum]


  export const ReferenceTableColumnScalarFieldEnum: {
    id: 'id',
    tableSlug: 'tableSlug',
    columnIndex: 'columnIndex',
    header: 'header',
    span: 'span',
    alignment: 'alignment'
  };

  export type ReferenceTableColumnScalarFieldEnum = (typeof ReferenceTableColumnScalarFieldEnum)[keyof typeof ReferenceTableColumnScalarFieldEnum]


  export const ReferenceTableRowScalarFieldEnum: {
    id: 'id',
    tableSlug: 'tableSlug',
    rowIndex: 'rowIndex',
    label: 'label'
  };

  export type ReferenceTableRowScalarFieldEnum = (typeof ReferenceTableRowScalarFieldEnum)[keyof typeof ReferenceTableRowScalarFieldEnum]


  export const ReferenceTableCellScalarFieldEnum: {
    id: 'id',
    rowId: 'rowId',
    columnId: 'columnId',
    value: 'value',
    colSpan: 'colSpan',
    rowSpan: 'rowSpan'
  };

  export type ReferenceTableCellScalarFieldEnum = (typeof ReferenceTableCellScalarFieldEnum)[keyof typeof ReferenceTableCellScalarFieldEnum]


  export const UserCharacterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    raceId: 'raceId',
    alignmentId: 'alignmentId',
    age: 'age',
    height: 'height',
    weight: 'weight',
    eyes: 'eyes',
    hair: 'hair',
    gender: 'gender',
    notes: 'notes'
  };

  export type UserCharacterScalarFieldEnum = (typeof UserCharacterScalarFieldEnum)[keyof typeof UserCharacterScalarFieldEnum]


  export const UserCharacterAttributeScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    attributeId: 'attributeId',
    value: 'value'
  };

  export type UserCharacterAttributeScalarFieldEnum = (typeof UserCharacterAttributeScalarFieldEnum)[keyof typeof UserCharacterAttributeScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    isAdmin: 'isAdmin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    preferredEditionId: 'preferredEditionId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const ClassOrderByRelevanceFieldEnum: {
    name: 'name',
    abbreviation: 'abbreviation',
    description: 'description'
  };

  export type ClassOrderByRelevanceFieldEnum = (typeof ClassOrderByRelevanceFieldEnum)[keyof typeof ClassOrderByRelevanceFieldEnum]


  export const ClassFeatureOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type ClassFeatureOrderByRelevanceFieldEnum = (typeof ClassFeatureOrderByRelevanceFieldEnum)[keyof typeof ClassFeatureOrderByRelevanceFieldEnum]


  export const SpellOrderByRelevanceFieldEnum: {
    name: 'name',
    summary: 'summary',
    description: 'description',
    castingTime: 'castingTime',
    range: 'range',
    rangeValue: 'rangeValue',
    area: 'area',
    duration: 'duration',
    savingThrow: 'savingThrow',
    spellResistance: 'spellResistance',
    effect: 'effect',
    target: 'target'
  };

  export type SpellOrderByRelevanceFieldEnum = (typeof SpellOrderByRelevanceFieldEnum)[keyof typeof SpellOrderByRelevanceFieldEnum]


  export const SkillOrderByRelevanceFieldEnum: {
    name: 'name',
    checkDescription: 'checkDescription',
    actionDescription: 'actionDescription',
    retryDescription: 'retryDescription',
    specialNotes: 'specialNotes',
    synergyNotes: 'synergyNotes',
    untrainedNotes: 'untrainedNotes',
    description: 'description'
  };

  export type SkillOrderByRelevanceFieldEnum = (typeof SkillOrderByRelevanceFieldEnum)[keyof typeof SkillOrderByRelevanceFieldEnum]


  export const FeatOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    benefit: 'benefit',
    normalEffect: 'normalEffect',
    specialEffect: 'specialEffect',
    prerequisites: 'prerequisites'
  };

  export type FeatOrderByRelevanceFieldEnum = (typeof FeatOrderByRelevanceFieldEnum)[keyof typeof FeatOrderByRelevanceFieldEnum]


  export const RaceOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type RaceOrderByRelevanceFieldEnum = (typeof RaceOrderByRelevanceFieldEnum)[keyof typeof RaceOrderByRelevanceFieldEnum]


  export const RaceTraitOrderByRelevanceFieldEnum: {
    slug: 'slug',
    name: 'name',
    description: 'description'
  };

  export type RaceTraitOrderByRelevanceFieldEnum = (typeof RaceTraitOrderByRelevanceFieldEnum)[keyof typeof RaceTraitOrderByRelevanceFieldEnum]


  export const RaceTraitMapOrderByRelevanceFieldEnum: {
    traitId: 'traitId',
    value: 'value'
  };

  export type RaceTraitMapOrderByRelevanceFieldEnum = (typeof RaceTraitMapOrderByRelevanceFieldEnum)[keyof typeof RaceTraitMapOrderByRelevanceFieldEnum]


  export const ArmorOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type ArmorOrderByRelevanceFieldEnum = (typeof ArmorOrderByRelevanceFieldEnum)[keyof typeof ArmorOrderByRelevanceFieldEnum]


  export const WeaponOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    damageSmall: 'damageSmall',
    damageMedium: 'damageMedium',
    critical: 'critical',
    range: 'range'
  };

  export type WeaponOrderByRelevanceFieldEnum = (typeof WeaponOrderByRelevanceFieldEnum)[keyof typeof WeaponOrderByRelevanceFieldEnum]


  export const SourceBookOrderByRelevanceFieldEnum: {
    name: 'name',
    abbreviation: 'abbreviation',
    description: 'description'
  };

  export type SourceBookOrderByRelevanceFieldEnum = (typeof SourceBookOrderByRelevanceFieldEnum)[keyof typeof SourceBookOrderByRelevanceFieldEnum]


  export const ReferenceTableOrderByRelevanceFieldEnum: {
    slug: 'slug',
    name: 'name',
    description: 'description'
  };

  export type ReferenceTableOrderByRelevanceFieldEnum = (typeof ReferenceTableOrderByRelevanceFieldEnum)[keyof typeof ReferenceTableOrderByRelevanceFieldEnum]


  export const ReferenceTableColumnOrderByRelevanceFieldEnum: {
    tableSlug: 'tableSlug',
    header: 'header',
    alignment: 'alignment'
  };

  export type ReferenceTableColumnOrderByRelevanceFieldEnum = (typeof ReferenceTableColumnOrderByRelevanceFieldEnum)[keyof typeof ReferenceTableColumnOrderByRelevanceFieldEnum]


  export const ReferenceTableRowOrderByRelevanceFieldEnum: {
    tableSlug: 'tableSlug',
    label: 'label'
  };

  export type ReferenceTableRowOrderByRelevanceFieldEnum = (typeof ReferenceTableRowOrderByRelevanceFieldEnum)[keyof typeof ReferenceTableRowOrderByRelevanceFieldEnum]


  export const ReferenceTableCellOrderByRelevanceFieldEnum: {
    value: 'value'
  };

  export type ReferenceTableCellOrderByRelevanceFieldEnum = (typeof ReferenceTableCellOrderByRelevanceFieldEnum)[keyof typeof ReferenceTableCellOrderByRelevanceFieldEnum]


  export const UserCharacterOrderByRelevanceFieldEnum: {
    name: 'name',
    eyes: 'eyes',
    hair: 'hair',
    gender: 'gender',
    notes: 'notes'
  };

  export type UserCharacterOrderByRelevanceFieldEnum = (typeof UserCharacterOrderByRelevanceFieldEnum)[keyof typeof UserCharacterOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    username: 'username',
    email: 'email',
    password: 'password'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: IntFilter<"Class"> | number
    name?: StringFilter<"Class"> | string
    abbreviation?: StringFilter<"Class"> | string
    editionId?: IntNullableFilter<"Class"> | number | null
    isPrestige?: BoolFilter<"Class"> | boolean
    isVisible?: BoolFilter<"Class"> | boolean
    canCastSpells?: BoolFilter<"Class"> | boolean
    hitDie?: IntFilter<"Class"> | number
    description?: StringNullableFilter<"Class"> | string | null
    skillPoints?: IntFilter<"Class"> | number
    castingAbilityId?: IntNullableFilter<"Class"> | number | null
    features?: ClassFeatureListRelationFilter
    attributes?: ClassLevelAttributeListRelationFilter
    spellProgression?: ClassSpellLevelListRelationFilter
    skills?: ClassSkillMapListRelationFilter
    sources?: ClassSourceMapListRelationFilter
    spellLevels?: SpellLevelMapListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    editionId?: SortOrderInput | SortOrder
    isPrestige?: SortOrder
    isVisible?: SortOrder
    canCastSpells?: SortOrder
    hitDie?: SortOrder
    description?: SortOrderInput | SortOrder
    skillPoints?: SortOrder
    castingAbilityId?: SortOrderInput | SortOrder
    features?: ClassFeatureOrderByRelationAggregateInput
    attributes?: ClassLevelAttributeOrderByRelationAggregateInput
    spellProgression?: ClassSpellLevelOrderByRelationAggregateInput
    skills?: ClassSkillMapOrderByRelationAggregateInput
    sources?: ClassSourceMapOrderByRelationAggregateInput
    spellLevels?: SpellLevelMapOrderByRelationAggregateInput
    _relevance?: ClassOrderByRelevanceInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    name?: StringFilter<"Class"> | string
    abbreviation?: StringFilter<"Class"> | string
    editionId?: IntNullableFilter<"Class"> | number | null
    isPrestige?: BoolFilter<"Class"> | boolean
    isVisible?: BoolFilter<"Class"> | boolean
    canCastSpells?: BoolFilter<"Class"> | boolean
    hitDie?: IntFilter<"Class"> | number
    description?: StringNullableFilter<"Class"> | string | null
    skillPoints?: IntFilter<"Class"> | number
    castingAbilityId?: IntNullableFilter<"Class"> | number | null
    features?: ClassFeatureListRelationFilter
    attributes?: ClassLevelAttributeListRelationFilter
    spellProgression?: ClassSpellLevelListRelationFilter
    skills?: ClassSkillMapListRelationFilter
    sources?: ClassSourceMapListRelationFilter
    spellLevels?: SpellLevelMapListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    editionId?: SortOrderInput | SortOrder
    isPrestige?: SortOrder
    isVisible?: SortOrder
    canCastSpells?: SortOrder
    hitDie?: SortOrder
    description?: SortOrderInput | SortOrder
    skillPoints?: SortOrder
    castingAbilityId?: SortOrderInput | SortOrder
    _count?: ClassCountOrderByAggregateInput
    _avg?: ClassAvgOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
    _sum?: ClassSumOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Class"> | number
    name?: StringWithAggregatesFilter<"Class"> | string
    abbreviation?: StringWithAggregatesFilter<"Class"> | string
    editionId?: IntNullableWithAggregatesFilter<"Class"> | number | null
    isPrestige?: BoolWithAggregatesFilter<"Class"> | boolean
    isVisible?: BoolWithAggregatesFilter<"Class"> | boolean
    canCastSpells?: BoolWithAggregatesFilter<"Class"> | boolean
    hitDie?: IntWithAggregatesFilter<"Class"> | number
    description?: StringNullableWithAggregatesFilter<"Class"> | string | null
    skillPoints?: IntWithAggregatesFilter<"Class"> | number
    castingAbilityId?: IntNullableWithAggregatesFilter<"Class"> | number | null
  }

  export type ClassFeatureWhereInput = {
    AND?: ClassFeatureWhereInput | ClassFeatureWhereInput[]
    OR?: ClassFeatureWhereInput[]
    NOT?: ClassFeatureWhereInput | ClassFeatureWhereInput[]
    id?: IntFilter<"ClassFeature"> | number
    classId?: IntFilter<"ClassFeature"> | number
    name?: StringFilter<"ClassFeature"> | string
    description?: StringNullableFilter<"ClassFeature"> | string | null
    level?: IntNullableFilter<"ClassFeature"> | number | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type ClassFeatureOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    class?: ClassOrderByWithRelationInput
    _relevance?: ClassFeatureOrderByRelevanceInput
  }

  export type ClassFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassFeatureWhereInput | ClassFeatureWhereInput[]
    OR?: ClassFeatureWhereInput[]
    NOT?: ClassFeatureWhereInput | ClassFeatureWhereInput[]
    classId?: IntFilter<"ClassFeature"> | number
    name?: StringFilter<"ClassFeature"> | string
    description?: StringNullableFilter<"ClassFeature"> | string | null
    level?: IntNullableFilter<"ClassFeature"> | number | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id">

  export type ClassFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    _count?: ClassFeatureCountOrderByAggregateInput
    _avg?: ClassFeatureAvgOrderByAggregateInput
    _max?: ClassFeatureMaxOrderByAggregateInput
    _min?: ClassFeatureMinOrderByAggregateInput
    _sum?: ClassFeatureSumOrderByAggregateInput
  }

  export type ClassFeatureScalarWhereWithAggregatesInput = {
    AND?: ClassFeatureScalarWhereWithAggregatesInput | ClassFeatureScalarWhereWithAggregatesInput[]
    OR?: ClassFeatureScalarWhereWithAggregatesInput[]
    NOT?: ClassFeatureScalarWhereWithAggregatesInput | ClassFeatureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassFeature"> | number
    classId?: IntWithAggregatesFilter<"ClassFeature"> | number
    name?: StringWithAggregatesFilter<"ClassFeature"> | string
    description?: StringNullableWithAggregatesFilter<"ClassFeature"> | string | null
    level?: IntNullableWithAggregatesFilter<"ClassFeature"> | number | null
  }

  export type ClassSpellLevelWhereInput = {
    AND?: ClassSpellLevelWhereInput | ClassSpellLevelWhereInput[]
    OR?: ClassSpellLevelWhereInput[]
    NOT?: ClassSpellLevelWhereInput | ClassSpellLevelWhereInput[]
    id?: IntFilter<"ClassSpellLevel"> | number
    classId?: IntFilter<"ClassSpellLevel"> | number
    spellLevel?: IntFilter<"ClassSpellLevel"> | number
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type ClassSpellLevelOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    spellLevel?: SortOrder
    class?: ClassOrderByWithRelationInput
  }

  export type ClassSpellLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassSpellLevelWhereInput | ClassSpellLevelWhereInput[]
    OR?: ClassSpellLevelWhereInput[]
    NOT?: ClassSpellLevelWhereInput | ClassSpellLevelWhereInput[]
    classId?: IntFilter<"ClassSpellLevel"> | number
    spellLevel?: IntFilter<"ClassSpellLevel"> | number
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id">

  export type ClassSpellLevelOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    spellLevel?: SortOrder
    _count?: ClassSpellLevelCountOrderByAggregateInput
    _avg?: ClassSpellLevelAvgOrderByAggregateInput
    _max?: ClassSpellLevelMaxOrderByAggregateInput
    _min?: ClassSpellLevelMinOrderByAggregateInput
    _sum?: ClassSpellLevelSumOrderByAggregateInput
  }

  export type ClassSpellLevelScalarWhereWithAggregatesInput = {
    AND?: ClassSpellLevelScalarWhereWithAggregatesInput | ClassSpellLevelScalarWhereWithAggregatesInput[]
    OR?: ClassSpellLevelScalarWhereWithAggregatesInput[]
    NOT?: ClassSpellLevelScalarWhereWithAggregatesInput | ClassSpellLevelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassSpellLevel"> | number
    classId?: IntWithAggregatesFilter<"ClassSpellLevel"> | number
    spellLevel?: IntWithAggregatesFilter<"ClassSpellLevel"> | number
  }

  export type ClassLevelAttributeWhereInput = {
    AND?: ClassLevelAttributeWhereInput | ClassLevelAttributeWhereInput[]
    OR?: ClassLevelAttributeWhereInput[]
    NOT?: ClassLevelAttributeWhereInput | ClassLevelAttributeWhereInput[]
    id?: IntFilter<"ClassLevelAttribute"> | number
    classId?: IntFilter<"ClassLevelAttribute"> | number
    baseAttackBonus?: IntFilter<"ClassLevelAttribute"> | number
    fortSave?: IntFilter<"ClassLevelAttribute"> | number
    refSave?: IntFilter<"ClassLevelAttribute"> | number
    willSave?: IntFilter<"ClassLevelAttribute"> | number
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type ClassLevelAttributeOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    baseAttackBonus?: SortOrder
    fortSave?: SortOrder
    refSave?: SortOrder
    willSave?: SortOrder
    class?: ClassOrderByWithRelationInput
  }

  export type ClassLevelAttributeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassLevelAttributeWhereInput | ClassLevelAttributeWhereInput[]
    OR?: ClassLevelAttributeWhereInput[]
    NOT?: ClassLevelAttributeWhereInput | ClassLevelAttributeWhereInput[]
    classId?: IntFilter<"ClassLevelAttribute"> | number
    baseAttackBonus?: IntFilter<"ClassLevelAttribute"> | number
    fortSave?: IntFilter<"ClassLevelAttribute"> | number
    refSave?: IntFilter<"ClassLevelAttribute"> | number
    willSave?: IntFilter<"ClassLevelAttribute"> | number
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id">

  export type ClassLevelAttributeOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    baseAttackBonus?: SortOrder
    fortSave?: SortOrder
    refSave?: SortOrder
    willSave?: SortOrder
    _count?: ClassLevelAttributeCountOrderByAggregateInput
    _avg?: ClassLevelAttributeAvgOrderByAggregateInput
    _max?: ClassLevelAttributeMaxOrderByAggregateInput
    _min?: ClassLevelAttributeMinOrderByAggregateInput
    _sum?: ClassLevelAttributeSumOrderByAggregateInput
  }

  export type ClassLevelAttributeScalarWhereWithAggregatesInput = {
    AND?: ClassLevelAttributeScalarWhereWithAggregatesInput | ClassLevelAttributeScalarWhereWithAggregatesInput[]
    OR?: ClassLevelAttributeScalarWhereWithAggregatesInput[]
    NOT?: ClassLevelAttributeScalarWhereWithAggregatesInput | ClassLevelAttributeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassLevelAttribute"> | number
    classId?: IntWithAggregatesFilter<"ClassLevelAttribute"> | number
    baseAttackBonus?: IntWithAggregatesFilter<"ClassLevelAttribute"> | number
    fortSave?: IntWithAggregatesFilter<"ClassLevelAttribute"> | number
    refSave?: IntWithAggregatesFilter<"ClassLevelAttribute"> | number
    willSave?: IntWithAggregatesFilter<"ClassLevelAttribute"> | number
  }

  export type ClassSkillMapWhereInput = {
    AND?: ClassSkillMapWhereInput | ClassSkillMapWhereInput[]
    OR?: ClassSkillMapWhereInput[]
    NOT?: ClassSkillMapWhereInput | ClassSkillMapWhereInput[]
    id?: IntFilter<"ClassSkillMap"> | number
    classId?: IntFilter<"ClassSkillMap"> | number
    skillId?: IntFilter<"ClassSkillMap"> | number
    Class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    Skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type ClassSkillMapOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
    Class?: ClassOrderByWithRelationInput
    Skill?: SkillOrderByWithRelationInput
  }

  export type ClassSkillMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassSkillMapWhereInput | ClassSkillMapWhereInput[]
    OR?: ClassSkillMapWhereInput[]
    NOT?: ClassSkillMapWhereInput | ClassSkillMapWhereInput[]
    classId?: IntFilter<"ClassSkillMap"> | number
    skillId?: IntFilter<"ClassSkillMap"> | number
    Class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    Skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "id">

  export type ClassSkillMapOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
    _count?: ClassSkillMapCountOrderByAggregateInput
    _avg?: ClassSkillMapAvgOrderByAggregateInput
    _max?: ClassSkillMapMaxOrderByAggregateInput
    _min?: ClassSkillMapMinOrderByAggregateInput
    _sum?: ClassSkillMapSumOrderByAggregateInput
  }

  export type ClassSkillMapScalarWhereWithAggregatesInput = {
    AND?: ClassSkillMapScalarWhereWithAggregatesInput | ClassSkillMapScalarWhereWithAggregatesInput[]
    OR?: ClassSkillMapScalarWhereWithAggregatesInput[]
    NOT?: ClassSkillMapScalarWhereWithAggregatesInput | ClassSkillMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassSkillMap"> | number
    classId?: IntWithAggregatesFilter<"ClassSkillMap"> | number
    skillId?: IntWithAggregatesFilter<"ClassSkillMap"> | number
  }

  export type ClassSourceMapWhereInput = {
    AND?: ClassSourceMapWhereInput | ClassSourceMapWhereInput[]
    OR?: ClassSourceMapWhereInput[]
    NOT?: ClassSourceMapWhereInput | ClassSourceMapWhereInput[]
    id?: IntFilter<"ClassSourceMap"> | number
    classId?: IntFilter<"ClassSourceMap"> | number
    bookId?: IntFilter<"ClassSourceMap"> | number
    pageNumber?: IntNullableFilter<"ClassSourceMap"> | number | null
    sourceBookId?: IntNullableFilter<"ClassSourceMap"> | number | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    SourceBook?: XOR<SourceBookNullableScalarRelationFilter, SourceBookWhereInput> | null
  }

  export type ClassSourceMapOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrderInput | SortOrder
    sourceBookId?: SortOrderInput | SortOrder
    class?: ClassOrderByWithRelationInput
    SourceBook?: SourceBookOrderByWithRelationInput
  }

  export type ClassSourceMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassSourceMapWhereInput | ClassSourceMapWhereInput[]
    OR?: ClassSourceMapWhereInput[]
    NOT?: ClassSourceMapWhereInput | ClassSourceMapWhereInput[]
    classId?: IntFilter<"ClassSourceMap"> | number
    bookId?: IntFilter<"ClassSourceMap"> | number
    pageNumber?: IntNullableFilter<"ClassSourceMap"> | number | null
    sourceBookId?: IntNullableFilter<"ClassSourceMap"> | number | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    SourceBook?: XOR<SourceBookNullableScalarRelationFilter, SourceBookWhereInput> | null
  }, "id">

  export type ClassSourceMapOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrderInput | SortOrder
    sourceBookId?: SortOrderInput | SortOrder
    _count?: ClassSourceMapCountOrderByAggregateInput
    _avg?: ClassSourceMapAvgOrderByAggregateInput
    _max?: ClassSourceMapMaxOrderByAggregateInput
    _min?: ClassSourceMapMinOrderByAggregateInput
    _sum?: ClassSourceMapSumOrderByAggregateInput
  }

  export type ClassSourceMapScalarWhereWithAggregatesInput = {
    AND?: ClassSourceMapScalarWhereWithAggregatesInput | ClassSourceMapScalarWhereWithAggregatesInput[]
    OR?: ClassSourceMapScalarWhereWithAggregatesInput[]
    NOT?: ClassSourceMapScalarWhereWithAggregatesInput | ClassSourceMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassSourceMap"> | number
    classId?: IntWithAggregatesFilter<"ClassSourceMap"> | number
    bookId?: IntWithAggregatesFilter<"ClassSourceMap"> | number
    pageNumber?: IntNullableWithAggregatesFilter<"ClassSourceMap"> | number | null
    sourceBookId?: IntNullableWithAggregatesFilter<"ClassSourceMap"> | number | null
  }

  export type SpellLevelMapWhereInput = {
    AND?: SpellLevelMapWhereInput | SpellLevelMapWhereInput[]
    OR?: SpellLevelMapWhereInput[]
    NOT?: SpellLevelMapWhereInput | SpellLevelMapWhereInput[]
    id?: IntFilter<"SpellLevelMap"> | number
    classId?: IntFilter<"SpellLevelMap"> | number
    spellId?: IntFilter<"SpellLevelMap"> | number
    level?: IntFilter<"SpellLevelMap"> | number
    isVisible?: BoolFilter<"SpellLevelMap"> | boolean
    spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type SpellLevelMapOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    spellId?: SortOrder
    level?: SortOrder
    isVisible?: SortOrder
    spell?: SpellOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type SpellLevelMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpellLevelMapWhereInput | SpellLevelMapWhereInput[]
    OR?: SpellLevelMapWhereInput[]
    NOT?: SpellLevelMapWhereInput | SpellLevelMapWhereInput[]
    classId?: IntFilter<"SpellLevelMap"> | number
    spellId?: IntFilter<"SpellLevelMap"> | number
    level?: IntFilter<"SpellLevelMap"> | number
    isVisible?: BoolFilter<"SpellLevelMap"> | boolean
    spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id">

  export type SpellLevelMapOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    spellId?: SortOrder
    level?: SortOrder
    isVisible?: SortOrder
    _count?: SpellLevelMapCountOrderByAggregateInput
    _avg?: SpellLevelMapAvgOrderByAggregateInput
    _max?: SpellLevelMapMaxOrderByAggregateInput
    _min?: SpellLevelMapMinOrderByAggregateInput
    _sum?: SpellLevelMapSumOrderByAggregateInput
  }

  export type SpellLevelMapScalarWhereWithAggregatesInput = {
    AND?: SpellLevelMapScalarWhereWithAggregatesInput | SpellLevelMapScalarWhereWithAggregatesInput[]
    OR?: SpellLevelMapScalarWhereWithAggregatesInput[]
    NOT?: SpellLevelMapScalarWhereWithAggregatesInput | SpellLevelMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellLevelMap"> | number
    classId?: IntWithAggregatesFilter<"SpellLevelMap"> | number
    spellId?: IntWithAggregatesFilter<"SpellLevelMap"> | number
    level?: IntWithAggregatesFilter<"SpellLevelMap"> | number
    isVisible?: BoolWithAggregatesFilter<"SpellLevelMap"> | boolean
  }

  export type SpellWhereInput = {
    AND?: SpellWhereInput | SpellWhereInput[]
    OR?: SpellWhereInput[]
    NOT?: SpellWhereInput | SpellWhereInput[]
    id?: IntFilter<"Spell"> | number
    name?: StringFilter<"Spell"> | string
    summary?: StringNullableFilter<"Spell"> | string | null
    description?: StringNullableFilter<"Spell"> | string | null
    castingTime?: StringNullableFilter<"Spell"> | string | null
    range?: StringNullableFilter<"Spell"> | string | null
    rangeTypeId?: IntNullableFilter<"Spell"> | number | null
    rangeValue?: StringNullableFilter<"Spell"> | string | null
    area?: StringNullableFilter<"Spell"> | string | null
    duration?: StringNullableFilter<"Spell"> | string | null
    savingThrow?: StringNullableFilter<"Spell"> | string | null
    spellResistance?: StringNullableFilter<"Spell"> | string | null
    editionId?: IntFilter<"Spell"> | number
    baseLevel?: IntFilter<"Spell"> | number
    effect?: StringNullableFilter<"Spell"> | string | null
    target?: StringNullableFilter<"Spell"> | string | null
    descriptors?: SpellDescriptorMapListRelationFilter
    levelMapping?: SpellLevelMapListRelationFilter
    schools?: SpellSchoolMapListRelationFilter
    sources?: SpellSourceMapListRelationFilter
    subschools?: SpellSubschoolMapListRelationFilter
  }

  export type SpellOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    summary?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    castingTime?: SortOrderInput | SortOrder
    range?: SortOrderInput | SortOrder
    rangeTypeId?: SortOrderInput | SortOrder
    rangeValue?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    savingThrow?: SortOrderInput | SortOrder
    spellResistance?: SortOrderInput | SortOrder
    editionId?: SortOrder
    baseLevel?: SortOrder
    effect?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    descriptors?: SpellDescriptorMapOrderByRelationAggregateInput
    levelMapping?: SpellLevelMapOrderByRelationAggregateInput
    schools?: SpellSchoolMapOrderByRelationAggregateInput
    sources?: SpellSourceMapOrderByRelationAggregateInput
    subschools?: SpellSubschoolMapOrderByRelationAggregateInput
    _relevance?: SpellOrderByRelevanceInput
  }

  export type SpellWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpellWhereInput | SpellWhereInput[]
    OR?: SpellWhereInput[]
    NOT?: SpellWhereInput | SpellWhereInput[]
    name?: StringFilter<"Spell"> | string
    summary?: StringNullableFilter<"Spell"> | string | null
    description?: StringNullableFilter<"Spell"> | string | null
    castingTime?: StringNullableFilter<"Spell"> | string | null
    range?: StringNullableFilter<"Spell"> | string | null
    rangeTypeId?: IntNullableFilter<"Spell"> | number | null
    rangeValue?: StringNullableFilter<"Spell"> | string | null
    area?: StringNullableFilter<"Spell"> | string | null
    duration?: StringNullableFilter<"Spell"> | string | null
    savingThrow?: StringNullableFilter<"Spell"> | string | null
    spellResistance?: StringNullableFilter<"Spell"> | string | null
    editionId?: IntFilter<"Spell"> | number
    baseLevel?: IntFilter<"Spell"> | number
    effect?: StringNullableFilter<"Spell"> | string | null
    target?: StringNullableFilter<"Spell"> | string | null
    descriptors?: SpellDescriptorMapListRelationFilter
    levelMapping?: SpellLevelMapListRelationFilter
    schools?: SpellSchoolMapListRelationFilter
    sources?: SpellSourceMapListRelationFilter
    subschools?: SpellSubschoolMapListRelationFilter
  }, "id">

  export type SpellOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    summary?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    castingTime?: SortOrderInput | SortOrder
    range?: SortOrderInput | SortOrder
    rangeTypeId?: SortOrderInput | SortOrder
    rangeValue?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    savingThrow?: SortOrderInput | SortOrder
    spellResistance?: SortOrderInput | SortOrder
    editionId?: SortOrder
    baseLevel?: SortOrder
    effect?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    _count?: SpellCountOrderByAggregateInput
    _avg?: SpellAvgOrderByAggregateInput
    _max?: SpellMaxOrderByAggregateInput
    _min?: SpellMinOrderByAggregateInput
    _sum?: SpellSumOrderByAggregateInput
  }

  export type SpellScalarWhereWithAggregatesInput = {
    AND?: SpellScalarWhereWithAggregatesInput | SpellScalarWhereWithAggregatesInput[]
    OR?: SpellScalarWhereWithAggregatesInput[]
    NOT?: SpellScalarWhereWithAggregatesInput | SpellScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Spell"> | number
    name?: StringWithAggregatesFilter<"Spell"> | string
    summary?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    description?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    castingTime?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    range?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    rangeTypeId?: IntNullableWithAggregatesFilter<"Spell"> | number | null
    rangeValue?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    area?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    duration?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    savingThrow?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    spellResistance?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    editionId?: IntWithAggregatesFilter<"Spell"> | number
    baseLevel?: IntWithAggregatesFilter<"Spell"> | number
    effect?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    target?: StringNullableWithAggregatesFilter<"Spell"> | string | null
  }

  export type SpellDescriptorMapWhereInput = {
    AND?: SpellDescriptorMapWhereInput | SpellDescriptorMapWhereInput[]
    OR?: SpellDescriptorMapWhereInput[]
    NOT?: SpellDescriptorMapWhereInput | SpellDescriptorMapWhereInput[]
    id?: IntFilter<"SpellDescriptorMap"> | number
    spellId?: IntFilter<"SpellDescriptorMap"> | number
    descriptorId?: IntFilter<"SpellDescriptorMap"> | number
    Spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
  }

  export type SpellDescriptorMapOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    descriptorId?: SortOrder
    Spell?: SpellOrderByWithRelationInput
  }

  export type SpellDescriptorMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpellDescriptorMapWhereInput | SpellDescriptorMapWhereInput[]
    OR?: SpellDescriptorMapWhereInput[]
    NOT?: SpellDescriptorMapWhereInput | SpellDescriptorMapWhereInput[]
    spellId?: IntFilter<"SpellDescriptorMap"> | number
    descriptorId?: IntFilter<"SpellDescriptorMap"> | number
    Spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
  }, "id">

  export type SpellDescriptorMapOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    descriptorId?: SortOrder
    _count?: SpellDescriptorMapCountOrderByAggregateInput
    _avg?: SpellDescriptorMapAvgOrderByAggregateInput
    _max?: SpellDescriptorMapMaxOrderByAggregateInput
    _min?: SpellDescriptorMapMinOrderByAggregateInput
    _sum?: SpellDescriptorMapSumOrderByAggregateInput
  }

  export type SpellDescriptorMapScalarWhereWithAggregatesInput = {
    AND?: SpellDescriptorMapScalarWhereWithAggregatesInput | SpellDescriptorMapScalarWhereWithAggregatesInput[]
    OR?: SpellDescriptorMapScalarWhereWithAggregatesInput[]
    NOT?: SpellDescriptorMapScalarWhereWithAggregatesInput | SpellDescriptorMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellDescriptorMap"> | number
    spellId?: IntWithAggregatesFilter<"SpellDescriptorMap"> | number
    descriptorId?: IntWithAggregatesFilter<"SpellDescriptorMap"> | number
  }

  export type SpellSchoolMapWhereInput = {
    AND?: SpellSchoolMapWhereInput | SpellSchoolMapWhereInput[]
    OR?: SpellSchoolMapWhereInput[]
    NOT?: SpellSchoolMapWhereInput | SpellSchoolMapWhereInput[]
    id?: IntFilter<"SpellSchoolMap"> | number
    spellId?: IntFilter<"SpellSchoolMap"> | number
    schoolId?: IntFilter<"SpellSchoolMap"> | number
    Spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
  }

  export type SpellSchoolMapOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
    Spell?: SpellOrderByWithRelationInput
  }

  export type SpellSchoolMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpellSchoolMapWhereInput | SpellSchoolMapWhereInput[]
    OR?: SpellSchoolMapWhereInput[]
    NOT?: SpellSchoolMapWhereInput | SpellSchoolMapWhereInput[]
    spellId?: IntFilter<"SpellSchoolMap"> | number
    schoolId?: IntFilter<"SpellSchoolMap"> | number
    Spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
  }, "id">

  export type SpellSchoolMapOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
    _count?: SpellSchoolMapCountOrderByAggregateInput
    _avg?: SpellSchoolMapAvgOrderByAggregateInput
    _max?: SpellSchoolMapMaxOrderByAggregateInput
    _min?: SpellSchoolMapMinOrderByAggregateInput
    _sum?: SpellSchoolMapSumOrderByAggregateInput
  }

  export type SpellSchoolMapScalarWhereWithAggregatesInput = {
    AND?: SpellSchoolMapScalarWhereWithAggregatesInput | SpellSchoolMapScalarWhereWithAggregatesInput[]
    OR?: SpellSchoolMapScalarWhereWithAggregatesInput[]
    NOT?: SpellSchoolMapScalarWhereWithAggregatesInput | SpellSchoolMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellSchoolMap"> | number
    spellId?: IntWithAggregatesFilter<"SpellSchoolMap"> | number
    schoolId?: IntWithAggregatesFilter<"SpellSchoolMap"> | number
  }

  export type SpellSourceMapWhereInput = {
    AND?: SpellSourceMapWhereInput | SpellSourceMapWhereInput[]
    OR?: SpellSourceMapWhereInput[]
    NOT?: SpellSourceMapWhereInput | SpellSourceMapWhereInput[]
    id?: IntFilter<"SpellSourceMap"> | number
    spellId?: IntFilter<"SpellSourceMap"> | number
    bookId?: IntFilter<"SpellSourceMap"> | number
    pageNumber?: IntNullableFilter<"SpellSourceMap"> | number | null
    sourceBookId?: IntNullableFilter<"SpellSourceMap"> | number | null
    Spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
    SourceBook?: XOR<SourceBookNullableScalarRelationFilter, SourceBookWhereInput> | null
  }

  export type SpellSourceMapOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrderInput | SortOrder
    sourceBookId?: SortOrderInput | SortOrder
    Spell?: SpellOrderByWithRelationInput
    SourceBook?: SourceBookOrderByWithRelationInput
  }

  export type SpellSourceMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpellSourceMapWhereInput | SpellSourceMapWhereInput[]
    OR?: SpellSourceMapWhereInput[]
    NOT?: SpellSourceMapWhereInput | SpellSourceMapWhereInput[]
    spellId?: IntFilter<"SpellSourceMap"> | number
    bookId?: IntFilter<"SpellSourceMap"> | number
    pageNumber?: IntNullableFilter<"SpellSourceMap"> | number | null
    sourceBookId?: IntNullableFilter<"SpellSourceMap"> | number | null
    Spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
    SourceBook?: XOR<SourceBookNullableScalarRelationFilter, SourceBookWhereInput> | null
  }, "id">

  export type SpellSourceMapOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrderInput | SortOrder
    sourceBookId?: SortOrderInput | SortOrder
    _count?: SpellSourceMapCountOrderByAggregateInput
    _avg?: SpellSourceMapAvgOrderByAggregateInput
    _max?: SpellSourceMapMaxOrderByAggregateInput
    _min?: SpellSourceMapMinOrderByAggregateInput
    _sum?: SpellSourceMapSumOrderByAggregateInput
  }

  export type SpellSourceMapScalarWhereWithAggregatesInput = {
    AND?: SpellSourceMapScalarWhereWithAggregatesInput | SpellSourceMapScalarWhereWithAggregatesInput[]
    OR?: SpellSourceMapScalarWhereWithAggregatesInput[]
    NOT?: SpellSourceMapScalarWhereWithAggregatesInput | SpellSourceMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellSourceMap"> | number
    spellId?: IntWithAggregatesFilter<"SpellSourceMap"> | number
    bookId?: IntWithAggregatesFilter<"SpellSourceMap"> | number
    pageNumber?: IntNullableWithAggregatesFilter<"SpellSourceMap"> | number | null
    sourceBookId?: IntNullableWithAggregatesFilter<"SpellSourceMap"> | number | null
  }

  export type SpellSubschoolMapWhereInput = {
    AND?: SpellSubschoolMapWhereInput | SpellSubschoolMapWhereInput[]
    OR?: SpellSubschoolMapWhereInput[]
    NOT?: SpellSubschoolMapWhereInput | SpellSubschoolMapWhereInput[]
    id?: IntFilter<"SpellSubschoolMap"> | number
    spellId?: IntFilter<"SpellSubschoolMap"> | number
    schoolId?: IntFilter<"SpellSubschoolMap"> | number
    Spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
  }

  export type SpellSubschoolMapOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
    Spell?: SpellOrderByWithRelationInput
  }

  export type SpellSubschoolMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpellSubschoolMapWhereInput | SpellSubschoolMapWhereInput[]
    OR?: SpellSubschoolMapWhereInput[]
    NOT?: SpellSubschoolMapWhereInput | SpellSubschoolMapWhereInput[]
    spellId?: IntFilter<"SpellSubschoolMap"> | number
    schoolId?: IntFilter<"SpellSubschoolMap"> | number
    Spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
  }, "id">

  export type SpellSubschoolMapOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
    _count?: SpellSubschoolMapCountOrderByAggregateInput
    _avg?: SpellSubschoolMapAvgOrderByAggregateInput
    _max?: SpellSubschoolMapMaxOrderByAggregateInput
    _min?: SpellSubschoolMapMinOrderByAggregateInput
    _sum?: SpellSubschoolMapSumOrderByAggregateInput
  }

  export type SpellSubschoolMapScalarWhereWithAggregatesInput = {
    AND?: SpellSubschoolMapScalarWhereWithAggregatesInput | SpellSubschoolMapScalarWhereWithAggregatesInput[]
    OR?: SpellSubschoolMapScalarWhereWithAggregatesInput[]
    NOT?: SpellSubschoolMapScalarWhereWithAggregatesInput | SpellSubschoolMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellSubschoolMap"> | number
    spellId?: IntWithAggregatesFilter<"SpellSubschoolMap"> | number
    schoolId?: IntWithAggregatesFilter<"SpellSubschoolMap"> | number
  }

  export type SpellComponentMapWhereInput = {
    AND?: SpellComponentMapWhereInput | SpellComponentMapWhereInput[]
    OR?: SpellComponentMapWhereInput[]
    NOT?: SpellComponentMapWhereInput | SpellComponentMapWhereInput[]
    id?: IntFilter<"SpellComponentMap"> | number
    spellId?: IntFilter<"SpellComponentMap"> | number
    componentId?: IntFilter<"SpellComponentMap"> | number
  }

  export type SpellComponentMapOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    componentId?: SortOrder
  }

  export type SpellComponentMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpellComponentMapWhereInput | SpellComponentMapWhereInput[]
    OR?: SpellComponentMapWhereInput[]
    NOT?: SpellComponentMapWhereInput | SpellComponentMapWhereInput[]
    spellId?: IntFilter<"SpellComponentMap"> | number
    componentId?: IntFilter<"SpellComponentMap"> | number
  }, "id">

  export type SpellComponentMapOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    componentId?: SortOrder
    _count?: SpellComponentMapCountOrderByAggregateInput
    _avg?: SpellComponentMapAvgOrderByAggregateInput
    _max?: SpellComponentMapMaxOrderByAggregateInput
    _min?: SpellComponentMapMinOrderByAggregateInput
    _sum?: SpellComponentMapSumOrderByAggregateInput
  }

  export type SpellComponentMapScalarWhereWithAggregatesInput = {
    AND?: SpellComponentMapScalarWhereWithAggregatesInput | SpellComponentMapScalarWhereWithAggregatesInput[]
    OR?: SpellComponentMapScalarWhereWithAggregatesInput[]
    NOT?: SpellComponentMapScalarWhereWithAggregatesInput | SpellComponentMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellComponentMap"> | number
    spellId?: IntWithAggregatesFilter<"SpellComponentMap"> | number
    componentId?: IntWithAggregatesFilter<"SpellComponentMap"> | number
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: IntFilter<"Skill"> | number
    name?: StringFilter<"Skill"> | string
    abilityId?: IntFilter<"Skill"> | number
    checkDescription?: StringNullableFilter<"Skill"> | string | null
    actionDescription?: StringNullableFilter<"Skill"> | string | null
    retryTypeId?: IntNullableFilter<"Skill"> | number | null
    retryDescription?: StringNullableFilter<"Skill"> | string | null
    specialNotes?: StringNullableFilter<"Skill"> | string | null
    synergyNotes?: StringNullableFilter<"Skill"> | string | null
    untrainedNotes?: StringNullableFilter<"Skill"> | string | null
    affectedByArmor?: BoolFilter<"Skill"> | boolean
    description?: StringNullableFilter<"Skill"> | string | null
    trainedOnly?: BoolNullableFilter<"Skill"> | boolean | null
    classes?: ClassSkillMapListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abilityId?: SortOrder
    checkDescription?: SortOrderInput | SortOrder
    actionDescription?: SortOrderInput | SortOrder
    retryTypeId?: SortOrderInput | SortOrder
    retryDescription?: SortOrderInput | SortOrder
    specialNotes?: SortOrderInput | SortOrder
    synergyNotes?: SortOrderInput | SortOrder
    untrainedNotes?: SortOrderInput | SortOrder
    affectedByArmor?: SortOrder
    description?: SortOrderInput | SortOrder
    trainedOnly?: SortOrderInput | SortOrder
    classes?: ClassSkillMapOrderByRelationAggregateInput
    _relevance?: SkillOrderByRelevanceInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    name?: StringFilter<"Skill"> | string
    abilityId?: IntFilter<"Skill"> | number
    checkDescription?: StringNullableFilter<"Skill"> | string | null
    actionDescription?: StringNullableFilter<"Skill"> | string | null
    retryTypeId?: IntNullableFilter<"Skill"> | number | null
    retryDescription?: StringNullableFilter<"Skill"> | string | null
    specialNotes?: StringNullableFilter<"Skill"> | string | null
    synergyNotes?: StringNullableFilter<"Skill"> | string | null
    untrainedNotes?: StringNullableFilter<"Skill"> | string | null
    affectedByArmor?: BoolFilter<"Skill"> | boolean
    description?: StringNullableFilter<"Skill"> | string | null
    trainedOnly?: BoolNullableFilter<"Skill"> | boolean | null
    classes?: ClassSkillMapListRelationFilter
  }, "id">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abilityId?: SortOrder
    checkDescription?: SortOrderInput | SortOrder
    actionDescription?: SortOrderInput | SortOrder
    retryTypeId?: SortOrderInput | SortOrder
    retryDescription?: SortOrderInput | SortOrder
    specialNotes?: SortOrderInput | SortOrder
    synergyNotes?: SortOrderInput | SortOrder
    untrainedNotes?: SortOrderInput | SortOrder
    affectedByArmor?: SortOrder
    description?: SortOrderInput | SortOrder
    trainedOnly?: SortOrderInput | SortOrder
    _count?: SkillCountOrderByAggregateInput
    _avg?: SkillAvgOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
    _sum?: SkillSumOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Skill"> | number
    name?: StringWithAggregatesFilter<"Skill"> | string
    abilityId?: IntWithAggregatesFilter<"Skill"> | number
    checkDescription?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    actionDescription?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    retryTypeId?: IntNullableWithAggregatesFilter<"Skill"> | number | null
    retryDescription?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    specialNotes?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    synergyNotes?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    untrainedNotes?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    affectedByArmor?: BoolWithAggregatesFilter<"Skill"> | boolean
    description?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    trainedOnly?: BoolNullableWithAggregatesFilter<"Skill"> | boolean | null
  }

  export type FeatWhereInput = {
    AND?: FeatWhereInput | FeatWhereInput[]
    OR?: FeatWhereInput[]
    NOT?: FeatWhereInput | FeatWhereInput[]
    id?: IntFilter<"Feat"> | number
    name?: StringFilter<"Feat"> | string
    typeId?: IntFilter<"Feat"> | number
    description?: StringNullableFilter<"Feat"> | string | null
    benefit?: StringNullableFilter<"Feat"> | string | null
    normalEffect?: StringNullableFilter<"Feat"> | string | null
    specialEffect?: StringNullableFilter<"Feat"> | string | null
    prerequisites?: StringNullableFilter<"Feat"> | string | null
    repeatable?: BoolNullableFilter<"Feat"> | boolean | null
    fighterBonus?: BoolNullableFilter<"Feat"> | boolean | null
    benefits?: FeatBenefitMapListRelationFilter
    prerequisitesMap?: FeatPrerequisiteMapListRelationFilter
  }

  export type FeatOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    typeId?: SortOrder
    description?: SortOrderInput | SortOrder
    benefit?: SortOrderInput | SortOrder
    normalEffect?: SortOrderInput | SortOrder
    specialEffect?: SortOrderInput | SortOrder
    prerequisites?: SortOrderInput | SortOrder
    repeatable?: SortOrderInput | SortOrder
    fighterBonus?: SortOrderInput | SortOrder
    benefits?: FeatBenefitMapOrderByRelationAggregateInput
    prerequisitesMap?: FeatPrerequisiteMapOrderByRelationAggregateInput
    _relevance?: FeatOrderByRelevanceInput
  }

  export type FeatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeatWhereInput | FeatWhereInput[]
    OR?: FeatWhereInput[]
    NOT?: FeatWhereInput | FeatWhereInput[]
    name?: StringFilter<"Feat"> | string
    typeId?: IntFilter<"Feat"> | number
    description?: StringNullableFilter<"Feat"> | string | null
    benefit?: StringNullableFilter<"Feat"> | string | null
    normalEffect?: StringNullableFilter<"Feat"> | string | null
    specialEffect?: StringNullableFilter<"Feat"> | string | null
    prerequisites?: StringNullableFilter<"Feat"> | string | null
    repeatable?: BoolNullableFilter<"Feat"> | boolean | null
    fighterBonus?: BoolNullableFilter<"Feat"> | boolean | null
    benefits?: FeatBenefitMapListRelationFilter
    prerequisitesMap?: FeatPrerequisiteMapListRelationFilter
  }, "id">

  export type FeatOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    typeId?: SortOrder
    description?: SortOrderInput | SortOrder
    benefit?: SortOrderInput | SortOrder
    normalEffect?: SortOrderInput | SortOrder
    specialEffect?: SortOrderInput | SortOrder
    prerequisites?: SortOrderInput | SortOrder
    repeatable?: SortOrderInput | SortOrder
    fighterBonus?: SortOrderInput | SortOrder
    _count?: FeatCountOrderByAggregateInput
    _avg?: FeatAvgOrderByAggregateInput
    _max?: FeatMaxOrderByAggregateInput
    _min?: FeatMinOrderByAggregateInput
    _sum?: FeatSumOrderByAggregateInput
  }

  export type FeatScalarWhereWithAggregatesInput = {
    AND?: FeatScalarWhereWithAggregatesInput | FeatScalarWhereWithAggregatesInput[]
    OR?: FeatScalarWhereWithAggregatesInput[]
    NOT?: FeatScalarWhereWithAggregatesInput | FeatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Feat"> | number
    name?: StringWithAggregatesFilter<"Feat"> | string
    typeId?: IntWithAggregatesFilter<"Feat"> | number
    description?: StringNullableWithAggregatesFilter<"Feat"> | string | null
    benefit?: StringNullableWithAggregatesFilter<"Feat"> | string | null
    normalEffect?: StringNullableWithAggregatesFilter<"Feat"> | string | null
    specialEffect?: StringNullableWithAggregatesFilter<"Feat"> | string | null
    prerequisites?: StringNullableWithAggregatesFilter<"Feat"> | string | null
    repeatable?: BoolNullableWithAggregatesFilter<"Feat"> | boolean | null
    fighterBonus?: BoolNullableWithAggregatesFilter<"Feat"> | boolean | null
  }

  export type FeatBenefitMapWhereInput = {
    AND?: FeatBenefitMapWhereInput | FeatBenefitMapWhereInput[]
    OR?: FeatBenefitMapWhereInput[]
    NOT?: FeatBenefitMapWhereInput | FeatBenefitMapWhereInput[]
    featId?: IntFilter<"FeatBenefitMap"> | number
    typeId?: IntFilter<"FeatBenefitMap"> | number
    referenceId?: IntNullableFilter<"FeatBenefitMap"> | number | null
    amount?: IntNullableFilter<"FeatBenefitMap"> | number | null
    index?: IntFilter<"FeatBenefitMap"> | number
    feat?: XOR<FeatScalarRelationFilter, FeatWhereInput>
  }

  export type FeatBenefitMapOrderByWithRelationInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    index?: SortOrder
    feat?: FeatOrderByWithRelationInput
  }

  export type FeatBenefitMapWhereUniqueInput = Prisma.AtLeast<{
    featId_index?: FeatBenefitMapFeatIdIndexCompoundUniqueInput
    AND?: FeatBenefitMapWhereInput | FeatBenefitMapWhereInput[]
    OR?: FeatBenefitMapWhereInput[]
    NOT?: FeatBenefitMapWhereInput | FeatBenefitMapWhereInput[]
    featId?: IntFilter<"FeatBenefitMap"> | number
    typeId?: IntFilter<"FeatBenefitMap"> | number
    referenceId?: IntNullableFilter<"FeatBenefitMap"> | number | null
    amount?: IntNullableFilter<"FeatBenefitMap"> | number | null
    index?: IntFilter<"FeatBenefitMap"> | number
    feat?: XOR<FeatScalarRelationFilter, FeatWhereInput>
  }, "featId_index">

  export type FeatBenefitMapOrderByWithAggregationInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    index?: SortOrder
    _count?: FeatBenefitMapCountOrderByAggregateInput
    _avg?: FeatBenefitMapAvgOrderByAggregateInput
    _max?: FeatBenefitMapMaxOrderByAggregateInput
    _min?: FeatBenefitMapMinOrderByAggregateInput
    _sum?: FeatBenefitMapSumOrderByAggregateInput
  }

  export type FeatBenefitMapScalarWhereWithAggregatesInput = {
    AND?: FeatBenefitMapScalarWhereWithAggregatesInput | FeatBenefitMapScalarWhereWithAggregatesInput[]
    OR?: FeatBenefitMapScalarWhereWithAggregatesInput[]
    NOT?: FeatBenefitMapScalarWhereWithAggregatesInput | FeatBenefitMapScalarWhereWithAggregatesInput[]
    featId?: IntWithAggregatesFilter<"FeatBenefitMap"> | number
    typeId?: IntWithAggregatesFilter<"FeatBenefitMap"> | number
    referenceId?: IntNullableWithAggregatesFilter<"FeatBenefitMap"> | number | null
    amount?: IntNullableWithAggregatesFilter<"FeatBenefitMap"> | number | null
    index?: IntWithAggregatesFilter<"FeatBenefitMap"> | number
  }

  export type FeatPrerequisiteMapWhereInput = {
    AND?: FeatPrerequisiteMapWhereInput | FeatPrerequisiteMapWhereInput[]
    OR?: FeatPrerequisiteMapWhereInput[]
    NOT?: FeatPrerequisiteMapWhereInput | FeatPrerequisiteMapWhereInput[]
    featId?: IntFilter<"FeatPrerequisiteMap"> | number
    typeId?: IntFilter<"FeatPrerequisiteMap"> | number
    referenceId?: IntNullableFilter<"FeatPrerequisiteMap"> | number | null
    amount?: IntNullableFilter<"FeatPrerequisiteMap"> | number | null
    index?: IntFilter<"FeatPrerequisiteMap"> | number
    feat?: XOR<FeatScalarRelationFilter, FeatWhereInput>
  }

  export type FeatPrerequisiteMapOrderByWithRelationInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    index?: SortOrder
    feat?: FeatOrderByWithRelationInput
  }

  export type FeatPrerequisiteMapWhereUniqueInput = Prisma.AtLeast<{
    featId_index?: FeatPrerequisiteMapFeatIdIndexCompoundUniqueInput
    AND?: FeatPrerequisiteMapWhereInput | FeatPrerequisiteMapWhereInput[]
    OR?: FeatPrerequisiteMapWhereInput[]
    NOT?: FeatPrerequisiteMapWhereInput | FeatPrerequisiteMapWhereInput[]
    featId?: IntFilter<"FeatPrerequisiteMap"> | number
    typeId?: IntFilter<"FeatPrerequisiteMap"> | number
    referenceId?: IntNullableFilter<"FeatPrerequisiteMap"> | number | null
    amount?: IntNullableFilter<"FeatPrerequisiteMap"> | number | null
    index?: IntFilter<"FeatPrerequisiteMap"> | number
    feat?: XOR<FeatScalarRelationFilter, FeatWhereInput>
  }, "featId_index">

  export type FeatPrerequisiteMapOrderByWithAggregationInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    index?: SortOrder
    _count?: FeatPrerequisiteMapCountOrderByAggregateInput
    _avg?: FeatPrerequisiteMapAvgOrderByAggregateInput
    _max?: FeatPrerequisiteMapMaxOrderByAggregateInput
    _min?: FeatPrerequisiteMapMinOrderByAggregateInput
    _sum?: FeatPrerequisiteMapSumOrderByAggregateInput
  }

  export type FeatPrerequisiteMapScalarWhereWithAggregatesInput = {
    AND?: FeatPrerequisiteMapScalarWhereWithAggregatesInput | FeatPrerequisiteMapScalarWhereWithAggregatesInput[]
    OR?: FeatPrerequisiteMapScalarWhereWithAggregatesInput[]
    NOT?: FeatPrerequisiteMapScalarWhereWithAggregatesInput | FeatPrerequisiteMapScalarWhereWithAggregatesInput[]
    featId?: IntWithAggregatesFilter<"FeatPrerequisiteMap"> | number
    typeId?: IntWithAggregatesFilter<"FeatPrerequisiteMap"> | number
    referenceId?: IntNullableWithAggregatesFilter<"FeatPrerequisiteMap"> | number | null
    amount?: IntNullableWithAggregatesFilter<"FeatPrerequisiteMap"> | number | null
    index?: IntWithAggregatesFilter<"FeatPrerequisiteMap"> | number
  }

  export type RaceWhereInput = {
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    id?: IntFilter<"Race"> | number
    name?: StringFilter<"Race"> | string
    editionId?: IntNullableFilter<"Race"> | number | null
    isVisible?: BoolFilter<"Race"> | boolean
    description?: StringNullableFilter<"Race"> | string | null
    sizeId?: IntFilter<"Race"> | number
    speed?: IntFilter<"Race"> | number
    favoredClassId?: IntFilter<"Race"> | number
    abilityAdjustments?: RaceAbilityAdjustmentListRelationFilter
    languages?: RaceLanguageMapListRelationFilter
    sources?: RaceSourceMapListRelationFilter
    traits?: RaceTraitMapListRelationFilter
    UserCharacter?: UserCharacterListRelationFilter
  }

  export type RaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    editionId?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    description?: SortOrderInput | SortOrder
    sizeId?: SortOrder
    speed?: SortOrder
    favoredClassId?: SortOrder
    abilityAdjustments?: RaceAbilityAdjustmentOrderByRelationAggregateInput
    languages?: RaceLanguageMapOrderByRelationAggregateInput
    sources?: RaceSourceMapOrderByRelationAggregateInput
    traits?: RaceTraitMapOrderByRelationAggregateInput
    UserCharacter?: UserCharacterOrderByRelationAggregateInput
    _relevance?: RaceOrderByRelevanceInput
  }

  export type RaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    name?: StringFilter<"Race"> | string
    editionId?: IntNullableFilter<"Race"> | number | null
    isVisible?: BoolFilter<"Race"> | boolean
    description?: StringNullableFilter<"Race"> | string | null
    sizeId?: IntFilter<"Race"> | number
    speed?: IntFilter<"Race"> | number
    favoredClassId?: IntFilter<"Race"> | number
    abilityAdjustments?: RaceAbilityAdjustmentListRelationFilter
    languages?: RaceLanguageMapListRelationFilter
    sources?: RaceSourceMapListRelationFilter
    traits?: RaceTraitMapListRelationFilter
    UserCharacter?: UserCharacterListRelationFilter
  }, "id">

  export type RaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    editionId?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    description?: SortOrderInput | SortOrder
    sizeId?: SortOrder
    speed?: SortOrder
    favoredClassId?: SortOrder
    _count?: RaceCountOrderByAggregateInput
    _avg?: RaceAvgOrderByAggregateInput
    _max?: RaceMaxOrderByAggregateInput
    _min?: RaceMinOrderByAggregateInput
    _sum?: RaceSumOrderByAggregateInput
  }

  export type RaceScalarWhereWithAggregatesInput = {
    AND?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    OR?: RaceScalarWhereWithAggregatesInput[]
    NOT?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Race"> | number
    name?: StringWithAggregatesFilter<"Race"> | string
    editionId?: IntNullableWithAggregatesFilter<"Race"> | number | null
    isVisible?: BoolWithAggregatesFilter<"Race"> | boolean
    description?: StringNullableWithAggregatesFilter<"Race"> | string | null
    sizeId?: IntWithAggregatesFilter<"Race"> | number
    speed?: IntWithAggregatesFilter<"Race"> | number
    favoredClassId?: IntWithAggregatesFilter<"Race"> | number
  }

  export type RaceTraitWhereInput = {
    AND?: RaceTraitWhereInput | RaceTraitWhereInput[]
    OR?: RaceTraitWhereInput[]
    NOT?: RaceTraitWhereInput | RaceTraitWhereInput[]
    slug?: StringFilter<"RaceTrait"> | string
    name?: StringNullableFilter<"RaceTrait"> | string | null
    description?: StringNullableFilter<"RaceTrait"> | string | null
    hasValue?: BoolFilter<"RaceTrait"> | boolean
    raceLinks?: RaceTraitMapListRelationFilter
  }

  export type RaceTraitOrderByWithRelationInput = {
    slug?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    hasValue?: SortOrder
    raceLinks?: RaceTraitMapOrderByRelationAggregateInput
    _relevance?: RaceTraitOrderByRelevanceInput
  }

  export type RaceTraitWhereUniqueInput = Prisma.AtLeast<{
    slug?: string
    AND?: RaceTraitWhereInput | RaceTraitWhereInput[]
    OR?: RaceTraitWhereInput[]
    NOT?: RaceTraitWhereInput | RaceTraitWhereInput[]
    name?: StringNullableFilter<"RaceTrait"> | string | null
    description?: StringNullableFilter<"RaceTrait"> | string | null
    hasValue?: BoolFilter<"RaceTrait"> | boolean
    raceLinks?: RaceTraitMapListRelationFilter
  }, "slug">

  export type RaceTraitOrderByWithAggregationInput = {
    slug?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    hasValue?: SortOrder
    _count?: RaceTraitCountOrderByAggregateInput
    _max?: RaceTraitMaxOrderByAggregateInput
    _min?: RaceTraitMinOrderByAggregateInput
  }

  export type RaceTraitScalarWhereWithAggregatesInput = {
    AND?: RaceTraitScalarWhereWithAggregatesInput | RaceTraitScalarWhereWithAggregatesInput[]
    OR?: RaceTraitScalarWhereWithAggregatesInput[]
    NOT?: RaceTraitScalarWhereWithAggregatesInput | RaceTraitScalarWhereWithAggregatesInput[]
    slug?: StringWithAggregatesFilter<"RaceTrait"> | string
    name?: StringNullableWithAggregatesFilter<"RaceTrait"> | string | null
    description?: StringNullableWithAggregatesFilter<"RaceTrait"> | string | null
    hasValue?: BoolWithAggregatesFilter<"RaceTrait"> | boolean
  }

  export type RaceTraitMapWhereInput = {
    AND?: RaceTraitMapWhereInput | RaceTraitMapWhereInput[]
    OR?: RaceTraitMapWhereInput[]
    NOT?: RaceTraitMapWhereInput | RaceTraitMapWhereInput[]
    raceId?: IntFilter<"RaceTraitMap"> | number
    traitId?: StringFilter<"RaceTraitMap"> | string
    value?: StringNullableFilter<"RaceTraitMap"> | string | null
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    trait?: XOR<RaceTraitScalarRelationFilter, RaceTraitWhereInput>
  }

  export type RaceTraitMapOrderByWithRelationInput = {
    raceId?: SortOrder
    traitId?: SortOrder
    value?: SortOrderInput | SortOrder
    race?: RaceOrderByWithRelationInput
    trait?: RaceTraitOrderByWithRelationInput
    _relevance?: RaceTraitMapOrderByRelevanceInput
  }

  export type RaceTraitMapWhereUniqueInput = Prisma.AtLeast<{
    raceId_traitId?: RaceTraitMapRaceIdTraitIdCompoundUniqueInput
    AND?: RaceTraitMapWhereInput | RaceTraitMapWhereInput[]
    OR?: RaceTraitMapWhereInput[]
    NOT?: RaceTraitMapWhereInput | RaceTraitMapWhereInput[]
    raceId?: IntFilter<"RaceTraitMap"> | number
    traitId?: StringFilter<"RaceTraitMap"> | string
    value?: StringNullableFilter<"RaceTraitMap"> | string | null
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    trait?: XOR<RaceTraitScalarRelationFilter, RaceTraitWhereInput>
  }, "raceId_traitId">

  export type RaceTraitMapOrderByWithAggregationInput = {
    raceId?: SortOrder
    traitId?: SortOrder
    value?: SortOrderInput | SortOrder
    _count?: RaceTraitMapCountOrderByAggregateInput
    _avg?: RaceTraitMapAvgOrderByAggregateInput
    _max?: RaceTraitMapMaxOrderByAggregateInput
    _min?: RaceTraitMapMinOrderByAggregateInput
    _sum?: RaceTraitMapSumOrderByAggregateInput
  }

  export type RaceTraitMapScalarWhereWithAggregatesInput = {
    AND?: RaceTraitMapScalarWhereWithAggregatesInput | RaceTraitMapScalarWhereWithAggregatesInput[]
    OR?: RaceTraitMapScalarWhereWithAggregatesInput[]
    NOT?: RaceTraitMapScalarWhereWithAggregatesInput | RaceTraitMapScalarWhereWithAggregatesInput[]
    raceId?: IntWithAggregatesFilter<"RaceTraitMap"> | number
    traitId?: StringWithAggregatesFilter<"RaceTraitMap"> | string
    value?: StringNullableWithAggregatesFilter<"RaceTraitMap"> | string | null
  }

  export type RaceAbilityAdjustmentWhereInput = {
    AND?: RaceAbilityAdjustmentWhereInput | RaceAbilityAdjustmentWhereInput[]
    OR?: RaceAbilityAdjustmentWhereInput[]
    NOT?: RaceAbilityAdjustmentWhereInput | RaceAbilityAdjustmentWhereInput[]
    raceId?: IntFilter<"RaceAbilityAdjustment"> | number
    abilityId?: IntFilter<"RaceAbilityAdjustment"> | number
    value?: IntFilter<"RaceAbilityAdjustment"> | number
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
  }

  export type RaceAbilityAdjustmentOrderByWithRelationInput = {
    raceId?: SortOrder
    abilityId?: SortOrder
    value?: SortOrder
    race?: RaceOrderByWithRelationInput
  }

  export type RaceAbilityAdjustmentWhereUniqueInput = Prisma.AtLeast<{
    raceId_abilityId?: RaceAbilityAdjustmentRaceIdAbilityIdCompoundUniqueInput
    AND?: RaceAbilityAdjustmentWhereInput | RaceAbilityAdjustmentWhereInput[]
    OR?: RaceAbilityAdjustmentWhereInput[]
    NOT?: RaceAbilityAdjustmentWhereInput | RaceAbilityAdjustmentWhereInput[]
    raceId?: IntFilter<"RaceAbilityAdjustment"> | number
    abilityId?: IntFilter<"RaceAbilityAdjustment"> | number
    value?: IntFilter<"RaceAbilityAdjustment"> | number
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
  }, "raceId_abilityId">

  export type RaceAbilityAdjustmentOrderByWithAggregationInput = {
    raceId?: SortOrder
    abilityId?: SortOrder
    value?: SortOrder
    _count?: RaceAbilityAdjustmentCountOrderByAggregateInput
    _avg?: RaceAbilityAdjustmentAvgOrderByAggregateInput
    _max?: RaceAbilityAdjustmentMaxOrderByAggregateInput
    _min?: RaceAbilityAdjustmentMinOrderByAggregateInput
    _sum?: RaceAbilityAdjustmentSumOrderByAggregateInput
  }

  export type RaceAbilityAdjustmentScalarWhereWithAggregatesInput = {
    AND?: RaceAbilityAdjustmentScalarWhereWithAggregatesInput | RaceAbilityAdjustmentScalarWhereWithAggregatesInput[]
    OR?: RaceAbilityAdjustmentScalarWhereWithAggregatesInput[]
    NOT?: RaceAbilityAdjustmentScalarWhereWithAggregatesInput | RaceAbilityAdjustmentScalarWhereWithAggregatesInput[]
    raceId?: IntWithAggregatesFilter<"RaceAbilityAdjustment"> | number
    abilityId?: IntWithAggregatesFilter<"RaceAbilityAdjustment"> | number
    value?: IntWithAggregatesFilter<"RaceAbilityAdjustment"> | number
  }

  export type RaceLanguageMapWhereInput = {
    AND?: RaceLanguageMapWhereInput | RaceLanguageMapWhereInput[]
    OR?: RaceLanguageMapWhereInput[]
    NOT?: RaceLanguageMapWhereInput | RaceLanguageMapWhereInput[]
    raceId?: IntFilter<"RaceLanguageMap"> | number
    languageId?: IntFilter<"RaceLanguageMap"> | number
    isAutomatic?: BoolFilter<"RaceLanguageMap"> | boolean
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
  }

  export type RaceLanguageMapOrderByWithRelationInput = {
    raceId?: SortOrder
    languageId?: SortOrder
    isAutomatic?: SortOrder
    race?: RaceOrderByWithRelationInput
  }

  export type RaceLanguageMapWhereUniqueInput = Prisma.AtLeast<{
    raceId_languageId?: RaceLanguageMapRaceIdLanguageIdCompoundUniqueInput
    AND?: RaceLanguageMapWhereInput | RaceLanguageMapWhereInput[]
    OR?: RaceLanguageMapWhereInput[]
    NOT?: RaceLanguageMapWhereInput | RaceLanguageMapWhereInput[]
    raceId?: IntFilter<"RaceLanguageMap"> | number
    languageId?: IntFilter<"RaceLanguageMap"> | number
    isAutomatic?: BoolFilter<"RaceLanguageMap"> | boolean
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
  }, "raceId_languageId">

  export type RaceLanguageMapOrderByWithAggregationInput = {
    raceId?: SortOrder
    languageId?: SortOrder
    isAutomatic?: SortOrder
    _count?: RaceLanguageMapCountOrderByAggregateInput
    _avg?: RaceLanguageMapAvgOrderByAggregateInput
    _max?: RaceLanguageMapMaxOrderByAggregateInput
    _min?: RaceLanguageMapMinOrderByAggregateInput
    _sum?: RaceLanguageMapSumOrderByAggregateInput
  }

  export type RaceLanguageMapScalarWhereWithAggregatesInput = {
    AND?: RaceLanguageMapScalarWhereWithAggregatesInput | RaceLanguageMapScalarWhereWithAggregatesInput[]
    OR?: RaceLanguageMapScalarWhereWithAggregatesInput[]
    NOT?: RaceLanguageMapScalarWhereWithAggregatesInput | RaceLanguageMapScalarWhereWithAggregatesInput[]
    raceId?: IntWithAggregatesFilter<"RaceLanguageMap"> | number
    languageId?: IntWithAggregatesFilter<"RaceLanguageMap"> | number
    isAutomatic?: BoolWithAggregatesFilter<"RaceLanguageMap"> | boolean
  }

  export type RaceSourceMapWhereInput = {
    AND?: RaceSourceMapWhereInput | RaceSourceMapWhereInput[]
    OR?: RaceSourceMapWhereInput[]
    NOT?: RaceSourceMapWhereInput | RaceSourceMapWhereInput[]
    id?: IntFilter<"RaceSourceMap"> | number
    raceId?: IntFilter<"RaceSourceMap"> | number
    bookId?: IntFilter<"RaceSourceMap"> | number
    pageNumber?: IntNullableFilter<"RaceSourceMap"> | number | null
    sourceBookId?: IntNullableFilter<"RaceSourceMap"> | number | null
    Race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    SourceBook?: XOR<SourceBookNullableScalarRelationFilter, SourceBookWhereInput> | null
  }

  export type RaceSourceMapOrderByWithRelationInput = {
    id?: SortOrder
    raceId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrderInput | SortOrder
    sourceBookId?: SortOrderInput | SortOrder
    Race?: RaceOrderByWithRelationInput
    SourceBook?: SourceBookOrderByWithRelationInput
  }

  export type RaceSourceMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RaceSourceMapWhereInput | RaceSourceMapWhereInput[]
    OR?: RaceSourceMapWhereInput[]
    NOT?: RaceSourceMapWhereInput | RaceSourceMapWhereInput[]
    raceId?: IntFilter<"RaceSourceMap"> | number
    bookId?: IntFilter<"RaceSourceMap"> | number
    pageNumber?: IntNullableFilter<"RaceSourceMap"> | number | null
    sourceBookId?: IntNullableFilter<"RaceSourceMap"> | number | null
    Race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    SourceBook?: XOR<SourceBookNullableScalarRelationFilter, SourceBookWhereInput> | null
  }, "id">

  export type RaceSourceMapOrderByWithAggregationInput = {
    id?: SortOrder
    raceId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrderInput | SortOrder
    sourceBookId?: SortOrderInput | SortOrder
    _count?: RaceSourceMapCountOrderByAggregateInput
    _avg?: RaceSourceMapAvgOrderByAggregateInput
    _max?: RaceSourceMapMaxOrderByAggregateInput
    _min?: RaceSourceMapMinOrderByAggregateInput
    _sum?: RaceSourceMapSumOrderByAggregateInput
  }

  export type RaceSourceMapScalarWhereWithAggregatesInput = {
    AND?: RaceSourceMapScalarWhereWithAggregatesInput | RaceSourceMapScalarWhereWithAggregatesInput[]
    OR?: RaceSourceMapScalarWhereWithAggregatesInput[]
    NOT?: RaceSourceMapScalarWhereWithAggregatesInput | RaceSourceMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RaceSourceMap"> | number
    raceId?: IntWithAggregatesFilter<"RaceSourceMap"> | number
    bookId?: IntWithAggregatesFilter<"RaceSourceMap"> | number
    pageNumber?: IntNullableWithAggregatesFilter<"RaceSourceMap"> | number | null
    sourceBookId?: IntNullableWithAggregatesFilter<"RaceSourceMap"> | number | null
  }

  export type ArmorWhereInput = {
    AND?: ArmorWhereInput | ArmorWhereInput[]
    OR?: ArmorWhereInput[]
    NOT?: ArmorWhereInput | ArmorWhereInput[]
    id?: IntFilter<"Armor"> | number
    name?: StringFilter<"Armor"> | string
    description?: StringNullableFilter<"Armor"> | string | null
    category?: IntFilter<"Armor"> | number
    cost?: DecimalNullableFilter<"Armor"> | Decimal | DecimalJsLike | number | string | null
    bonus?: IntNullableFilter<"Armor"> | number | null
    dexterityCap?: IntNullableFilter<"Armor"> | number | null
    checkPenalty?: IntNullableFilter<"Armor"> | number | null
    arcaneSpellFailure?: IntNullableFilter<"Armor"> | number | null
    speedCapThirty?: IntNullableFilter<"Armor"> | number | null
    speedCapTwenty?: IntNullableFilter<"Armor"> | number | null
    weight?: IntNullableFilter<"Armor"> | number | null
  }

  export type ArmorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    cost?: SortOrderInput | SortOrder
    bonus?: SortOrderInput | SortOrder
    dexterityCap?: SortOrderInput | SortOrder
    checkPenalty?: SortOrderInput | SortOrder
    arcaneSpellFailure?: SortOrderInput | SortOrder
    speedCapThirty?: SortOrderInput | SortOrder
    speedCapTwenty?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    _relevance?: ArmorOrderByRelevanceInput
  }

  export type ArmorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ArmorWhereInput | ArmorWhereInput[]
    OR?: ArmorWhereInput[]
    NOT?: ArmorWhereInput | ArmorWhereInput[]
    name?: StringFilter<"Armor"> | string
    description?: StringNullableFilter<"Armor"> | string | null
    category?: IntFilter<"Armor"> | number
    cost?: DecimalNullableFilter<"Armor"> | Decimal | DecimalJsLike | number | string | null
    bonus?: IntNullableFilter<"Armor"> | number | null
    dexterityCap?: IntNullableFilter<"Armor"> | number | null
    checkPenalty?: IntNullableFilter<"Armor"> | number | null
    arcaneSpellFailure?: IntNullableFilter<"Armor"> | number | null
    speedCapThirty?: IntNullableFilter<"Armor"> | number | null
    speedCapTwenty?: IntNullableFilter<"Armor"> | number | null
    weight?: IntNullableFilter<"Armor"> | number | null
  }, "id">

  export type ArmorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    cost?: SortOrderInput | SortOrder
    bonus?: SortOrderInput | SortOrder
    dexterityCap?: SortOrderInput | SortOrder
    checkPenalty?: SortOrderInput | SortOrder
    arcaneSpellFailure?: SortOrderInput | SortOrder
    speedCapThirty?: SortOrderInput | SortOrder
    speedCapTwenty?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    _count?: ArmorCountOrderByAggregateInput
    _avg?: ArmorAvgOrderByAggregateInput
    _max?: ArmorMaxOrderByAggregateInput
    _min?: ArmorMinOrderByAggregateInput
    _sum?: ArmorSumOrderByAggregateInput
  }

  export type ArmorScalarWhereWithAggregatesInput = {
    AND?: ArmorScalarWhereWithAggregatesInput | ArmorScalarWhereWithAggregatesInput[]
    OR?: ArmorScalarWhereWithAggregatesInput[]
    NOT?: ArmorScalarWhereWithAggregatesInput | ArmorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Armor"> | number
    name?: StringWithAggregatesFilter<"Armor"> | string
    description?: StringNullableWithAggregatesFilter<"Armor"> | string | null
    category?: IntWithAggregatesFilter<"Armor"> | number
    cost?: DecimalNullableWithAggregatesFilter<"Armor"> | Decimal | DecimalJsLike | number | string | null
    bonus?: IntNullableWithAggregatesFilter<"Armor"> | number | null
    dexterityCap?: IntNullableWithAggregatesFilter<"Armor"> | number | null
    checkPenalty?: IntNullableWithAggregatesFilter<"Armor"> | number | null
    arcaneSpellFailure?: IntNullableWithAggregatesFilter<"Armor"> | number | null
    speedCapThirty?: IntNullableWithAggregatesFilter<"Armor"> | number | null
    speedCapTwenty?: IntNullableWithAggregatesFilter<"Armor"> | number | null
    weight?: IntNullableWithAggregatesFilter<"Armor"> | number | null
  }

  export type WeaponWhereInput = {
    AND?: WeaponWhereInput | WeaponWhereInput[]
    OR?: WeaponWhereInput[]
    NOT?: WeaponWhereInput | WeaponWhereInput[]
    id?: IntFilter<"Weapon"> | number
    name?: StringFilter<"Weapon"> | string
    description?: StringNullableFilter<"Weapon"> | string | null
    category?: IntFilter<"Weapon"> | number
    cost?: DecimalNullableFilter<"Weapon"> | Decimal | DecimalJsLike | number | string | null
    damageSmall?: StringNullableFilter<"Weapon"> | string | null
    damageMedium?: StringNullableFilter<"Weapon"> | string | null
    critical?: StringNullableFilter<"Weapon"> | string | null
    range?: StringNullableFilter<"Weapon"> | string | null
    weight?: DecimalNullableFilter<"Weapon"> | Decimal | DecimalJsLike | number | string | null
    damageTypeId?: IntNullableFilter<"Weapon"> | number | null
  }

  export type WeaponOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    cost?: SortOrderInput | SortOrder
    damageSmall?: SortOrderInput | SortOrder
    damageMedium?: SortOrderInput | SortOrder
    critical?: SortOrderInput | SortOrder
    range?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    damageTypeId?: SortOrderInput | SortOrder
    _relevance?: WeaponOrderByRelevanceInput
  }

  export type WeaponWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WeaponWhereInput | WeaponWhereInput[]
    OR?: WeaponWhereInput[]
    NOT?: WeaponWhereInput | WeaponWhereInput[]
    name?: StringFilter<"Weapon"> | string
    description?: StringNullableFilter<"Weapon"> | string | null
    category?: IntFilter<"Weapon"> | number
    cost?: DecimalNullableFilter<"Weapon"> | Decimal | DecimalJsLike | number | string | null
    damageSmall?: StringNullableFilter<"Weapon"> | string | null
    damageMedium?: StringNullableFilter<"Weapon"> | string | null
    critical?: StringNullableFilter<"Weapon"> | string | null
    range?: StringNullableFilter<"Weapon"> | string | null
    weight?: DecimalNullableFilter<"Weapon"> | Decimal | DecimalJsLike | number | string | null
    damageTypeId?: IntNullableFilter<"Weapon"> | number | null
  }, "id">

  export type WeaponOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    cost?: SortOrderInput | SortOrder
    damageSmall?: SortOrderInput | SortOrder
    damageMedium?: SortOrderInput | SortOrder
    critical?: SortOrderInput | SortOrder
    range?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    damageTypeId?: SortOrderInput | SortOrder
    _count?: WeaponCountOrderByAggregateInput
    _avg?: WeaponAvgOrderByAggregateInput
    _max?: WeaponMaxOrderByAggregateInput
    _min?: WeaponMinOrderByAggregateInput
    _sum?: WeaponSumOrderByAggregateInput
  }

  export type WeaponScalarWhereWithAggregatesInput = {
    AND?: WeaponScalarWhereWithAggregatesInput | WeaponScalarWhereWithAggregatesInput[]
    OR?: WeaponScalarWhereWithAggregatesInput[]
    NOT?: WeaponScalarWhereWithAggregatesInput | WeaponScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Weapon"> | number
    name?: StringWithAggregatesFilter<"Weapon"> | string
    description?: StringNullableWithAggregatesFilter<"Weapon"> | string | null
    category?: IntWithAggregatesFilter<"Weapon"> | number
    cost?: DecimalNullableWithAggregatesFilter<"Weapon"> | Decimal | DecimalJsLike | number | string | null
    damageSmall?: StringNullableWithAggregatesFilter<"Weapon"> | string | null
    damageMedium?: StringNullableWithAggregatesFilter<"Weapon"> | string | null
    critical?: StringNullableWithAggregatesFilter<"Weapon"> | string | null
    range?: StringNullableWithAggregatesFilter<"Weapon"> | string | null
    weight?: DecimalNullableWithAggregatesFilter<"Weapon"> | Decimal | DecimalJsLike | number | string | null
    damageTypeId?: IntNullableWithAggregatesFilter<"Weapon"> | number | null
  }

  export type SourceBookWhereInput = {
    AND?: SourceBookWhereInput | SourceBookWhereInput[]
    OR?: SourceBookWhereInput[]
    NOT?: SourceBookWhereInput | SourceBookWhereInput[]
    id?: IntFilter<"SourceBook"> | number
    name?: StringFilter<"SourceBook"> | string
    abbreviation?: StringFilter<"SourceBook"> | string
    releaseDate?: DateTimeNullableFilter<"SourceBook"> | Date | string | null
    editionId?: IntNullableFilter<"SourceBook"> | number | null
    description?: StringNullableFilter<"SourceBook"> | string | null
    isVisible?: BoolFilter<"SourceBook"> | boolean
    classes?: ClassSourceMapListRelationFilter
    races?: RaceSourceMapListRelationFilter
    spells?: SpellSourceMapListRelationFilter
  }

  export type SourceBookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    releaseDate?: SortOrderInput | SortOrder
    editionId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    classes?: ClassSourceMapOrderByRelationAggregateInput
    races?: RaceSourceMapOrderByRelationAggregateInput
    spells?: SpellSourceMapOrderByRelationAggregateInput
    _relevance?: SourceBookOrderByRelevanceInput
  }

  export type SourceBookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SourceBookWhereInput | SourceBookWhereInput[]
    OR?: SourceBookWhereInput[]
    NOT?: SourceBookWhereInput | SourceBookWhereInput[]
    name?: StringFilter<"SourceBook"> | string
    abbreviation?: StringFilter<"SourceBook"> | string
    releaseDate?: DateTimeNullableFilter<"SourceBook"> | Date | string | null
    editionId?: IntNullableFilter<"SourceBook"> | number | null
    description?: StringNullableFilter<"SourceBook"> | string | null
    isVisible?: BoolFilter<"SourceBook"> | boolean
    classes?: ClassSourceMapListRelationFilter
    races?: RaceSourceMapListRelationFilter
    spells?: SpellSourceMapListRelationFilter
  }, "id">

  export type SourceBookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    releaseDate?: SortOrderInput | SortOrder
    editionId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    _count?: SourceBookCountOrderByAggregateInput
    _avg?: SourceBookAvgOrderByAggregateInput
    _max?: SourceBookMaxOrderByAggregateInput
    _min?: SourceBookMinOrderByAggregateInput
    _sum?: SourceBookSumOrderByAggregateInput
  }

  export type SourceBookScalarWhereWithAggregatesInput = {
    AND?: SourceBookScalarWhereWithAggregatesInput | SourceBookScalarWhereWithAggregatesInput[]
    OR?: SourceBookScalarWhereWithAggregatesInput[]
    NOT?: SourceBookScalarWhereWithAggregatesInput | SourceBookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SourceBook"> | number
    name?: StringWithAggregatesFilter<"SourceBook"> | string
    abbreviation?: StringWithAggregatesFilter<"SourceBook"> | string
    releaseDate?: DateTimeNullableWithAggregatesFilter<"SourceBook"> | Date | string | null
    editionId?: IntNullableWithAggregatesFilter<"SourceBook"> | number | null
    description?: StringNullableWithAggregatesFilter<"SourceBook"> | string | null
    isVisible?: BoolWithAggregatesFilter<"SourceBook"> | boolean
  }

  export type ReferenceTableWhereInput = {
    AND?: ReferenceTableWhereInput | ReferenceTableWhereInput[]
    OR?: ReferenceTableWhereInput[]
    NOT?: ReferenceTableWhereInput | ReferenceTableWhereInput[]
    slug?: StringFilter<"ReferenceTable"> | string
    name?: StringFilter<"ReferenceTable"> | string
    description?: StringNullableFilter<"ReferenceTable"> | string | null
    columns?: ReferenceTableColumnListRelationFilter
    rows?: ReferenceTableRowListRelationFilter
  }

  export type ReferenceTableOrderByWithRelationInput = {
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    columns?: ReferenceTableColumnOrderByRelationAggregateInput
    rows?: ReferenceTableRowOrderByRelationAggregateInput
    _relevance?: ReferenceTableOrderByRelevanceInput
  }

  export type ReferenceTableWhereUniqueInput = Prisma.AtLeast<{
    slug?: string
    AND?: ReferenceTableWhereInput | ReferenceTableWhereInput[]
    OR?: ReferenceTableWhereInput[]
    NOT?: ReferenceTableWhereInput | ReferenceTableWhereInput[]
    name?: StringFilter<"ReferenceTable"> | string
    description?: StringNullableFilter<"ReferenceTable"> | string | null
    columns?: ReferenceTableColumnListRelationFilter
    rows?: ReferenceTableRowListRelationFilter
  }, "slug">

  export type ReferenceTableOrderByWithAggregationInput = {
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ReferenceTableCountOrderByAggregateInput
    _max?: ReferenceTableMaxOrderByAggregateInput
    _min?: ReferenceTableMinOrderByAggregateInput
  }

  export type ReferenceTableScalarWhereWithAggregatesInput = {
    AND?: ReferenceTableScalarWhereWithAggregatesInput | ReferenceTableScalarWhereWithAggregatesInput[]
    OR?: ReferenceTableScalarWhereWithAggregatesInput[]
    NOT?: ReferenceTableScalarWhereWithAggregatesInput | ReferenceTableScalarWhereWithAggregatesInput[]
    slug?: StringWithAggregatesFilter<"ReferenceTable"> | string
    name?: StringWithAggregatesFilter<"ReferenceTable"> | string
    description?: StringNullableWithAggregatesFilter<"ReferenceTable"> | string | null
  }

  export type ReferenceTableColumnWhereInput = {
    AND?: ReferenceTableColumnWhereInput | ReferenceTableColumnWhereInput[]
    OR?: ReferenceTableColumnWhereInput[]
    NOT?: ReferenceTableColumnWhereInput | ReferenceTableColumnWhereInput[]
    id?: IntFilter<"ReferenceTableColumn"> | number
    tableSlug?: StringFilter<"ReferenceTableColumn"> | string
    columnIndex?: IntFilter<"ReferenceTableColumn"> | number
    header?: StringFilter<"ReferenceTableColumn"> | string
    span?: IntNullableFilter<"ReferenceTableColumn"> | number | null
    alignment?: StringNullableFilter<"ReferenceTableColumn"> | string | null
    cells?: ReferenceTableCellListRelationFilter
    table?: XOR<ReferenceTableScalarRelationFilter, ReferenceTableWhereInput>
  }

  export type ReferenceTableColumnOrderByWithRelationInput = {
    id?: SortOrder
    tableSlug?: SortOrder
    columnIndex?: SortOrder
    header?: SortOrder
    span?: SortOrderInput | SortOrder
    alignment?: SortOrderInput | SortOrder
    cells?: ReferenceTableCellOrderByRelationAggregateInput
    table?: ReferenceTableOrderByWithRelationInput
    _relevance?: ReferenceTableColumnOrderByRelevanceInput
  }

  export type ReferenceTableColumnWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReferenceTableColumnWhereInput | ReferenceTableColumnWhereInput[]
    OR?: ReferenceTableColumnWhereInput[]
    NOT?: ReferenceTableColumnWhereInput | ReferenceTableColumnWhereInput[]
    tableSlug?: StringFilter<"ReferenceTableColumn"> | string
    columnIndex?: IntFilter<"ReferenceTableColumn"> | number
    header?: StringFilter<"ReferenceTableColumn"> | string
    span?: IntNullableFilter<"ReferenceTableColumn"> | number | null
    alignment?: StringNullableFilter<"ReferenceTableColumn"> | string | null
    cells?: ReferenceTableCellListRelationFilter
    table?: XOR<ReferenceTableScalarRelationFilter, ReferenceTableWhereInput>
  }, "id">

  export type ReferenceTableColumnOrderByWithAggregationInput = {
    id?: SortOrder
    tableSlug?: SortOrder
    columnIndex?: SortOrder
    header?: SortOrder
    span?: SortOrderInput | SortOrder
    alignment?: SortOrderInput | SortOrder
    _count?: ReferenceTableColumnCountOrderByAggregateInput
    _avg?: ReferenceTableColumnAvgOrderByAggregateInput
    _max?: ReferenceTableColumnMaxOrderByAggregateInput
    _min?: ReferenceTableColumnMinOrderByAggregateInput
    _sum?: ReferenceTableColumnSumOrderByAggregateInput
  }

  export type ReferenceTableColumnScalarWhereWithAggregatesInput = {
    AND?: ReferenceTableColumnScalarWhereWithAggregatesInput | ReferenceTableColumnScalarWhereWithAggregatesInput[]
    OR?: ReferenceTableColumnScalarWhereWithAggregatesInput[]
    NOT?: ReferenceTableColumnScalarWhereWithAggregatesInput | ReferenceTableColumnScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReferenceTableColumn"> | number
    tableSlug?: StringWithAggregatesFilter<"ReferenceTableColumn"> | string
    columnIndex?: IntWithAggregatesFilter<"ReferenceTableColumn"> | number
    header?: StringWithAggregatesFilter<"ReferenceTableColumn"> | string
    span?: IntNullableWithAggregatesFilter<"ReferenceTableColumn"> | number | null
    alignment?: StringNullableWithAggregatesFilter<"ReferenceTableColumn"> | string | null
  }

  export type ReferenceTableRowWhereInput = {
    AND?: ReferenceTableRowWhereInput | ReferenceTableRowWhereInput[]
    OR?: ReferenceTableRowWhereInput[]
    NOT?: ReferenceTableRowWhereInput | ReferenceTableRowWhereInput[]
    id?: IntFilter<"ReferenceTableRow"> | number
    tableSlug?: StringFilter<"ReferenceTableRow"> | string
    rowIndex?: IntFilter<"ReferenceTableRow"> | number
    label?: StringNullableFilter<"ReferenceTableRow"> | string | null
    cells?: ReferenceTableCellListRelationFilter
    table?: XOR<ReferenceTableScalarRelationFilter, ReferenceTableWhereInput>
  }

  export type ReferenceTableRowOrderByWithRelationInput = {
    id?: SortOrder
    tableSlug?: SortOrder
    rowIndex?: SortOrder
    label?: SortOrderInput | SortOrder
    cells?: ReferenceTableCellOrderByRelationAggregateInput
    table?: ReferenceTableOrderByWithRelationInput
    _relevance?: ReferenceTableRowOrderByRelevanceInput
  }

  export type ReferenceTableRowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReferenceTableRowWhereInput | ReferenceTableRowWhereInput[]
    OR?: ReferenceTableRowWhereInput[]
    NOT?: ReferenceTableRowWhereInput | ReferenceTableRowWhereInput[]
    tableSlug?: StringFilter<"ReferenceTableRow"> | string
    rowIndex?: IntFilter<"ReferenceTableRow"> | number
    label?: StringNullableFilter<"ReferenceTableRow"> | string | null
    cells?: ReferenceTableCellListRelationFilter
    table?: XOR<ReferenceTableScalarRelationFilter, ReferenceTableWhereInput>
  }, "id">

  export type ReferenceTableRowOrderByWithAggregationInput = {
    id?: SortOrder
    tableSlug?: SortOrder
    rowIndex?: SortOrder
    label?: SortOrderInput | SortOrder
    _count?: ReferenceTableRowCountOrderByAggregateInput
    _avg?: ReferenceTableRowAvgOrderByAggregateInput
    _max?: ReferenceTableRowMaxOrderByAggregateInput
    _min?: ReferenceTableRowMinOrderByAggregateInput
    _sum?: ReferenceTableRowSumOrderByAggregateInput
  }

  export type ReferenceTableRowScalarWhereWithAggregatesInput = {
    AND?: ReferenceTableRowScalarWhereWithAggregatesInput | ReferenceTableRowScalarWhereWithAggregatesInput[]
    OR?: ReferenceTableRowScalarWhereWithAggregatesInput[]
    NOT?: ReferenceTableRowScalarWhereWithAggregatesInput | ReferenceTableRowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReferenceTableRow"> | number
    tableSlug?: StringWithAggregatesFilter<"ReferenceTableRow"> | string
    rowIndex?: IntWithAggregatesFilter<"ReferenceTableRow"> | number
    label?: StringNullableWithAggregatesFilter<"ReferenceTableRow"> | string | null
  }

  export type ReferenceTableCellWhereInput = {
    AND?: ReferenceTableCellWhereInput | ReferenceTableCellWhereInput[]
    OR?: ReferenceTableCellWhereInput[]
    NOT?: ReferenceTableCellWhereInput | ReferenceTableCellWhereInput[]
    id?: IntFilter<"ReferenceTableCell"> | number
    rowId?: IntFilter<"ReferenceTableCell"> | number
    columnId?: IntFilter<"ReferenceTableCell"> | number
    value?: StringNullableFilter<"ReferenceTableCell"> | string | null
    colSpan?: IntNullableFilter<"ReferenceTableCell"> | number | null
    rowSpan?: IntNullableFilter<"ReferenceTableCell"> | number | null
    column?: XOR<ReferenceTableColumnScalarRelationFilter, ReferenceTableColumnWhereInput>
    row?: XOR<ReferenceTableRowScalarRelationFilter, ReferenceTableRowWhereInput>
  }

  export type ReferenceTableCellOrderByWithRelationInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    value?: SortOrderInput | SortOrder
    colSpan?: SortOrderInput | SortOrder
    rowSpan?: SortOrderInput | SortOrder
    column?: ReferenceTableColumnOrderByWithRelationInput
    row?: ReferenceTableRowOrderByWithRelationInput
    _relevance?: ReferenceTableCellOrderByRelevanceInput
  }

  export type ReferenceTableCellWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReferenceTableCellWhereInput | ReferenceTableCellWhereInput[]
    OR?: ReferenceTableCellWhereInput[]
    NOT?: ReferenceTableCellWhereInput | ReferenceTableCellWhereInput[]
    rowId?: IntFilter<"ReferenceTableCell"> | number
    columnId?: IntFilter<"ReferenceTableCell"> | number
    value?: StringNullableFilter<"ReferenceTableCell"> | string | null
    colSpan?: IntNullableFilter<"ReferenceTableCell"> | number | null
    rowSpan?: IntNullableFilter<"ReferenceTableCell"> | number | null
    column?: XOR<ReferenceTableColumnScalarRelationFilter, ReferenceTableColumnWhereInput>
    row?: XOR<ReferenceTableRowScalarRelationFilter, ReferenceTableRowWhereInput>
  }, "id">

  export type ReferenceTableCellOrderByWithAggregationInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    value?: SortOrderInput | SortOrder
    colSpan?: SortOrderInput | SortOrder
    rowSpan?: SortOrderInput | SortOrder
    _count?: ReferenceTableCellCountOrderByAggregateInput
    _avg?: ReferenceTableCellAvgOrderByAggregateInput
    _max?: ReferenceTableCellMaxOrderByAggregateInput
    _min?: ReferenceTableCellMinOrderByAggregateInput
    _sum?: ReferenceTableCellSumOrderByAggregateInput
  }

  export type ReferenceTableCellScalarWhereWithAggregatesInput = {
    AND?: ReferenceTableCellScalarWhereWithAggregatesInput | ReferenceTableCellScalarWhereWithAggregatesInput[]
    OR?: ReferenceTableCellScalarWhereWithAggregatesInput[]
    NOT?: ReferenceTableCellScalarWhereWithAggregatesInput | ReferenceTableCellScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReferenceTableCell"> | number
    rowId?: IntWithAggregatesFilter<"ReferenceTableCell"> | number
    columnId?: IntWithAggregatesFilter<"ReferenceTableCell"> | number
    value?: StringNullableWithAggregatesFilter<"ReferenceTableCell"> | string | null
    colSpan?: IntNullableWithAggregatesFilter<"ReferenceTableCell"> | number | null
    rowSpan?: IntNullableWithAggregatesFilter<"ReferenceTableCell"> | number | null
  }

  export type UserCharacterWhereInput = {
    AND?: UserCharacterWhereInput | UserCharacterWhereInput[]
    OR?: UserCharacterWhereInput[]
    NOT?: UserCharacterWhereInput | UserCharacterWhereInput[]
    id?: IntFilter<"UserCharacter"> | number
    userId?: IntFilter<"UserCharacter"> | number
    name?: StringFilter<"UserCharacter"> | string
    raceId?: IntFilter<"UserCharacter"> | number
    alignmentId?: IntFilter<"UserCharacter"> | number
    age?: IntNullableFilter<"UserCharacter"> | number | null
    height?: IntNullableFilter<"UserCharacter"> | number | null
    weight?: IntNullableFilter<"UserCharacter"> | number | null
    eyes?: StringNullableFilter<"UserCharacter"> | string | null
    hair?: StringNullableFilter<"UserCharacter"> | string | null
    gender?: StringNullableFilter<"UserCharacter"> | string | null
    notes?: StringNullableFilter<"UserCharacter"> | string | null
    attributes?: UserCharacterAttributeListRelationFilter
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserCharacterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    raceId?: SortOrder
    alignmentId?: SortOrder
    age?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    eyes?: SortOrderInput | SortOrder
    hair?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    attributes?: UserCharacterAttributeOrderByRelationAggregateInput
    race?: RaceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: UserCharacterOrderByRelevanceInput
  }

  export type UserCharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserCharacterWhereInput | UserCharacterWhereInput[]
    OR?: UserCharacterWhereInput[]
    NOT?: UserCharacterWhereInput | UserCharacterWhereInput[]
    userId?: IntFilter<"UserCharacter"> | number
    name?: StringFilter<"UserCharacter"> | string
    raceId?: IntFilter<"UserCharacter"> | number
    alignmentId?: IntFilter<"UserCharacter"> | number
    age?: IntNullableFilter<"UserCharacter"> | number | null
    height?: IntNullableFilter<"UserCharacter"> | number | null
    weight?: IntNullableFilter<"UserCharacter"> | number | null
    eyes?: StringNullableFilter<"UserCharacter"> | string | null
    hair?: StringNullableFilter<"UserCharacter"> | string | null
    gender?: StringNullableFilter<"UserCharacter"> | string | null
    notes?: StringNullableFilter<"UserCharacter"> | string | null
    attributes?: UserCharacterAttributeListRelationFilter
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserCharacterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    raceId?: SortOrder
    alignmentId?: SortOrder
    age?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    eyes?: SortOrderInput | SortOrder
    hair?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: UserCharacterCountOrderByAggregateInput
    _avg?: UserCharacterAvgOrderByAggregateInput
    _max?: UserCharacterMaxOrderByAggregateInput
    _min?: UserCharacterMinOrderByAggregateInput
    _sum?: UserCharacterSumOrderByAggregateInput
  }

  export type UserCharacterScalarWhereWithAggregatesInput = {
    AND?: UserCharacterScalarWhereWithAggregatesInput | UserCharacterScalarWhereWithAggregatesInput[]
    OR?: UserCharacterScalarWhereWithAggregatesInput[]
    NOT?: UserCharacterScalarWhereWithAggregatesInput | UserCharacterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserCharacter"> | number
    userId?: IntWithAggregatesFilter<"UserCharacter"> | number
    name?: StringWithAggregatesFilter<"UserCharacter"> | string
    raceId?: IntWithAggregatesFilter<"UserCharacter"> | number
    alignmentId?: IntWithAggregatesFilter<"UserCharacter"> | number
    age?: IntNullableWithAggregatesFilter<"UserCharacter"> | number | null
    height?: IntNullableWithAggregatesFilter<"UserCharacter"> | number | null
    weight?: IntNullableWithAggregatesFilter<"UserCharacter"> | number | null
    eyes?: StringNullableWithAggregatesFilter<"UserCharacter"> | string | null
    hair?: StringNullableWithAggregatesFilter<"UserCharacter"> | string | null
    gender?: StringNullableWithAggregatesFilter<"UserCharacter"> | string | null
    notes?: StringNullableWithAggregatesFilter<"UserCharacter"> | string | null
  }

  export type UserCharacterAttributeWhereInput = {
    AND?: UserCharacterAttributeWhereInput | UserCharacterAttributeWhereInput[]
    OR?: UserCharacterAttributeWhereInput[]
    NOT?: UserCharacterAttributeWhereInput | UserCharacterAttributeWhereInput[]
    id?: IntFilter<"UserCharacterAttribute"> | number
    characterId?: IntFilter<"UserCharacterAttribute"> | number
    attributeId?: IntFilter<"UserCharacterAttribute"> | number
    value?: IntFilter<"UserCharacterAttribute"> | number
    character?: XOR<UserCharacterScalarRelationFilter, UserCharacterWhereInput>
  }

  export type UserCharacterAttributeOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
    character?: UserCharacterOrderByWithRelationInput
  }

  export type UserCharacterAttributeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserCharacterAttributeWhereInput | UserCharacterAttributeWhereInput[]
    OR?: UserCharacterAttributeWhereInput[]
    NOT?: UserCharacterAttributeWhereInput | UserCharacterAttributeWhereInput[]
    characterId?: IntFilter<"UserCharacterAttribute"> | number
    attributeId?: IntFilter<"UserCharacterAttribute"> | number
    value?: IntFilter<"UserCharacterAttribute"> | number
    character?: XOR<UserCharacterScalarRelationFilter, UserCharacterWhereInput>
  }, "id">

  export type UserCharacterAttributeOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
    _count?: UserCharacterAttributeCountOrderByAggregateInput
    _avg?: UserCharacterAttributeAvgOrderByAggregateInput
    _max?: UserCharacterAttributeMaxOrderByAggregateInput
    _min?: UserCharacterAttributeMinOrderByAggregateInput
    _sum?: UserCharacterAttributeSumOrderByAggregateInput
  }

  export type UserCharacterAttributeScalarWhereWithAggregatesInput = {
    AND?: UserCharacterAttributeScalarWhereWithAggregatesInput | UserCharacterAttributeScalarWhereWithAggregatesInput[]
    OR?: UserCharacterAttributeScalarWhereWithAggregatesInput[]
    NOT?: UserCharacterAttributeScalarWhereWithAggregatesInput | UserCharacterAttributeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserCharacterAttribute"> | number
    characterId?: IntWithAggregatesFilter<"UserCharacterAttribute"> | number
    attributeId?: IntWithAggregatesFilter<"UserCharacterAttribute"> | number
    value?: IntWithAggregatesFilter<"UserCharacterAttribute"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    isAdmin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    preferredEditionId?: IntNullableFilter<"User"> | number | null
    characters?: UserCharacterListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferredEditionId?: SortOrderInput | SortOrder
    characters?: UserCharacterOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    isAdmin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    preferredEditionId?: IntNullableFilter<"User"> | number | null
    characters?: UserCharacterListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferredEditionId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    preferredEditionId?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type ClassCreateInput = {
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureCreateNestedManyWithoutClassInput
    attributes?: ClassLevelAttributeCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: number
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureUncheckedCreateNestedManyWithoutClassInput
    attributes?: ClassLevelAttributeUncheckedCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelUncheckedCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapUncheckedCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapUncheckedCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUpdateManyWithoutClassNestedInput
    attributes?: ClassLevelAttributeUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUncheckedUpdateManyWithoutClassNestedInput
    attributes?: ClassLevelAttributeUncheckedUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUncheckedUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUncheckedUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUncheckedUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: number
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
  }

  export type ClassUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassFeatureCreateInput = {
    name: string
    description?: string | null
    level?: number | null
    class: ClassCreateNestedOneWithoutFeaturesInput
  }

  export type ClassFeatureUncheckedCreateInput = {
    id?: number
    classId: number
    name: string
    description?: string | null
    level?: number | null
  }

  export type ClassFeatureUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    class?: ClassUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type ClassFeatureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassFeatureCreateManyInput = {
    id?: number
    classId: number
    name: string
    description?: string | null
    level?: number | null
  }

  export type ClassFeatureUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassFeatureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassSpellLevelCreateInput = {
    spellLevel: number
    class: ClassCreateNestedOneWithoutSpellProgressionInput
  }

  export type ClassSpellLevelUncheckedCreateInput = {
    id?: number
    classId: number
    spellLevel: number
  }

  export type ClassSpellLevelUpdateInput = {
    spellLevel?: IntFieldUpdateOperationsInput | number
    class?: ClassUpdateOneRequiredWithoutSpellProgressionNestedInput
  }

  export type ClassSpellLevelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    spellLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSpellLevelCreateManyInput = {
    id?: number
    classId: number
    spellLevel: number
  }

  export type ClassSpellLevelUpdateManyMutationInput = {
    spellLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSpellLevelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    spellLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ClassLevelAttributeCreateInput = {
    baseAttackBonus: number
    fortSave: number
    refSave: number
    willSave: number
    class: ClassCreateNestedOneWithoutAttributesInput
  }

  export type ClassLevelAttributeUncheckedCreateInput = {
    id?: number
    classId: number
    baseAttackBonus: number
    fortSave: number
    refSave: number
    willSave: number
  }

  export type ClassLevelAttributeUpdateInput = {
    baseAttackBonus?: IntFieldUpdateOperationsInput | number
    fortSave?: IntFieldUpdateOperationsInput | number
    refSave?: IntFieldUpdateOperationsInput | number
    willSave?: IntFieldUpdateOperationsInput | number
    class?: ClassUpdateOneRequiredWithoutAttributesNestedInput
  }

  export type ClassLevelAttributeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    baseAttackBonus?: IntFieldUpdateOperationsInput | number
    fortSave?: IntFieldUpdateOperationsInput | number
    refSave?: IntFieldUpdateOperationsInput | number
    willSave?: IntFieldUpdateOperationsInput | number
  }

  export type ClassLevelAttributeCreateManyInput = {
    id?: number
    classId: number
    baseAttackBonus: number
    fortSave: number
    refSave: number
    willSave: number
  }

  export type ClassLevelAttributeUpdateManyMutationInput = {
    baseAttackBonus?: IntFieldUpdateOperationsInput | number
    fortSave?: IntFieldUpdateOperationsInput | number
    refSave?: IntFieldUpdateOperationsInput | number
    willSave?: IntFieldUpdateOperationsInput | number
  }

  export type ClassLevelAttributeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    baseAttackBonus?: IntFieldUpdateOperationsInput | number
    fortSave?: IntFieldUpdateOperationsInput | number
    refSave?: IntFieldUpdateOperationsInput | number
    willSave?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSkillMapCreateInput = {
    Class: ClassCreateNestedOneWithoutSkillsInput
    Skill: SkillCreateNestedOneWithoutClassesInput
  }

  export type ClassSkillMapUncheckedCreateInput = {
    id?: number
    classId: number
    skillId: number
  }

  export type ClassSkillMapUpdateInput = {
    Class?: ClassUpdateOneRequiredWithoutSkillsNestedInput
    Skill?: SkillUpdateOneRequiredWithoutClassesNestedInput
  }

  export type ClassSkillMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSkillMapCreateManyInput = {
    id?: number
    classId: number
    skillId: number
  }

  export type ClassSkillMapUpdateManyMutationInput = {

  }

  export type ClassSkillMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSourceMapCreateInput = {
    bookId: number
    pageNumber?: number | null
    class: ClassCreateNestedOneWithoutSourcesInput
    SourceBook?: SourceBookCreateNestedOneWithoutClassesInput
  }

  export type ClassSourceMapUncheckedCreateInput = {
    id?: number
    classId: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type ClassSourceMapUpdateInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    class?: ClassUpdateOneRequiredWithoutSourcesNestedInput
    SourceBook?: SourceBookUpdateOneWithoutClassesNestedInput
  }

  export type ClassSourceMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassSourceMapCreateManyInput = {
    id?: number
    classId: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type ClassSourceMapUpdateManyMutationInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassSourceMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellLevelMapCreateInput = {
    level: number
    isVisible?: boolean
    spell: SpellCreateNestedOneWithoutLevelMappingInput
    class: ClassCreateNestedOneWithoutSpellLevelsInput
  }

  export type SpellLevelMapUncheckedCreateInput = {
    id?: number
    classId: number
    spellId: number
    level: number
    isVisible?: boolean
  }

  export type SpellLevelMapUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    spell?: SpellUpdateOneRequiredWithoutLevelMappingNestedInput
    class?: ClassUpdateOneRequiredWithoutSpellLevelsNestedInput
  }

  export type SpellLevelMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellLevelMapCreateManyInput = {
    id?: number
    classId: number
    spellId: number
    level: number
    isVisible?: boolean
  }

  export type SpellLevelMapUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellLevelMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellCreateInput = {
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    descriptors?: SpellDescriptorMapCreateNestedManyWithoutSpellInput
    levelMapping?: SpellLevelMapCreateNestedManyWithoutSpellInput
    schools?: SpellSchoolMapCreateNestedManyWithoutSpellInput
    sources?: SpellSourceMapCreateNestedManyWithoutSpellInput
    subschools?: SpellSubschoolMapCreateNestedManyWithoutSpellInput
  }

  export type SpellUncheckedCreateInput = {
    id?: number
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    descriptors?: SpellDescriptorMapUncheckedCreateNestedManyWithoutSpellInput
    levelMapping?: SpellLevelMapUncheckedCreateNestedManyWithoutSpellInput
    schools?: SpellSchoolMapUncheckedCreateNestedManyWithoutSpellInput
    sources?: SpellSourceMapUncheckedCreateNestedManyWithoutSpellInput
    subschools?: SpellSubschoolMapUncheckedCreateNestedManyWithoutSpellInput
  }

  export type SpellUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    descriptors?: SpellDescriptorMapUpdateManyWithoutSpellNestedInput
    levelMapping?: SpellLevelMapUpdateManyWithoutSpellNestedInput
    schools?: SpellSchoolMapUpdateManyWithoutSpellNestedInput
    sources?: SpellSourceMapUpdateManyWithoutSpellNestedInput
    subschools?: SpellSubschoolMapUpdateManyWithoutSpellNestedInput
  }

  export type SpellUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    descriptors?: SpellDescriptorMapUncheckedUpdateManyWithoutSpellNestedInput
    levelMapping?: SpellLevelMapUncheckedUpdateManyWithoutSpellNestedInput
    schools?: SpellSchoolMapUncheckedUpdateManyWithoutSpellNestedInput
    sources?: SpellSourceMapUncheckedUpdateManyWithoutSpellNestedInput
    subschools?: SpellSubschoolMapUncheckedUpdateManyWithoutSpellNestedInput
  }

  export type SpellCreateManyInput = {
    id?: number
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
  }

  export type SpellUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellDescriptorMapCreateInput = {
    descriptorId: number
    Spell: SpellCreateNestedOneWithoutDescriptorsInput
  }

  export type SpellDescriptorMapUncheckedCreateInput = {
    id?: number
    spellId: number
    descriptorId: number
  }

  export type SpellDescriptorMapUpdateInput = {
    descriptorId?: IntFieldUpdateOperationsInput | number
    Spell?: SpellUpdateOneRequiredWithoutDescriptorsNestedInput
  }

  export type SpellDescriptorMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    descriptorId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellDescriptorMapCreateManyInput = {
    id?: number
    spellId: number
    descriptorId: number
  }

  export type SpellDescriptorMapUpdateManyMutationInput = {
    descriptorId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellDescriptorMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    descriptorId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellSchoolMapCreateInput = {
    schoolId: number
    Spell: SpellCreateNestedOneWithoutSchoolsInput
  }

  export type SpellSchoolMapUncheckedCreateInput = {
    id?: number
    spellId: number
    schoolId: number
  }

  export type SpellSchoolMapUpdateInput = {
    schoolId?: IntFieldUpdateOperationsInput | number
    Spell?: SpellUpdateOneRequiredWithoutSchoolsNestedInput
  }

  export type SpellSchoolMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellSchoolMapCreateManyInput = {
    id?: number
    spellId: number
    schoolId: number
  }

  export type SpellSchoolMapUpdateManyMutationInput = {
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellSchoolMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellSourceMapCreateInput = {
    bookId: number
    pageNumber?: number | null
    Spell: SpellCreateNestedOneWithoutSourcesInput
    SourceBook?: SourceBookCreateNestedOneWithoutSpellsInput
  }

  export type SpellSourceMapUncheckedCreateInput = {
    id?: number
    spellId: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type SpellSourceMapUpdateInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    Spell?: SpellUpdateOneRequiredWithoutSourcesNestedInput
    SourceBook?: SourceBookUpdateOneWithoutSpellsNestedInput
  }

  export type SpellSourceMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSourceMapCreateManyInput = {
    id?: number
    spellId: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type SpellSourceMapUpdateManyMutationInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSourceMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSubschoolMapCreateInput = {
    schoolId: number
    Spell: SpellCreateNestedOneWithoutSubschoolsInput
  }

  export type SpellSubschoolMapUncheckedCreateInput = {
    id?: number
    spellId: number
    schoolId: number
  }

  export type SpellSubschoolMapUpdateInput = {
    schoolId?: IntFieldUpdateOperationsInput | number
    Spell?: SpellUpdateOneRequiredWithoutSubschoolsNestedInput
  }

  export type SpellSubschoolMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellSubschoolMapCreateManyInput = {
    id?: number
    spellId: number
    schoolId: number
  }

  export type SpellSubschoolMapUpdateManyMutationInput = {
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellSubschoolMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellComponentMapCreateInput = {
    spellId: number
    componentId: number
  }

  export type SpellComponentMapUncheckedCreateInput = {
    id?: number
    spellId: number
    componentId: number
  }

  export type SpellComponentMapUpdateInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    componentId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellComponentMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    componentId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellComponentMapCreateManyInput = {
    id?: number
    spellId: number
    componentId: number
  }

  export type SpellComponentMapUpdateManyMutationInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    componentId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellComponentMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    componentId?: IntFieldUpdateOperationsInput | number
  }

  export type SkillCreateInput = {
    name: string
    abilityId?: number
    checkDescription?: string | null
    actionDescription?: string | null
    retryTypeId?: number | null
    retryDescription?: string | null
    specialNotes?: string | null
    synergyNotes?: string | null
    untrainedNotes?: string | null
    affectedByArmor?: boolean
    description?: string | null
    trainedOnly?: boolean | null
    classes?: ClassSkillMapCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: number
    name: string
    abilityId?: number
    checkDescription?: string | null
    actionDescription?: string | null
    retryTypeId?: number | null
    retryDescription?: string | null
    specialNotes?: string | null
    synergyNotes?: string | null
    untrainedNotes?: string | null
    affectedByArmor?: boolean
    description?: string | null
    trainedOnly?: boolean | null
    classes?: ClassSkillMapUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    abilityId?: IntFieldUpdateOperationsInput | number
    checkDescription?: NullableStringFieldUpdateOperationsInput | string | null
    actionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    retryTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    retryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    synergyNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untrainedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    affectedByArmor?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainedOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    classes?: ClassSkillMapUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilityId?: IntFieldUpdateOperationsInput | number
    checkDescription?: NullableStringFieldUpdateOperationsInput | string | null
    actionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    retryTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    retryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    synergyNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untrainedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    affectedByArmor?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainedOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    classes?: ClassSkillMapUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: number
    name: string
    abilityId?: number
    checkDescription?: string | null
    actionDescription?: string | null
    retryTypeId?: number | null
    retryDescription?: string | null
    specialNotes?: string | null
    synergyNotes?: string | null
    untrainedNotes?: string | null
    affectedByArmor?: boolean
    description?: string | null
    trainedOnly?: boolean | null
  }

  export type SkillUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    abilityId?: IntFieldUpdateOperationsInput | number
    checkDescription?: NullableStringFieldUpdateOperationsInput | string | null
    actionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    retryTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    retryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    synergyNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untrainedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    affectedByArmor?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainedOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilityId?: IntFieldUpdateOperationsInput | number
    checkDescription?: NullableStringFieldUpdateOperationsInput | string | null
    actionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    retryTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    retryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    synergyNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untrainedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    affectedByArmor?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainedOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FeatCreateInput = {
    name: string
    typeId: number
    description?: string | null
    benefit?: string | null
    normalEffect?: string | null
    specialEffect?: string | null
    prerequisites?: string | null
    repeatable?: boolean | null
    fighterBonus?: boolean | null
    benefits?: FeatBenefitMapCreateNestedManyWithoutFeatInput
    prerequisitesMap?: FeatPrerequisiteMapCreateNestedManyWithoutFeatInput
  }

  export type FeatUncheckedCreateInput = {
    id?: number
    name: string
    typeId: number
    description?: string | null
    benefit?: string | null
    normalEffect?: string | null
    specialEffect?: string | null
    prerequisites?: string | null
    repeatable?: boolean | null
    fighterBonus?: boolean | null
    benefits?: FeatBenefitMapUncheckedCreateNestedManyWithoutFeatInput
    prerequisitesMap?: FeatPrerequisiteMapUncheckedCreateNestedManyWithoutFeatInput
  }

  export type FeatUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    typeId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    normalEffect?: NullableStringFieldUpdateOperationsInput | string | null
    specialEffect?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    repeatable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fighterBonus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    benefits?: FeatBenefitMapUpdateManyWithoutFeatNestedInput
    prerequisitesMap?: FeatPrerequisiteMapUpdateManyWithoutFeatNestedInput
  }

  export type FeatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    typeId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    normalEffect?: NullableStringFieldUpdateOperationsInput | string | null
    specialEffect?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    repeatable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fighterBonus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    benefits?: FeatBenefitMapUncheckedUpdateManyWithoutFeatNestedInput
    prerequisitesMap?: FeatPrerequisiteMapUncheckedUpdateManyWithoutFeatNestedInput
  }

  export type FeatCreateManyInput = {
    id?: number
    name: string
    typeId: number
    description?: string | null
    benefit?: string | null
    normalEffect?: string | null
    specialEffect?: string | null
    prerequisites?: string | null
    repeatable?: boolean | null
    fighterBonus?: boolean | null
  }

  export type FeatUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    typeId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    normalEffect?: NullableStringFieldUpdateOperationsInput | string | null
    specialEffect?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    repeatable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fighterBonus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FeatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    typeId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    normalEffect?: NullableStringFieldUpdateOperationsInput | string | null
    specialEffect?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    repeatable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fighterBonus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FeatBenefitMapCreateInput = {
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
    feat: FeatCreateNestedOneWithoutBenefitsInput
  }

  export type FeatBenefitMapUncheckedCreateInput = {
    featId: number
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
  }

  export type FeatBenefitMapUpdateInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
    feat?: FeatUpdateOneRequiredWithoutBenefitsNestedInput
  }

  export type FeatBenefitMapUncheckedUpdateInput = {
    featId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type FeatBenefitMapCreateManyInput = {
    featId: number
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
  }

  export type FeatBenefitMapUpdateManyMutationInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type FeatBenefitMapUncheckedUpdateManyInput = {
    featId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type FeatPrerequisiteMapCreateInput = {
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
    feat: FeatCreateNestedOneWithoutPrerequisitesMapInput
  }

  export type FeatPrerequisiteMapUncheckedCreateInput = {
    featId: number
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
  }

  export type FeatPrerequisiteMapUpdateInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
    feat?: FeatUpdateOneRequiredWithoutPrerequisitesMapNestedInput
  }

  export type FeatPrerequisiteMapUncheckedUpdateInput = {
    featId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type FeatPrerequisiteMapCreateManyInput = {
    featId: number
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
  }

  export type FeatPrerequisiteMapUpdateManyMutationInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type FeatPrerequisiteMapUncheckedUpdateManyInput = {
    featId?: IntFieldUpdateOperationsInput | number
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type RaceCreateInput = {
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    abilityAdjustments?: RaceAbilityAdjustmentCreateNestedManyWithoutRaceInput
    languages?: RaceLanguageMapCreateNestedManyWithoutRaceInput
    sources?: RaceSourceMapCreateNestedManyWithoutRaceInput
    traits?: RaceTraitMapCreateNestedManyWithoutRaceInput
    UserCharacter?: UserCharacterCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateInput = {
    id?: number
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    abilityAdjustments?: RaceAbilityAdjustmentUncheckedCreateNestedManyWithoutRaceInput
    languages?: RaceLanguageMapUncheckedCreateNestedManyWithoutRaceInput
    sources?: RaceSourceMapUncheckedCreateNestedManyWithoutRaceInput
    traits?: RaceTraitMapUncheckedCreateNestedManyWithoutRaceInput
    UserCharacter?: UserCharacterUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    abilityAdjustments?: RaceAbilityAdjustmentUpdateManyWithoutRaceNestedInput
    languages?: RaceLanguageMapUpdateManyWithoutRaceNestedInput
    sources?: RaceSourceMapUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitMapUpdateManyWithoutRaceNestedInput
    UserCharacter?: UserCharacterUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    abilityAdjustments?: RaceAbilityAdjustmentUncheckedUpdateManyWithoutRaceNestedInput
    languages?: RaceLanguageMapUncheckedUpdateManyWithoutRaceNestedInput
    sources?: RaceSourceMapUncheckedUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitMapUncheckedUpdateManyWithoutRaceNestedInput
    UserCharacter?: UserCharacterUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceCreateManyInput = {
    id?: number
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
  }

  export type RaceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceTraitCreateInput = {
    slug: string
    name?: string | null
    description?: string | null
    hasValue?: boolean
    raceLinks?: RaceTraitMapCreateNestedManyWithoutTraitInput
  }

  export type RaceTraitUncheckedCreateInput = {
    slug: string
    name?: string | null
    description?: string | null
    hasValue?: boolean
    raceLinks?: RaceTraitMapUncheckedCreateNestedManyWithoutTraitInput
  }

  export type RaceTraitUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasValue?: BoolFieldUpdateOperationsInput | boolean
    raceLinks?: RaceTraitMapUpdateManyWithoutTraitNestedInput
  }

  export type RaceTraitUncheckedUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasValue?: BoolFieldUpdateOperationsInput | boolean
    raceLinks?: RaceTraitMapUncheckedUpdateManyWithoutTraitNestedInput
  }

  export type RaceTraitCreateManyInput = {
    slug: string
    name?: string | null
    description?: string | null
    hasValue?: boolean
  }

  export type RaceTraitUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasValue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceTraitUncheckedUpdateManyInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasValue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceTraitMapCreateInput = {
    value?: string | null
    race: RaceCreateNestedOneWithoutTraitsInput
    trait: RaceTraitCreateNestedOneWithoutRaceLinksInput
  }

  export type RaceTraitMapUncheckedCreateInput = {
    raceId: number
    traitId: string
    value?: string | null
  }

  export type RaceTraitMapUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneRequiredWithoutTraitsNestedInput
    trait?: RaceTraitUpdateOneRequiredWithoutRaceLinksNestedInput
  }

  export type RaceTraitMapUncheckedUpdateInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    traitId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaceTraitMapCreateManyInput = {
    raceId: number
    traitId: string
    value?: string | null
  }

  export type RaceTraitMapUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaceTraitMapUncheckedUpdateManyInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    traitId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaceAbilityAdjustmentCreateInput = {
    abilityId: number
    value: number
    race: RaceCreateNestedOneWithoutAbilityAdjustmentsInput
  }

  export type RaceAbilityAdjustmentUncheckedCreateInput = {
    raceId: number
    abilityId: number
    value: number
  }

  export type RaceAbilityAdjustmentUpdateInput = {
    abilityId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    race?: RaceUpdateOneRequiredWithoutAbilityAdjustmentsNestedInput
  }

  export type RaceAbilityAdjustmentUncheckedUpdateInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    abilityId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RaceAbilityAdjustmentCreateManyInput = {
    raceId: number
    abilityId: number
    value: number
  }

  export type RaceAbilityAdjustmentUpdateManyMutationInput = {
    abilityId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RaceAbilityAdjustmentUncheckedUpdateManyInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    abilityId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RaceLanguageMapCreateInput = {
    languageId: number
    isAutomatic?: boolean
    race: RaceCreateNestedOneWithoutLanguagesInput
  }

  export type RaceLanguageMapUncheckedCreateInput = {
    raceId: number
    languageId: number
    isAutomatic?: boolean
  }

  export type RaceLanguageMapUpdateInput = {
    languageId?: IntFieldUpdateOperationsInput | number
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean
    race?: RaceUpdateOneRequiredWithoutLanguagesNestedInput
  }

  export type RaceLanguageMapUncheckedUpdateInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    languageId?: IntFieldUpdateOperationsInput | number
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceLanguageMapCreateManyInput = {
    raceId: number
    languageId: number
    isAutomatic?: boolean
  }

  export type RaceLanguageMapUpdateManyMutationInput = {
    languageId?: IntFieldUpdateOperationsInput | number
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceLanguageMapUncheckedUpdateManyInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    languageId?: IntFieldUpdateOperationsInput | number
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceSourceMapCreateInput = {
    bookId: number
    pageNumber?: number | null
    Race: RaceCreateNestedOneWithoutSourcesInput
    SourceBook?: SourceBookCreateNestedOneWithoutRacesInput
  }

  export type RaceSourceMapUncheckedCreateInput = {
    id?: number
    raceId: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type RaceSourceMapUpdateInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    Race?: RaceUpdateOneRequiredWithoutSourcesNestedInput
    SourceBook?: SourceBookUpdateOneWithoutRacesNestedInput
  }

  export type RaceSourceMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RaceSourceMapCreateManyInput = {
    id?: number
    raceId: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type RaceSourceMapUpdateManyMutationInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RaceSourceMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArmorCreateInput = {
    name: string
    description?: string | null
    category: number
    cost?: Decimal | DecimalJsLike | number | string | null
    bonus?: number | null
    dexterityCap?: number | null
    checkPenalty?: number | null
    arcaneSpellFailure?: number | null
    speedCapThirty?: number | null
    speedCapTwenty?: number | null
    weight?: number | null
  }

  export type ArmorUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    category: number
    cost?: Decimal | DecimalJsLike | number | string | null
    bonus?: number | null
    dexterityCap?: number | null
    checkPenalty?: number | null
    arcaneSpellFailure?: number | null
    speedCapThirty?: number | null
    speedCapTwenty?: number | null
    weight?: number | null
  }

  export type ArmorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonus?: NullableIntFieldUpdateOperationsInput | number | null
    dexterityCap?: NullableIntFieldUpdateOperationsInput | number | null
    checkPenalty?: NullableIntFieldUpdateOperationsInput | number | null
    arcaneSpellFailure?: NullableIntFieldUpdateOperationsInput | number | null
    speedCapThirty?: NullableIntFieldUpdateOperationsInput | number | null
    speedCapTwenty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArmorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonus?: NullableIntFieldUpdateOperationsInput | number | null
    dexterityCap?: NullableIntFieldUpdateOperationsInput | number | null
    checkPenalty?: NullableIntFieldUpdateOperationsInput | number | null
    arcaneSpellFailure?: NullableIntFieldUpdateOperationsInput | number | null
    speedCapThirty?: NullableIntFieldUpdateOperationsInput | number | null
    speedCapTwenty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArmorCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    category: number
    cost?: Decimal | DecimalJsLike | number | string | null
    bonus?: number | null
    dexterityCap?: number | null
    checkPenalty?: number | null
    arcaneSpellFailure?: number | null
    speedCapThirty?: number | null
    speedCapTwenty?: number | null
    weight?: number | null
  }

  export type ArmorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonus?: NullableIntFieldUpdateOperationsInput | number | null
    dexterityCap?: NullableIntFieldUpdateOperationsInput | number | null
    checkPenalty?: NullableIntFieldUpdateOperationsInput | number | null
    arcaneSpellFailure?: NullableIntFieldUpdateOperationsInput | number | null
    speedCapThirty?: NullableIntFieldUpdateOperationsInput | number | null
    speedCapTwenty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArmorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonus?: NullableIntFieldUpdateOperationsInput | number | null
    dexterityCap?: NullableIntFieldUpdateOperationsInput | number | null
    checkPenalty?: NullableIntFieldUpdateOperationsInput | number | null
    arcaneSpellFailure?: NullableIntFieldUpdateOperationsInput | number | null
    speedCapThirty?: NullableIntFieldUpdateOperationsInput | number | null
    speedCapTwenty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WeaponCreateInput = {
    name: string
    description?: string | null
    category: number
    cost?: Decimal | DecimalJsLike | number | string | null
    damageSmall?: string | null
    damageMedium?: string | null
    critical?: string | null
    range?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    damageTypeId?: number | null
  }

  export type WeaponUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    category: number
    cost?: Decimal | DecimalJsLike | number | string | null
    damageSmall?: string | null
    damageMedium?: string | null
    critical?: string | null
    range?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    damageTypeId?: number | null
  }

  export type WeaponUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    damageSmall?: NullableStringFieldUpdateOperationsInput | string | null
    damageMedium?: NullableStringFieldUpdateOperationsInput | string | null
    critical?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    damageTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WeaponUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    damageSmall?: NullableStringFieldUpdateOperationsInput | string | null
    damageMedium?: NullableStringFieldUpdateOperationsInput | string | null
    critical?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    damageTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WeaponCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    category: number
    cost?: Decimal | DecimalJsLike | number | string | null
    damageSmall?: string | null
    damageMedium?: string | null
    critical?: string | null
    range?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    damageTypeId?: number | null
  }

  export type WeaponUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    damageSmall?: NullableStringFieldUpdateOperationsInput | string | null
    damageMedium?: NullableStringFieldUpdateOperationsInput | string | null
    critical?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    damageTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WeaponUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    damageSmall?: NullableStringFieldUpdateOperationsInput | string | null
    damageMedium?: NullableStringFieldUpdateOperationsInput | string | null
    critical?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    damageTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SourceBookCreateInput = {
    name: string
    abbreviation: string
    releaseDate?: Date | string | null
    editionId?: number | null
    description?: string | null
    isVisible?: boolean
    classes?: ClassSourceMapCreateNestedManyWithoutSourceBookInput
    races?: RaceSourceMapCreateNestedManyWithoutSourceBookInput
    spells?: SpellSourceMapCreateNestedManyWithoutSourceBookInput
  }

  export type SourceBookUncheckedCreateInput = {
    id?: number
    name: string
    abbreviation: string
    releaseDate?: Date | string | null
    editionId?: number | null
    description?: string | null
    isVisible?: boolean
    classes?: ClassSourceMapUncheckedCreateNestedManyWithoutSourceBookInput
    races?: RaceSourceMapUncheckedCreateNestedManyWithoutSourceBookInput
    spells?: SpellSourceMapUncheckedCreateNestedManyWithoutSourceBookInput
  }

  export type SourceBookUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassSourceMapUpdateManyWithoutSourceBookNestedInput
    races?: RaceSourceMapUpdateManyWithoutSourceBookNestedInput
    spells?: SpellSourceMapUpdateManyWithoutSourceBookNestedInput
  }

  export type SourceBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput
    races?: RaceSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput
    spells?: SpellSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput
  }

  export type SourceBookCreateManyInput = {
    id?: number
    name: string
    abbreviation: string
    releaseDate?: Date | string | null
    editionId?: number | null
    description?: string | null
    isVisible?: boolean
  }

  export type SourceBookUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SourceBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReferenceTableCreateInput = {
    slug: string
    name: string
    description?: string | null
    columns?: ReferenceTableColumnCreateNestedManyWithoutTableInput
    rows?: ReferenceTableRowCreateNestedManyWithoutTableInput
  }

  export type ReferenceTableUncheckedCreateInput = {
    slug: string
    name: string
    description?: string | null
    columns?: ReferenceTableColumnUncheckedCreateNestedManyWithoutTableInput
    rows?: ReferenceTableRowUncheckedCreateNestedManyWithoutTableInput
  }

  export type ReferenceTableUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    columns?: ReferenceTableColumnUpdateManyWithoutTableNestedInput
    rows?: ReferenceTableRowUpdateManyWithoutTableNestedInput
  }

  export type ReferenceTableUncheckedUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    columns?: ReferenceTableColumnUncheckedUpdateManyWithoutTableNestedInput
    rows?: ReferenceTableRowUncheckedUpdateManyWithoutTableNestedInput
  }

  export type ReferenceTableCreateManyInput = {
    slug: string
    name: string
    description?: string | null
  }

  export type ReferenceTableUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceTableUncheckedUpdateManyInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceTableColumnCreateInput = {
    columnIndex: number
    header: string
    span?: number | null
    alignment?: string | null
    cells?: ReferenceTableCellCreateNestedManyWithoutColumnInput
    table: ReferenceTableCreateNestedOneWithoutColumnsInput
  }

  export type ReferenceTableColumnUncheckedCreateInput = {
    id?: number
    tableSlug: string
    columnIndex: number
    header: string
    span?: number | null
    alignment?: string | null
    cells?: ReferenceTableCellUncheckedCreateNestedManyWithoutColumnInput
  }

  export type ReferenceTableColumnUpdateInput = {
    columnIndex?: IntFieldUpdateOperationsInput | number
    header?: StringFieldUpdateOperationsInput | string
    span?: NullableIntFieldUpdateOperationsInput | number | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
    cells?: ReferenceTableCellUpdateManyWithoutColumnNestedInput
    table?: ReferenceTableUpdateOneRequiredWithoutColumnsNestedInput
  }

  export type ReferenceTableColumnUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableSlug?: StringFieldUpdateOperationsInput | string
    columnIndex?: IntFieldUpdateOperationsInput | number
    header?: StringFieldUpdateOperationsInput | string
    span?: NullableIntFieldUpdateOperationsInput | number | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
    cells?: ReferenceTableCellUncheckedUpdateManyWithoutColumnNestedInput
  }

  export type ReferenceTableColumnCreateManyInput = {
    id?: number
    tableSlug: string
    columnIndex: number
    header: string
    span?: number | null
    alignment?: string | null
  }

  export type ReferenceTableColumnUpdateManyMutationInput = {
    columnIndex?: IntFieldUpdateOperationsInput | number
    header?: StringFieldUpdateOperationsInput | string
    span?: NullableIntFieldUpdateOperationsInput | number | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceTableColumnUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableSlug?: StringFieldUpdateOperationsInput | string
    columnIndex?: IntFieldUpdateOperationsInput | number
    header?: StringFieldUpdateOperationsInput | string
    span?: NullableIntFieldUpdateOperationsInput | number | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceTableRowCreateInput = {
    rowIndex: number
    label?: string | null
    cells?: ReferenceTableCellCreateNestedManyWithoutRowInput
    table: ReferenceTableCreateNestedOneWithoutRowsInput
  }

  export type ReferenceTableRowUncheckedCreateInput = {
    id?: number
    tableSlug: string
    rowIndex: number
    label?: string | null
    cells?: ReferenceTableCellUncheckedCreateNestedManyWithoutRowInput
  }

  export type ReferenceTableRowUpdateInput = {
    rowIndex?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    cells?: ReferenceTableCellUpdateManyWithoutRowNestedInput
    table?: ReferenceTableUpdateOneRequiredWithoutRowsNestedInput
  }

  export type ReferenceTableRowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableSlug?: StringFieldUpdateOperationsInput | string
    rowIndex?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    cells?: ReferenceTableCellUncheckedUpdateManyWithoutRowNestedInput
  }

  export type ReferenceTableRowCreateManyInput = {
    id?: number
    tableSlug: string
    rowIndex: number
    label?: string | null
  }

  export type ReferenceTableRowUpdateManyMutationInput = {
    rowIndex?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceTableRowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableSlug?: StringFieldUpdateOperationsInput | string
    rowIndex?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceTableCellCreateInput = {
    value?: string | null
    colSpan?: number | null
    rowSpan?: number | null
    column: ReferenceTableColumnCreateNestedOneWithoutCellsInput
    row: ReferenceTableRowCreateNestedOneWithoutCellsInput
  }

  export type ReferenceTableCellUncheckedCreateInput = {
    id?: number
    rowId: number
    columnId: number
    value?: string | null
    colSpan?: number | null
    rowSpan?: number | null
  }

  export type ReferenceTableCellUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    colSpan?: NullableIntFieldUpdateOperationsInput | number | null
    rowSpan?: NullableIntFieldUpdateOperationsInput | number | null
    column?: ReferenceTableColumnUpdateOneRequiredWithoutCellsNestedInput
    row?: ReferenceTableRowUpdateOneRequiredWithoutCellsNestedInput
  }

  export type ReferenceTableCellUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rowId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    colSpan?: NullableIntFieldUpdateOperationsInput | number | null
    rowSpan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferenceTableCellCreateManyInput = {
    id?: number
    rowId: number
    columnId: number
    value?: string | null
    colSpan?: number | null
    rowSpan?: number | null
  }

  export type ReferenceTableCellUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    colSpan?: NullableIntFieldUpdateOperationsInput | number | null
    rowSpan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferenceTableCellUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rowId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    colSpan?: NullableIntFieldUpdateOperationsInput | number | null
    rowSpan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCharacterCreateInput = {
    name: string
    alignmentId: number
    age?: number | null
    height?: number | null
    weight?: number | null
    eyes?: string | null
    hair?: string | null
    gender?: string | null
    notes?: string | null
    attributes?: UserCharacterAttributeCreateNestedManyWithoutCharacterInput
    race: RaceCreateNestedOneWithoutUserCharacterInput
    user: UserCreateNestedOneWithoutCharactersInput
  }

  export type UserCharacterUncheckedCreateInput = {
    id?: number
    userId: number
    name: string
    raceId: number
    alignmentId: number
    age?: number | null
    height?: number | null
    weight?: number | null
    eyes?: string | null
    hair?: string | null
    gender?: string | null
    notes?: string | null
    attributes?: UserCharacterAttributeUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type UserCharacterUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: UserCharacterAttributeUpdateManyWithoutCharacterNestedInput
    race?: RaceUpdateOneRequiredWithoutUserCharacterNestedInput
    user?: UserUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type UserCharacterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: UserCharacterAttributeUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type UserCharacterCreateManyInput = {
    id?: number
    userId: number
    name: string
    raceId: number
    alignmentId: number
    age?: number | null
    height?: number | null
    weight?: number | null
    eyes?: string | null
    hair?: string | null
    gender?: string | null
    notes?: string | null
  }

  export type UserCharacterUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCharacterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCharacterAttributeCreateInput = {
    attributeId: number
    value: number
    character: UserCharacterCreateNestedOneWithoutAttributesInput
  }

  export type UserCharacterAttributeUncheckedCreateInput = {
    id?: number
    characterId: number
    attributeId: number
    value: number
  }

  export type UserCharacterAttributeUpdateInput = {
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    character?: UserCharacterUpdateOneRequiredWithoutAttributesNestedInput
  }

  export type UserCharacterAttributeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterId?: IntFieldUpdateOperationsInput | number
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type UserCharacterAttributeCreateManyInput = {
    id?: number
    characterId: number
    attributeId: number
    value: number
  }

  export type UserCharacterAttributeUpdateManyMutationInput = {
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type UserCharacterAttributeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterId?: IntFieldUpdateOperationsInput | number
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    username: string
    email: string
    password: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredEditionId?: number | null
    characters?: UserCharacterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredEditionId?: number | null
    characters?: UserCharacterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredEditionId?: NullableIntFieldUpdateOperationsInput | number | null
    characters?: UserCharacterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredEditionId?: NullableIntFieldUpdateOperationsInput | number | null
    characters?: UserCharacterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    email: string
    password: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredEditionId?: number | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredEditionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredEditionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ClassFeatureListRelationFilter = {
    every?: ClassFeatureWhereInput
    some?: ClassFeatureWhereInput
    none?: ClassFeatureWhereInput
  }

  export type ClassLevelAttributeListRelationFilter = {
    every?: ClassLevelAttributeWhereInput
    some?: ClassLevelAttributeWhereInput
    none?: ClassLevelAttributeWhereInput
  }

  export type ClassSpellLevelListRelationFilter = {
    every?: ClassSpellLevelWhereInput
    some?: ClassSpellLevelWhereInput
    none?: ClassSpellLevelWhereInput
  }

  export type ClassSkillMapListRelationFilter = {
    every?: ClassSkillMapWhereInput
    some?: ClassSkillMapWhereInput
    none?: ClassSkillMapWhereInput
  }

  export type ClassSourceMapListRelationFilter = {
    every?: ClassSourceMapWhereInput
    some?: ClassSourceMapWhereInput
    none?: ClassSourceMapWhereInput
  }

  export type SpellLevelMapListRelationFilter = {
    every?: SpellLevelMapWhereInput
    some?: SpellLevelMapWhereInput
    none?: SpellLevelMapWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClassFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassLevelAttributeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassSpellLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassSkillMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassSourceMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellLevelMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelevanceInput = {
    fields: ClassOrderByRelevanceFieldEnum | ClassOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    editionId?: SortOrder
    isPrestige?: SortOrder
    isVisible?: SortOrder
    canCastSpells?: SortOrder
    hitDie?: SortOrder
    description?: SortOrder
    skillPoints?: SortOrder
    castingAbilityId?: SortOrder
  }

  export type ClassAvgOrderByAggregateInput = {
    id?: SortOrder
    editionId?: SortOrder
    hitDie?: SortOrder
    skillPoints?: SortOrder
    castingAbilityId?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    editionId?: SortOrder
    isPrestige?: SortOrder
    isVisible?: SortOrder
    canCastSpells?: SortOrder
    hitDie?: SortOrder
    description?: SortOrder
    skillPoints?: SortOrder
    castingAbilityId?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    editionId?: SortOrder
    isPrestige?: SortOrder
    isVisible?: SortOrder
    canCastSpells?: SortOrder
    hitDie?: SortOrder
    description?: SortOrder
    skillPoints?: SortOrder
    castingAbilityId?: SortOrder
  }

  export type ClassSumOrderByAggregateInput = {
    id?: SortOrder
    editionId?: SortOrder
    hitDie?: SortOrder
    skillPoints?: SortOrder
    castingAbilityId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type ClassFeatureOrderByRelevanceInput = {
    fields: ClassFeatureOrderByRelevanceFieldEnum | ClassFeatureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClassFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
  }

  export type ClassFeatureAvgOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    level?: SortOrder
  }

  export type ClassFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
  }

  export type ClassFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
  }

  export type ClassFeatureSumOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    level?: SortOrder
  }

  export type ClassSpellLevelCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    spellLevel?: SortOrder
  }

  export type ClassSpellLevelAvgOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    spellLevel?: SortOrder
  }

  export type ClassSpellLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    spellLevel?: SortOrder
  }

  export type ClassSpellLevelMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    spellLevel?: SortOrder
  }

  export type ClassSpellLevelSumOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    spellLevel?: SortOrder
  }

  export type ClassLevelAttributeCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    baseAttackBonus?: SortOrder
    fortSave?: SortOrder
    refSave?: SortOrder
    willSave?: SortOrder
  }

  export type ClassLevelAttributeAvgOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    baseAttackBonus?: SortOrder
    fortSave?: SortOrder
    refSave?: SortOrder
    willSave?: SortOrder
  }

  export type ClassLevelAttributeMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    baseAttackBonus?: SortOrder
    fortSave?: SortOrder
    refSave?: SortOrder
    willSave?: SortOrder
  }

  export type ClassLevelAttributeMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    baseAttackBonus?: SortOrder
    fortSave?: SortOrder
    refSave?: SortOrder
    willSave?: SortOrder
  }

  export type ClassLevelAttributeSumOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    baseAttackBonus?: SortOrder
    fortSave?: SortOrder
    refSave?: SortOrder
    willSave?: SortOrder
  }

  export type SkillScalarRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type ClassSkillMapCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
  }

  export type ClassSkillMapAvgOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
  }

  export type ClassSkillMapMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
  }

  export type ClassSkillMapMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
  }

  export type ClassSkillMapSumOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
  }

  export type SourceBookNullableScalarRelationFilter = {
    is?: SourceBookWhereInput | null
    isNot?: SourceBookWhereInput | null
  }

  export type ClassSourceMapCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type ClassSourceMapAvgOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type ClassSourceMapMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type ClassSourceMapMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type ClassSourceMapSumOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type SpellScalarRelationFilter = {
    is?: SpellWhereInput
    isNot?: SpellWhereInput
  }

  export type SpellLevelMapCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    spellId?: SortOrder
    level?: SortOrder
    isVisible?: SortOrder
  }

  export type SpellLevelMapAvgOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    spellId?: SortOrder
    level?: SortOrder
  }

  export type SpellLevelMapMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    spellId?: SortOrder
    level?: SortOrder
    isVisible?: SortOrder
  }

  export type SpellLevelMapMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    spellId?: SortOrder
    level?: SortOrder
    isVisible?: SortOrder
  }

  export type SpellLevelMapSumOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    spellId?: SortOrder
    level?: SortOrder
  }

  export type SpellDescriptorMapListRelationFilter = {
    every?: SpellDescriptorMapWhereInput
    some?: SpellDescriptorMapWhereInput
    none?: SpellDescriptorMapWhereInput
  }

  export type SpellSchoolMapListRelationFilter = {
    every?: SpellSchoolMapWhereInput
    some?: SpellSchoolMapWhereInput
    none?: SpellSchoolMapWhereInput
  }

  export type SpellSourceMapListRelationFilter = {
    every?: SpellSourceMapWhereInput
    some?: SpellSourceMapWhereInput
    none?: SpellSourceMapWhereInput
  }

  export type SpellSubschoolMapListRelationFilter = {
    every?: SpellSubschoolMapWhereInput
    some?: SpellSubschoolMapWhereInput
    none?: SpellSubschoolMapWhereInput
  }

  export type SpellDescriptorMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellSchoolMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellSourceMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellSubschoolMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellOrderByRelevanceInput = {
    fields: SpellOrderByRelevanceFieldEnum | SpellOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SpellCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    castingTime?: SortOrder
    range?: SortOrder
    rangeTypeId?: SortOrder
    rangeValue?: SortOrder
    area?: SortOrder
    duration?: SortOrder
    savingThrow?: SortOrder
    spellResistance?: SortOrder
    editionId?: SortOrder
    baseLevel?: SortOrder
    effect?: SortOrder
    target?: SortOrder
  }

  export type SpellAvgOrderByAggregateInput = {
    id?: SortOrder
    rangeTypeId?: SortOrder
    editionId?: SortOrder
    baseLevel?: SortOrder
  }

  export type SpellMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    castingTime?: SortOrder
    range?: SortOrder
    rangeTypeId?: SortOrder
    rangeValue?: SortOrder
    area?: SortOrder
    duration?: SortOrder
    savingThrow?: SortOrder
    spellResistance?: SortOrder
    editionId?: SortOrder
    baseLevel?: SortOrder
    effect?: SortOrder
    target?: SortOrder
  }

  export type SpellMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    castingTime?: SortOrder
    range?: SortOrder
    rangeTypeId?: SortOrder
    rangeValue?: SortOrder
    area?: SortOrder
    duration?: SortOrder
    savingThrow?: SortOrder
    spellResistance?: SortOrder
    editionId?: SortOrder
    baseLevel?: SortOrder
    effect?: SortOrder
    target?: SortOrder
  }

  export type SpellSumOrderByAggregateInput = {
    id?: SortOrder
    rangeTypeId?: SortOrder
    editionId?: SortOrder
    baseLevel?: SortOrder
  }

  export type SpellDescriptorMapCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    descriptorId?: SortOrder
  }

  export type SpellDescriptorMapAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    descriptorId?: SortOrder
  }

  export type SpellDescriptorMapMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    descriptorId?: SortOrder
  }

  export type SpellDescriptorMapMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    descriptorId?: SortOrder
  }

  export type SpellDescriptorMapSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    descriptorId?: SortOrder
  }

  export type SpellSchoolMapCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
  }

  export type SpellSchoolMapAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
  }

  export type SpellSchoolMapMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
  }

  export type SpellSchoolMapMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
  }

  export type SpellSchoolMapSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
  }

  export type SpellSourceMapCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type SpellSourceMapAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type SpellSourceMapMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type SpellSourceMapMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type SpellSourceMapSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type SpellSubschoolMapCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
  }

  export type SpellSubschoolMapAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
  }

  export type SpellSubschoolMapMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
  }

  export type SpellSubschoolMapMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
  }

  export type SpellSubschoolMapSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    schoolId?: SortOrder
  }

  export type SpellComponentMapCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    componentId?: SortOrder
  }

  export type SpellComponentMapAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    componentId?: SortOrder
  }

  export type SpellComponentMapMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    componentId?: SortOrder
  }

  export type SpellComponentMapMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    componentId?: SortOrder
  }

  export type SpellComponentMapSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    componentId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type SkillOrderByRelevanceInput = {
    fields: SkillOrderByRelevanceFieldEnum | SkillOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abilityId?: SortOrder
    checkDescription?: SortOrder
    actionDescription?: SortOrder
    retryTypeId?: SortOrder
    retryDescription?: SortOrder
    specialNotes?: SortOrder
    synergyNotes?: SortOrder
    untrainedNotes?: SortOrder
    affectedByArmor?: SortOrder
    description?: SortOrder
    trainedOnly?: SortOrder
  }

  export type SkillAvgOrderByAggregateInput = {
    id?: SortOrder
    abilityId?: SortOrder
    retryTypeId?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abilityId?: SortOrder
    checkDescription?: SortOrder
    actionDescription?: SortOrder
    retryTypeId?: SortOrder
    retryDescription?: SortOrder
    specialNotes?: SortOrder
    synergyNotes?: SortOrder
    untrainedNotes?: SortOrder
    affectedByArmor?: SortOrder
    description?: SortOrder
    trainedOnly?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abilityId?: SortOrder
    checkDescription?: SortOrder
    actionDescription?: SortOrder
    retryTypeId?: SortOrder
    retryDescription?: SortOrder
    specialNotes?: SortOrder
    synergyNotes?: SortOrder
    untrainedNotes?: SortOrder
    affectedByArmor?: SortOrder
    description?: SortOrder
    trainedOnly?: SortOrder
  }

  export type SkillSumOrderByAggregateInput = {
    id?: SortOrder
    abilityId?: SortOrder
    retryTypeId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FeatBenefitMapListRelationFilter = {
    every?: FeatBenefitMapWhereInput
    some?: FeatBenefitMapWhereInput
    none?: FeatBenefitMapWhereInput
  }

  export type FeatPrerequisiteMapListRelationFilter = {
    every?: FeatPrerequisiteMapWhereInput
    some?: FeatPrerequisiteMapWhereInput
    none?: FeatPrerequisiteMapWhereInput
  }

  export type FeatBenefitMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatPrerequisiteMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatOrderByRelevanceInput = {
    fields: FeatOrderByRelevanceFieldEnum | FeatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FeatCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    typeId?: SortOrder
    description?: SortOrder
    benefit?: SortOrder
    normalEffect?: SortOrder
    specialEffect?: SortOrder
    prerequisites?: SortOrder
    repeatable?: SortOrder
    fighterBonus?: SortOrder
  }

  export type FeatAvgOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
  }

  export type FeatMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    typeId?: SortOrder
    description?: SortOrder
    benefit?: SortOrder
    normalEffect?: SortOrder
    specialEffect?: SortOrder
    prerequisites?: SortOrder
    repeatable?: SortOrder
    fighterBonus?: SortOrder
  }

  export type FeatMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    typeId?: SortOrder
    description?: SortOrder
    benefit?: SortOrder
    normalEffect?: SortOrder
    specialEffect?: SortOrder
    prerequisites?: SortOrder
    repeatable?: SortOrder
    fighterBonus?: SortOrder
  }

  export type FeatSumOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
  }

  export type FeatScalarRelationFilter = {
    is?: FeatWhereInput
    isNot?: FeatWhereInput
  }

  export type FeatBenefitMapFeatIdIndexCompoundUniqueInput = {
    featId: number
    index: number
  }

  export type FeatBenefitMapCountOrderByAggregateInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    index?: SortOrder
  }

  export type FeatBenefitMapAvgOrderByAggregateInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    index?: SortOrder
  }

  export type FeatBenefitMapMaxOrderByAggregateInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    index?: SortOrder
  }

  export type FeatBenefitMapMinOrderByAggregateInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    index?: SortOrder
  }

  export type FeatBenefitMapSumOrderByAggregateInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    index?: SortOrder
  }

  export type FeatPrerequisiteMapFeatIdIndexCompoundUniqueInput = {
    featId: number
    index: number
  }

  export type FeatPrerequisiteMapCountOrderByAggregateInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    index?: SortOrder
  }

  export type FeatPrerequisiteMapAvgOrderByAggregateInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    index?: SortOrder
  }

  export type FeatPrerequisiteMapMaxOrderByAggregateInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    index?: SortOrder
  }

  export type FeatPrerequisiteMapMinOrderByAggregateInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    index?: SortOrder
  }

  export type FeatPrerequisiteMapSumOrderByAggregateInput = {
    featId?: SortOrder
    typeId?: SortOrder
    referenceId?: SortOrder
    amount?: SortOrder
    index?: SortOrder
  }

  export type RaceAbilityAdjustmentListRelationFilter = {
    every?: RaceAbilityAdjustmentWhereInput
    some?: RaceAbilityAdjustmentWhereInput
    none?: RaceAbilityAdjustmentWhereInput
  }

  export type RaceLanguageMapListRelationFilter = {
    every?: RaceLanguageMapWhereInput
    some?: RaceLanguageMapWhereInput
    none?: RaceLanguageMapWhereInput
  }

  export type RaceSourceMapListRelationFilter = {
    every?: RaceSourceMapWhereInput
    some?: RaceSourceMapWhereInput
    none?: RaceSourceMapWhereInput
  }

  export type RaceTraitMapListRelationFilter = {
    every?: RaceTraitMapWhereInput
    some?: RaceTraitMapWhereInput
    none?: RaceTraitMapWhereInput
  }

  export type UserCharacterListRelationFilter = {
    every?: UserCharacterWhereInput
    some?: UserCharacterWhereInput
    none?: UserCharacterWhereInput
  }

  export type RaceAbilityAdjustmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceLanguageMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceSourceMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceTraitMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceOrderByRelevanceInput = {
    fields: RaceOrderByRelevanceFieldEnum | RaceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    editionId?: SortOrder
    isVisible?: SortOrder
    description?: SortOrder
    sizeId?: SortOrder
    speed?: SortOrder
    favoredClassId?: SortOrder
  }

  export type RaceAvgOrderByAggregateInput = {
    id?: SortOrder
    editionId?: SortOrder
    sizeId?: SortOrder
    speed?: SortOrder
    favoredClassId?: SortOrder
  }

  export type RaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    editionId?: SortOrder
    isVisible?: SortOrder
    description?: SortOrder
    sizeId?: SortOrder
    speed?: SortOrder
    favoredClassId?: SortOrder
  }

  export type RaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    editionId?: SortOrder
    isVisible?: SortOrder
    description?: SortOrder
    sizeId?: SortOrder
    speed?: SortOrder
    favoredClassId?: SortOrder
  }

  export type RaceSumOrderByAggregateInput = {
    id?: SortOrder
    editionId?: SortOrder
    sizeId?: SortOrder
    speed?: SortOrder
    favoredClassId?: SortOrder
  }

  export type RaceTraitOrderByRelevanceInput = {
    fields: RaceTraitOrderByRelevanceFieldEnum | RaceTraitOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RaceTraitCountOrderByAggregateInput = {
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    hasValue?: SortOrder
  }

  export type RaceTraitMaxOrderByAggregateInput = {
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    hasValue?: SortOrder
  }

  export type RaceTraitMinOrderByAggregateInput = {
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    hasValue?: SortOrder
  }

  export type RaceScalarRelationFilter = {
    is?: RaceWhereInput
    isNot?: RaceWhereInput
  }

  export type RaceTraitScalarRelationFilter = {
    is?: RaceTraitWhereInput
    isNot?: RaceTraitWhereInput
  }

  export type RaceTraitMapOrderByRelevanceInput = {
    fields: RaceTraitMapOrderByRelevanceFieldEnum | RaceTraitMapOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RaceTraitMapRaceIdTraitIdCompoundUniqueInput = {
    raceId: number
    traitId: string
  }

  export type RaceTraitMapCountOrderByAggregateInput = {
    raceId?: SortOrder
    traitId?: SortOrder
    value?: SortOrder
  }

  export type RaceTraitMapAvgOrderByAggregateInput = {
    raceId?: SortOrder
  }

  export type RaceTraitMapMaxOrderByAggregateInput = {
    raceId?: SortOrder
    traitId?: SortOrder
    value?: SortOrder
  }

  export type RaceTraitMapMinOrderByAggregateInput = {
    raceId?: SortOrder
    traitId?: SortOrder
    value?: SortOrder
  }

  export type RaceTraitMapSumOrderByAggregateInput = {
    raceId?: SortOrder
  }

  export type RaceAbilityAdjustmentRaceIdAbilityIdCompoundUniqueInput = {
    raceId: number
    abilityId: number
  }

  export type RaceAbilityAdjustmentCountOrderByAggregateInput = {
    raceId?: SortOrder
    abilityId?: SortOrder
    value?: SortOrder
  }

  export type RaceAbilityAdjustmentAvgOrderByAggregateInput = {
    raceId?: SortOrder
    abilityId?: SortOrder
    value?: SortOrder
  }

  export type RaceAbilityAdjustmentMaxOrderByAggregateInput = {
    raceId?: SortOrder
    abilityId?: SortOrder
    value?: SortOrder
  }

  export type RaceAbilityAdjustmentMinOrderByAggregateInput = {
    raceId?: SortOrder
    abilityId?: SortOrder
    value?: SortOrder
  }

  export type RaceAbilityAdjustmentSumOrderByAggregateInput = {
    raceId?: SortOrder
    abilityId?: SortOrder
    value?: SortOrder
  }

  export type RaceLanguageMapRaceIdLanguageIdCompoundUniqueInput = {
    raceId: number
    languageId: number
  }

  export type RaceLanguageMapCountOrderByAggregateInput = {
    raceId?: SortOrder
    languageId?: SortOrder
    isAutomatic?: SortOrder
  }

  export type RaceLanguageMapAvgOrderByAggregateInput = {
    raceId?: SortOrder
    languageId?: SortOrder
  }

  export type RaceLanguageMapMaxOrderByAggregateInput = {
    raceId?: SortOrder
    languageId?: SortOrder
    isAutomatic?: SortOrder
  }

  export type RaceLanguageMapMinOrderByAggregateInput = {
    raceId?: SortOrder
    languageId?: SortOrder
    isAutomatic?: SortOrder
  }

  export type RaceLanguageMapSumOrderByAggregateInput = {
    raceId?: SortOrder
    languageId?: SortOrder
  }

  export type RaceSourceMapCountOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type RaceSourceMapAvgOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type RaceSourceMapMaxOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type RaceSourceMapMinOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type RaceSourceMapSumOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    bookId?: SortOrder
    pageNumber?: SortOrder
    sourceBookId?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ArmorOrderByRelevanceInput = {
    fields: ArmorOrderByRelevanceFieldEnum | ArmorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ArmorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    bonus?: SortOrder
    dexterityCap?: SortOrder
    checkPenalty?: SortOrder
    arcaneSpellFailure?: SortOrder
    speedCapThirty?: SortOrder
    speedCapTwenty?: SortOrder
    weight?: SortOrder
  }

  export type ArmorAvgOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    bonus?: SortOrder
    dexterityCap?: SortOrder
    checkPenalty?: SortOrder
    arcaneSpellFailure?: SortOrder
    speedCapThirty?: SortOrder
    speedCapTwenty?: SortOrder
    weight?: SortOrder
  }

  export type ArmorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    bonus?: SortOrder
    dexterityCap?: SortOrder
    checkPenalty?: SortOrder
    arcaneSpellFailure?: SortOrder
    speedCapThirty?: SortOrder
    speedCapTwenty?: SortOrder
    weight?: SortOrder
  }

  export type ArmorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    bonus?: SortOrder
    dexterityCap?: SortOrder
    checkPenalty?: SortOrder
    arcaneSpellFailure?: SortOrder
    speedCapThirty?: SortOrder
    speedCapTwenty?: SortOrder
    weight?: SortOrder
  }

  export type ArmorSumOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    bonus?: SortOrder
    dexterityCap?: SortOrder
    checkPenalty?: SortOrder
    arcaneSpellFailure?: SortOrder
    speedCapThirty?: SortOrder
    speedCapTwenty?: SortOrder
    weight?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type WeaponOrderByRelevanceInput = {
    fields: WeaponOrderByRelevanceFieldEnum | WeaponOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WeaponCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    damageSmall?: SortOrder
    damageMedium?: SortOrder
    critical?: SortOrder
    range?: SortOrder
    weight?: SortOrder
    damageTypeId?: SortOrder
  }

  export type WeaponAvgOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    weight?: SortOrder
    damageTypeId?: SortOrder
  }

  export type WeaponMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    damageSmall?: SortOrder
    damageMedium?: SortOrder
    critical?: SortOrder
    range?: SortOrder
    weight?: SortOrder
    damageTypeId?: SortOrder
  }

  export type WeaponMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    damageSmall?: SortOrder
    damageMedium?: SortOrder
    critical?: SortOrder
    range?: SortOrder
    weight?: SortOrder
    damageTypeId?: SortOrder
  }

  export type WeaponSumOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    cost?: SortOrder
    weight?: SortOrder
    damageTypeId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SourceBookOrderByRelevanceInput = {
    fields: SourceBookOrderByRelevanceFieldEnum | SourceBookOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SourceBookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    releaseDate?: SortOrder
    editionId?: SortOrder
    description?: SortOrder
    isVisible?: SortOrder
  }

  export type SourceBookAvgOrderByAggregateInput = {
    id?: SortOrder
    editionId?: SortOrder
  }

  export type SourceBookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    releaseDate?: SortOrder
    editionId?: SortOrder
    description?: SortOrder
    isVisible?: SortOrder
  }

  export type SourceBookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    releaseDate?: SortOrder
    editionId?: SortOrder
    description?: SortOrder
    isVisible?: SortOrder
  }

  export type SourceBookSumOrderByAggregateInput = {
    id?: SortOrder
    editionId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ReferenceTableColumnListRelationFilter = {
    every?: ReferenceTableColumnWhereInput
    some?: ReferenceTableColumnWhereInput
    none?: ReferenceTableColumnWhereInput
  }

  export type ReferenceTableRowListRelationFilter = {
    every?: ReferenceTableRowWhereInput
    some?: ReferenceTableRowWhereInput
    none?: ReferenceTableRowWhereInput
  }

  export type ReferenceTableColumnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferenceTableRowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferenceTableOrderByRelevanceInput = {
    fields: ReferenceTableOrderByRelevanceFieldEnum | ReferenceTableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReferenceTableCountOrderByAggregateInput = {
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ReferenceTableMaxOrderByAggregateInput = {
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ReferenceTableMinOrderByAggregateInput = {
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ReferenceTableCellListRelationFilter = {
    every?: ReferenceTableCellWhereInput
    some?: ReferenceTableCellWhereInput
    none?: ReferenceTableCellWhereInput
  }

  export type ReferenceTableScalarRelationFilter = {
    is?: ReferenceTableWhereInput
    isNot?: ReferenceTableWhereInput
  }

  export type ReferenceTableCellOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferenceTableColumnOrderByRelevanceInput = {
    fields: ReferenceTableColumnOrderByRelevanceFieldEnum | ReferenceTableColumnOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReferenceTableColumnCountOrderByAggregateInput = {
    id?: SortOrder
    tableSlug?: SortOrder
    columnIndex?: SortOrder
    header?: SortOrder
    span?: SortOrder
    alignment?: SortOrder
  }

  export type ReferenceTableColumnAvgOrderByAggregateInput = {
    id?: SortOrder
    columnIndex?: SortOrder
    span?: SortOrder
  }

  export type ReferenceTableColumnMaxOrderByAggregateInput = {
    id?: SortOrder
    tableSlug?: SortOrder
    columnIndex?: SortOrder
    header?: SortOrder
    span?: SortOrder
    alignment?: SortOrder
  }

  export type ReferenceTableColumnMinOrderByAggregateInput = {
    id?: SortOrder
    tableSlug?: SortOrder
    columnIndex?: SortOrder
    header?: SortOrder
    span?: SortOrder
    alignment?: SortOrder
  }

  export type ReferenceTableColumnSumOrderByAggregateInput = {
    id?: SortOrder
    columnIndex?: SortOrder
    span?: SortOrder
  }

  export type ReferenceTableRowOrderByRelevanceInput = {
    fields: ReferenceTableRowOrderByRelevanceFieldEnum | ReferenceTableRowOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReferenceTableRowCountOrderByAggregateInput = {
    id?: SortOrder
    tableSlug?: SortOrder
    rowIndex?: SortOrder
    label?: SortOrder
  }

  export type ReferenceTableRowAvgOrderByAggregateInput = {
    id?: SortOrder
    rowIndex?: SortOrder
  }

  export type ReferenceTableRowMaxOrderByAggregateInput = {
    id?: SortOrder
    tableSlug?: SortOrder
    rowIndex?: SortOrder
    label?: SortOrder
  }

  export type ReferenceTableRowMinOrderByAggregateInput = {
    id?: SortOrder
    tableSlug?: SortOrder
    rowIndex?: SortOrder
    label?: SortOrder
  }

  export type ReferenceTableRowSumOrderByAggregateInput = {
    id?: SortOrder
    rowIndex?: SortOrder
  }

  export type ReferenceTableColumnScalarRelationFilter = {
    is?: ReferenceTableColumnWhereInput
    isNot?: ReferenceTableColumnWhereInput
  }

  export type ReferenceTableRowScalarRelationFilter = {
    is?: ReferenceTableRowWhereInput
    isNot?: ReferenceTableRowWhereInput
  }

  export type ReferenceTableCellOrderByRelevanceInput = {
    fields: ReferenceTableCellOrderByRelevanceFieldEnum | ReferenceTableCellOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReferenceTableCellCountOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    value?: SortOrder
    colSpan?: SortOrder
    rowSpan?: SortOrder
  }

  export type ReferenceTableCellAvgOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    colSpan?: SortOrder
    rowSpan?: SortOrder
  }

  export type ReferenceTableCellMaxOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    value?: SortOrder
    colSpan?: SortOrder
    rowSpan?: SortOrder
  }

  export type ReferenceTableCellMinOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    value?: SortOrder
    colSpan?: SortOrder
    rowSpan?: SortOrder
  }

  export type ReferenceTableCellSumOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    columnId?: SortOrder
    colSpan?: SortOrder
    rowSpan?: SortOrder
  }

  export type UserCharacterAttributeListRelationFilter = {
    every?: UserCharacterAttributeWhereInput
    some?: UserCharacterAttributeWhereInput
    none?: UserCharacterAttributeWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserCharacterAttributeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCharacterOrderByRelevanceInput = {
    fields: UserCharacterOrderByRelevanceFieldEnum | UserCharacterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCharacterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    raceId?: SortOrder
    alignmentId?: SortOrder
    age?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    eyes?: SortOrder
    hair?: SortOrder
    gender?: SortOrder
    notes?: SortOrder
  }

  export type UserCharacterAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    raceId?: SortOrder
    alignmentId?: SortOrder
    age?: SortOrder
    height?: SortOrder
    weight?: SortOrder
  }

  export type UserCharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    raceId?: SortOrder
    alignmentId?: SortOrder
    age?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    eyes?: SortOrder
    hair?: SortOrder
    gender?: SortOrder
    notes?: SortOrder
  }

  export type UserCharacterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    raceId?: SortOrder
    alignmentId?: SortOrder
    age?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    eyes?: SortOrder
    hair?: SortOrder
    gender?: SortOrder
    notes?: SortOrder
  }

  export type UserCharacterSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    raceId?: SortOrder
    alignmentId?: SortOrder
    age?: SortOrder
    height?: SortOrder
    weight?: SortOrder
  }

  export type UserCharacterScalarRelationFilter = {
    is?: UserCharacterWhereInput
    isNot?: UserCharacterWhereInput
  }

  export type UserCharacterAttributeCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
  }

  export type UserCharacterAttributeAvgOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
  }

  export type UserCharacterAttributeMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
  }

  export type UserCharacterAttributeMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
  }

  export type UserCharacterAttributeSumOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferredEditionId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    preferredEditionId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferredEditionId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferredEditionId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    preferredEditionId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ClassFeatureCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput> | ClassFeatureCreateWithoutClassInput[] | ClassFeatureUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutClassInput | ClassFeatureCreateOrConnectWithoutClassInput[]
    createMany?: ClassFeatureCreateManyClassInputEnvelope
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
  }

  export type ClassLevelAttributeCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassLevelAttributeCreateWithoutClassInput, ClassLevelAttributeUncheckedCreateWithoutClassInput> | ClassLevelAttributeCreateWithoutClassInput[] | ClassLevelAttributeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassLevelAttributeCreateOrConnectWithoutClassInput | ClassLevelAttributeCreateOrConnectWithoutClassInput[]
    createMany?: ClassLevelAttributeCreateManyClassInputEnvelope
    connect?: ClassLevelAttributeWhereUniqueInput | ClassLevelAttributeWhereUniqueInput[]
  }

  export type ClassSpellLevelCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSpellLevelCreateWithoutClassInput, ClassSpellLevelUncheckedCreateWithoutClassInput> | ClassSpellLevelCreateWithoutClassInput[] | ClassSpellLevelUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSpellLevelCreateOrConnectWithoutClassInput | ClassSpellLevelCreateOrConnectWithoutClassInput[]
    createMany?: ClassSpellLevelCreateManyClassInputEnvelope
    connect?: ClassSpellLevelWhereUniqueInput | ClassSpellLevelWhereUniqueInput[]
  }

  export type ClassSkillMapCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSkillMapCreateWithoutClassInput, ClassSkillMapUncheckedCreateWithoutClassInput> | ClassSkillMapCreateWithoutClassInput[] | ClassSkillMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSkillMapCreateOrConnectWithoutClassInput | ClassSkillMapCreateOrConnectWithoutClassInput[]
    createMany?: ClassSkillMapCreateManyClassInputEnvelope
    connect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
  }

  export type ClassSourceMapCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSourceMapCreateWithoutClassInput, ClassSourceMapUncheckedCreateWithoutClassInput> | ClassSourceMapCreateWithoutClassInput[] | ClassSourceMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSourceMapCreateOrConnectWithoutClassInput | ClassSourceMapCreateOrConnectWithoutClassInput[]
    createMany?: ClassSourceMapCreateManyClassInputEnvelope
    connect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
  }

  export type SpellLevelMapCreateNestedManyWithoutClassInput = {
    create?: XOR<SpellLevelMapCreateWithoutClassInput, SpellLevelMapUncheckedCreateWithoutClassInput> | SpellLevelMapCreateWithoutClassInput[] | SpellLevelMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SpellLevelMapCreateOrConnectWithoutClassInput | SpellLevelMapCreateOrConnectWithoutClassInput[]
    createMany?: SpellLevelMapCreateManyClassInputEnvelope
    connect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
  }

  export type ClassFeatureUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput> | ClassFeatureCreateWithoutClassInput[] | ClassFeatureUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutClassInput | ClassFeatureCreateOrConnectWithoutClassInput[]
    createMany?: ClassFeatureCreateManyClassInputEnvelope
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
  }

  export type ClassLevelAttributeUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassLevelAttributeCreateWithoutClassInput, ClassLevelAttributeUncheckedCreateWithoutClassInput> | ClassLevelAttributeCreateWithoutClassInput[] | ClassLevelAttributeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassLevelAttributeCreateOrConnectWithoutClassInput | ClassLevelAttributeCreateOrConnectWithoutClassInput[]
    createMany?: ClassLevelAttributeCreateManyClassInputEnvelope
    connect?: ClassLevelAttributeWhereUniqueInput | ClassLevelAttributeWhereUniqueInput[]
  }

  export type ClassSpellLevelUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSpellLevelCreateWithoutClassInput, ClassSpellLevelUncheckedCreateWithoutClassInput> | ClassSpellLevelCreateWithoutClassInput[] | ClassSpellLevelUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSpellLevelCreateOrConnectWithoutClassInput | ClassSpellLevelCreateOrConnectWithoutClassInput[]
    createMany?: ClassSpellLevelCreateManyClassInputEnvelope
    connect?: ClassSpellLevelWhereUniqueInput | ClassSpellLevelWhereUniqueInput[]
  }

  export type ClassSkillMapUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSkillMapCreateWithoutClassInput, ClassSkillMapUncheckedCreateWithoutClassInput> | ClassSkillMapCreateWithoutClassInput[] | ClassSkillMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSkillMapCreateOrConnectWithoutClassInput | ClassSkillMapCreateOrConnectWithoutClassInput[]
    createMany?: ClassSkillMapCreateManyClassInputEnvelope
    connect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
  }

  export type ClassSourceMapUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSourceMapCreateWithoutClassInput, ClassSourceMapUncheckedCreateWithoutClassInput> | ClassSourceMapCreateWithoutClassInput[] | ClassSourceMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSourceMapCreateOrConnectWithoutClassInput | ClassSourceMapCreateOrConnectWithoutClassInput[]
    createMany?: ClassSourceMapCreateManyClassInputEnvelope
    connect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
  }

  export type SpellLevelMapUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<SpellLevelMapCreateWithoutClassInput, SpellLevelMapUncheckedCreateWithoutClassInput> | SpellLevelMapCreateWithoutClassInput[] | SpellLevelMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SpellLevelMapCreateOrConnectWithoutClassInput | SpellLevelMapCreateOrConnectWithoutClassInput[]
    createMany?: SpellLevelMapCreateManyClassInputEnvelope
    connect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ClassFeatureUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput> | ClassFeatureCreateWithoutClassInput[] | ClassFeatureUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutClassInput | ClassFeatureCreateOrConnectWithoutClassInput[]
    upsert?: ClassFeatureUpsertWithWhereUniqueWithoutClassInput | ClassFeatureUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassFeatureCreateManyClassInputEnvelope
    set?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    disconnect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    delete?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    update?: ClassFeatureUpdateWithWhereUniqueWithoutClassInput | ClassFeatureUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassFeatureUpdateManyWithWhereWithoutClassInput | ClassFeatureUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassFeatureScalarWhereInput | ClassFeatureScalarWhereInput[]
  }

  export type ClassLevelAttributeUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassLevelAttributeCreateWithoutClassInput, ClassLevelAttributeUncheckedCreateWithoutClassInput> | ClassLevelAttributeCreateWithoutClassInput[] | ClassLevelAttributeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassLevelAttributeCreateOrConnectWithoutClassInput | ClassLevelAttributeCreateOrConnectWithoutClassInput[]
    upsert?: ClassLevelAttributeUpsertWithWhereUniqueWithoutClassInput | ClassLevelAttributeUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassLevelAttributeCreateManyClassInputEnvelope
    set?: ClassLevelAttributeWhereUniqueInput | ClassLevelAttributeWhereUniqueInput[]
    disconnect?: ClassLevelAttributeWhereUniqueInput | ClassLevelAttributeWhereUniqueInput[]
    delete?: ClassLevelAttributeWhereUniqueInput | ClassLevelAttributeWhereUniqueInput[]
    connect?: ClassLevelAttributeWhereUniqueInput | ClassLevelAttributeWhereUniqueInput[]
    update?: ClassLevelAttributeUpdateWithWhereUniqueWithoutClassInput | ClassLevelAttributeUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassLevelAttributeUpdateManyWithWhereWithoutClassInput | ClassLevelAttributeUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassLevelAttributeScalarWhereInput | ClassLevelAttributeScalarWhereInput[]
  }

  export type ClassSpellLevelUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSpellLevelCreateWithoutClassInput, ClassSpellLevelUncheckedCreateWithoutClassInput> | ClassSpellLevelCreateWithoutClassInput[] | ClassSpellLevelUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSpellLevelCreateOrConnectWithoutClassInput | ClassSpellLevelCreateOrConnectWithoutClassInput[]
    upsert?: ClassSpellLevelUpsertWithWhereUniqueWithoutClassInput | ClassSpellLevelUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSpellLevelCreateManyClassInputEnvelope
    set?: ClassSpellLevelWhereUniqueInput | ClassSpellLevelWhereUniqueInput[]
    disconnect?: ClassSpellLevelWhereUniqueInput | ClassSpellLevelWhereUniqueInput[]
    delete?: ClassSpellLevelWhereUniqueInput | ClassSpellLevelWhereUniqueInput[]
    connect?: ClassSpellLevelWhereUniqueInput | ClassSpellLevelWhereUniqueInput[]
    update?: ClassSpellLevelUpdateWithWhereUniqueWithoutClassInput | ClassSpellLevelUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSpellLevelUpdateManyWithWhereWithoutClassInput | ClassSpellLevelUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSpellLevelScalarWhereInput | ClassSpellLevelScalarWhereInput[]
  }

  export type ClassSkillMapUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSkillMapCreateWithoutClassInput, ClassSkillMapUncheckedCreateWithoutClassInput> | ClassSkillMapCreateWithoutClassInput[] | ClassSkillMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSkillMapCreateOrConnectWithoutClassInput | ClassSkillMapCreateOrConnectWithoutClassInput[]
    upsert?: ClassSkillMapUpsertWithWhereUniqueWithoutClassInput | ClassSkillMapUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSkillMapCreateManyClassInputEnvelope
    set?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    disconnect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    delete?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    connect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    update?: ClassSkillMapUpdateWithWhereUniqueWithoutClassInput | ClassSkillMapUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSkillMapUpdateManyWithWhereWithoutClassInput | ClassSkillMapUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSkillMapScalarWhereInput | ClassSkillMapScalarWhereInput[]
  }

  export type ClassSourceMapUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSourceMapCreateWithoutClassInput, ClassSourceMapUncheckedCreateWithoutClassInput> | ClassSourceMapCreateWithoutClassInput[] | ClassSourceMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSourceMapCreateOrConnectWithoutClassInput | ClassSourceMapCreateOrConnectWithoutClassInput[]
    upsert?: ClassSourceMapUpsertWithWhereUniqueWithoutClassInput | ClassSourceMapUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSourceMapCreateManyClassInputEnvelope
    set?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    disconnect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    delete?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    connect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    update?: ClassSourceMapUpdateWithWhereUniqueWithoutClassInput | ClassSourceMapUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSourceMapUpdateManyWithWhereWithoutClassInput | ClassSourceMapUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSourceMapScalarWhereInput | ClassSourceMapScalarWhereInput[]
  }

  export type SpellLevelMapUpdateManyWithoutClassNestedInput = {
    create?: XOR<SpellLevelMapCreateWithoutClassInput, SpellLevelMapUncheckedCreateWithoutClassInput> | SpellLevelMapCreateWithoutClassInput[] | SpellLevelMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SpellLevelMapCreateOrConnectWithoutClassInput | SpellLevelMapCreateOrConnectWithoutClassInput[]
    upsert?: SpellLevelMapUpsertWithWhereUniqueWithoutClassInput | SpellLevelMapUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SpellLevelMapCreateManyClassInputEnvelope
    set?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    disconnect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    delete?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    connect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    update?: SpellLevelMapUpdateWithWhereUniqueWithoutClassInput | SpellLevelMapUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SpellLevelMapUpdateManyWithWhereWithoutClassInput | SpellLevelMapUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SpellLevelMapScalarWhereInput | SpellLevelMapScalarWhereInput[]
  }

  export type ClassFeatureUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput> | ClassFeatureCreateWithoutClassInput[] | ClassFeatureUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutClassInput | ClassFeatureCreateOrConnectWithoutClassInput[]
    upsert?: ClassFeatureUpsertWithWhereUniqueWithoutClassInput | ClassFeatureUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassFeatureCreateManyClassInputEnvelope
    set?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    disconnect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    delete?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    update?: ClassFeatureUpdateWithWhereUniqueWithoutClassInput | ClassFeatureUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassFeatureUpdateManyWithWhereWithoutClassInput | ClassFeatureUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassFeatureScalarWhereInput | ClassFeatureScalarWhereInput[]
  }

  export type ClassLevelAttributeUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassLevelAttributeCreateWithoutClassInput, ClassLevelAttributeUncheckedCreateWithoutClassInput> | ClassLevelAttributeCreateWithoutClassInput[] | ClassLevelAttributeUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassLevelAttributeCreateOrConnectWithoutClassInput | ClassLevelAttributeCreateOrConnectWithoutClassInput[]
    upsert?: ClassLevelAttributeUpsertWithWhereUniqueWithoutClassInput | ClassLevelAttributeUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassLevelAttributeCreateManyClassInputEnvelope
    set?: ClassLevelAttributeWhereUniqueInput | ClassLevelAttributeWhereUniqueInput[]
    disconnect?: ClassLevelAttributeWhereUniqueInput | ClassLevelAttributeWhereUniqueInput[]
    delete?: ClassLevelAttributeWhereUniqueInput | ClassLevelAttributeWhereUniqueInput[]
    connect?: ClassLevelAttributeWhereUniqueInput | ClassLevelAttributeWhereUniqueInput[]
    update?: ClassLevelAttributeUpdateWithWhereUniqueWithoutClassInput | ClassLevelAttributeUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassLevelAttributeUpdateManyWithWhereWithoutClassInput | ClassLevelAttributeUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassLevelAttributeScalarWhereInput | ClassLevelAttributeScalarWhereInput[]
  }

  export type ClassSpellLevelUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSpellLevelCreateWithoutClassInput, ClassSpellLevelUncheckedCreateWithoutClassInput> | ClassSpellLevelCreateWithoutClassInput[] | ClassSpellLevelUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSpellLevelCreateOrConnectWithoutClassInput | ClassSpellLevelCreateOrConnectWithoutClassInput[]
    upsert?: ClassSpellLevelUpsertWithWhereUniqueWithoutClassInput | ClassSpellLevelUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSpellLevelCreateManyClassInputEnvelope
    set?: ClassSpellLevelWhereUniqueInput | ClassSpellLevelWhereUniqueInput[]
    disconnect?: ClassSpellLevelWhereUniqueInput | ClassSpellLevelWhereUniqueInput[]
    delete?: ClassSpellLevelWhereUniqueInput | ClassSpellLevelWhereUniqueInput[]
    connect?: ClassSpellLevelWhereUniqueInput | ClassSpellLevelWhereUniqueInput[]
    update?: ClassSpellLevelUpdateWithWhereUniqueWithoutClassInput | ClassSpellLevelUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSpellLevelUpdateManyWithWhereWithoutClassInput | ClassSpellLevelUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSpellLevelScalarWhereInput | ClassSpellLevelScalarWhereInput[]
  }

  export type ClassSkillMapUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSkillMapCreateWithoutClassInput, ClassSkillMapUncheckedCreateWithoutClassInput> | ClassSkillMapCreateWithoutClassInput[] | ClassSkillMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSkillMapCreateOrConnectWithoutClassInput | ClassSkillMapCreateOrConnectWithoutClassInput[]
    upsert?: ClassSkillMapUpsertWithWhereUniqueWithoutClassInput | ClassSkillMapUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSkillMapCreateManyClassInputEnvelope
    set?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    disconnect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    delete?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    connect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    update?: ClassSkillMapUpdateWithWhereUniqueWithoutClassInput | ClassSkillMapUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSkillMapUpdateManyWithWhereWithoutClassInput | ClassSkillMapUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSkillMapScalarWhereInput | ClassSkillMapScalarWhereInput[]
  }

  export type ClassSourceMapUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSourceMapCreateWithoutClassInput, ClassSourceMapUncheckedCreateWithoutClassInput> | ClassSourceMapCreateWithoutClassInput[] | ClassSourceMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSourceMapCreateOrConnectWithoutClassInput | ClassSourceMapCreateOrConnectWithoutClassInput[]
    upsert?: ClassSourceMapUpsertWithWhereUniqueWithoutClassInput | ClassSourceMapUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSourceMapCreateManyClassInputEnvelope
    set?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    disconnect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    delete?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    connect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    update?: ClassSourceMapUpdateWithWhereUniqueWithoutClassInput | ClassSourceMapUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSourceMapUpdateManyWithWhereWithoutClassInput | ClassSourceMapUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSourceMapScalarWhereInput | ClassSourceMapScalarWhereInput[]
  }

  export type SpellLevelMapUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<SpellLevelMapCreateWithoutClassInput, SpellLevelMapUncheckedCreateWithoutClassInput> | SpellLevelMapCreateWithoutClassInput[] | SpellLevelMapUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SpellLevelMapCreateOrConnectWithoutClassInput | SpellLevelMapCreateOrConnectWithoutClassInput[]
    upsert?: SpellLevelMapUpsertWithWhereUniqueWithoutClassInput | SpellLevelMapUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SpellLevelMapCreateManyClassInputEnvelope
    set?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    disconnect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    delete?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    connect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    update?: SpellLevelMapUpdateWithWhereUniqueWithoutClassInput | SpellLevelMapUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SpellLevelMapUpdateManyWithWhereWithoutClassInput | SpellLevelMapUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SpellLevelMapScalarWhereInput | SpellLevelMapScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<ClassCreateWithoutFeaturesInput, ClassUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutFeaturesInput
    connect?: ClassWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<ClassCreateWithoutFeaturesInput, ClassUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutFeaturesInput
    upsert?: ClassUpsertWithoutFeaturesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutFeaturesInput, ClassUpdateWithoutFeaturesInput>, ClassUncheckedUpdateWithoutFeaturesInput>
  }

  export type ClassCreateNestedOneWithoutSpellProgressionInput = {
    create?: XOR<ClassCreateWithoutSpellProgressionInput, ClassUncheckedCreateWithoutSpellProgressionInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSpellProgressionInput
    connect?: ClassWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutSpellProgressionNestedInput = {
    create?: XOR<ClassCreateWithoutSpellProgressionInput, ClassUncheckedCreateWithoutSpellProgressionInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSpellProgressionInput
    upsert?: ClassUpsertWithoutSpellProgressionInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSpellProgressionInput, ClassUpdateWithoutSpellProgressionInput>, ClassUncheckedUpdateWithoutSpellProgressionInput>
  }

  export type ClassCreateNestedOneWithoutAttributesInput = {
    create?: XOR<ClassCreateWithoutAttributesInput, ClassUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAttributesInput
    connect?: ClassWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutAttributesNestedInput = {
    create?: XOR<ClassCreateWithoutAttributesInput, ClassUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAttributesInput
    upsert?: ClassUpsertWithoutAttributesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutAttributesInput, ClassUpdateWithoutAttributesInput>, ClassUncheckedUpdateWithoutAttributesInput>
  }

  export type ClassCreateNestedOneWithoutSkillsInput = {
    create?: XOR<ClassCreateWithoutSkillsInput, ClassUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSkillsInput
    connect?: ClassWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutClassesInput = {
    create?: XOR<SkillCreateWithoutClassesInput, SkillUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SkillCreateOrConnectWithoutClassesInput
    connect?: SkillWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<ClassCreateWithoutSkillsInput, ClassUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSkillsInput
    upsert?: ClassUpsertWithoutSkillsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSkillsInput, ClassUpdateWithoutSkillsInput>, ClassUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<SkillCreateWithoutClassesInput, SkillUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SkillCreateOrConnectWithoutClassesInput
    upsert?: SkillUpsertWithoutClassesInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutClassesInput, SkillUpdateWithoutClassesInput>, SkillUncheckedUpdateWithoutClassesInput>
  }

  export type ClassCreateNestedOneWithoutSourcesInput = {
    create?: XOR<ClassCreateWithoutSourcesInput, ClassUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSourcesInput
    connect?: ClassWhereUniqueInput
  }

  export type SourceBookCreateNestedOneWithoutClassesInput = {
    create?: XOR<SourceBookCreateWithoutClassesInput, SourceBookUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SourceBookCreateOrConnectWithoutClassesInput
    connect?: SourceBookWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutSourcesNestedInput = {
    create?: XOR<ClassCreateWithoutSourcesInput, ClassUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSourcesInput
    upsert?: ClassUpsertWithoutSourcesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSourcesInput, ClassUpdateWithoutSourcesInput>, ClassUncheckedUpdateWithoutSourcesInput>
  }

  export type SourceBookUpdateOneWithoutClassesNestedInput = {
    create?: XOR<SourceBookCreateWithoutClassesInput, SourceBookUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SourceBookCreateOrConnectWithoutClassesInput
    upsert?: SourceBookUpsertWithoutClassesInput
    disconnect?: SourceBookWhereInput | boolean
    delete?: SourceBookWhereInput | boolean
    connect?: SourceBookWhereUniqueInput
    update?: XOR<XOR<SourceBookUpdateToOneWithWhereWithoutClassesInput, SourceBookUpdateWithoutClassesInput>, SourceBookUncheckedUpdateWithoutClassesInput>
  }

  export type SpellCreateNestedOneWithoutLevelMappingInput = {
    create?: XOR<SpellCreateWithoutLevelMappingInput, SpellUncheckedCreateWithoutLevelMappingInput>
    connectOrCreate?: SpellCreateOrConnectWithoutLevelMappingInput
    connect?: SpellWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutSpellLevelsInput = {
    create?: XOR<ClassCreateWithoutSpellLevelsInput, ClassUncheckedCreateWithoutSpellLevelsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSpellLevelsInput
    connect?: ClassWhereUniqueInput
  }

  export type SpellUpdateOneRequiredWithoutLevelMappingNestedInput = {
    create?: XOR<SpellCreateWithoutLevelMappingInput, SpellUncheckedCreateWithoutLevelMappingInput>
    connectOrCreate?: SpellCreateOrConnectWithoutLevelMappingInput
    upsert?: SpellUpsertWithoutLevelMappingInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutLevelMappingInput, SpellUpdateWithoutLevelMappingInput>, SpellUncheckedUpdateWithoutLevelMappingInput>
  }

  export type ClassUpdateOneRequiredWithoutSpellLevelsNestedInput = {
    create?: XOR<ClassCreateWithoutSpellLevelsInput, ClassUncheckedCreateWithoutSpellLevelsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSpellLevelsInput
    upsert?: ClassUpsertWithoutSpellLevelsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSpellLevelsInput, ClassUpdateWithoutSpellLevelsInput>, ClassUncheckedUpdateWithoutSpellLevelsInput>
  }

  export type SpellDescriptorMapCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellDescriptorMapCreateWithoutSpellInput, SpellDescriptorMapUncheckedCreateWithoutSpellInput> | SpellDescriptorMapCreateWithoutSpellInput[] | SpellDescriptorMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellDescriptorMapCreateOrConnectWithoutSpellInput | SpellDescriptorMapCreateOrConnectWithoutSpellInput[]
    createMany?: SpellDescriptorMapCreateManySpellInputEnvelope
    connect?: SpellDescriptorMapWhereUniqueInput | SpellDescriptorMapWhereUniqueInput[]
  }

  export type SpellLevelMapCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellLevelMapCreateWithoutSpellInput, SpellLevelMapUncheckedCreateWithoutSpellInput> | SpellLevelMapCreateWithoutSpellInput[] | SpellLevelMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellLevelMapCreateOrConnectWithoutSpellInput | SpellLevelMapCreateOrConnectWithoutSpellInput[]
    createMany?: SpellLevelMapCreateManySpellInputEnvelope
    connect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
  }

  export type SpellSchoolMapCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellSchoolMapCreateWithoutSpellInput, SpellSchoolMapUncheckedCreateWithoutSpellInput> | SpellSchoolMapCreateWithoutSpellInput[] | SpellSchoolMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSchoolMapCreateOrConnectWithoutSpellInput | SpellSchoolMapCreateOrConnectWithoutSpellInput[]
    createMany?: SpellSchoolMapCreateManySpellInputEnvelope
    connect?: SpellSchoolMapWhereUniqueInput | SpellSchoolMapWhereUniqueInput[]
  }

  export type SpellSourceMapCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellSourceMapCreateWithoutSpellInput, SpellSourceMapUncheckedCreateWithoutSpellInput> | SpellSourceMapCreateWithoutSpellInput[] | SpellSourceMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSourceMapCreateOrConnectWithoutSpellInput | SpellSourceMapCreateOrConnectWithoutSpellInput[]
    createMany?: SpellSourceMapCreateManySpellInputEnvelope
    connect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
  }

  export type SpellSubschoolMapCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellSubschoolMapCreateWithoutSpellInput, SpellSubschoolMapUncheckedCreateWithoutSpellInput> | SpellSubschoolMapCreateWithoutSpellInput[] | SpellSubschoolMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSubschoolMapCreateOrConnectWithoutSpellInput | SpellSubschoolMapCreateOrConnectWithoutSpellInput[]
    createMany?: SpellSubschoolMapCreateManySpellInputEnvelope
    connect?: SpellSubschoolMapWhereUniqueInput | SpellSubschoolMapWhereUniqueInput[]
  }

  export type SpellDescriptorMapUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellDescriptorMapCreateWithoutSpellInput, SpellDescriptorMapUncheckedCreateWithoutSpellInput> | SpellDescriptorMapCreateWithoutSpellInput[] | SpellDescriptorMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellDescriptorMapCreateOrConnectWithoutSpellInput | SpellDescriptorMapCreateOrConnectWithoutSpellInput[]
    createMany?: SpellDescriptorMapCreateManySpellInputEnvelope
    connect?: SpellDescriptorMapWhereUniqueInput | SpellDescriptorMapWhereUniqueInput[]
  }

  export type SpellLevelMapUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellLevelMapCreateWithoutSpellInput, SpellLevelMapUncheckedCreateWithoutSpellInput> | SpellLevelMapCreateWithoutSpellInput[] | SpellLevelMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellLevelMapCreateOrConnectWithoutSpellInput | SpellLevelMapCreateOrConnectWithoutSpellInput[]
    createMany?: SpellLevelMapCreateManySpellInputEnvelope
    connect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
  }

  export type SpellSchoolMapUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellSchoolMapCreateWithoutSpellInput, SpellSchoolMapUncheckedCreateWithoutSpellInput> | SpellSchoolMapCreateWithoutSpellInput[] | SpellSchoolMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSchoolMapCreateOrConnectWithoutSpellInput | SpellSchoolMapCreateOrConnectWithoutSpellInput[]
    createMany?: SpellSchoolMapCreateManySpellInputEnvelope
    connect?: SpellSchoolMapWhereUniqueInput | SpellSchoolMapWhereUniqueInput[]
  }

  export type SpellSourceMapUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellSourceMapCreateWithoutSpellInput, SpellSourceMapUncheckedCreateWithoutSpellInput> | SpellSourceMapCreateWithoutSpellInput[] | SpellSourceMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSourceMapCreateOrConnectWithoutSpellInput | SpellSourceMapCreateOrConnectWithoutSpellInput[]
    createMany?: SpellSourceMapCreateManySpellInputEnvelope
    connect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
  }

  export type SpellSubschoolMapUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellSubschoolMapCreateWithoutSpellInput, SpellSubschoolMapUncheckedCreateWithoutSpellInput> | SpellSubschoolMapCreateWithoutSpellInput[] | SpellSubschoolMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSubschoolMapCreateOrConnectWithoutSpellInput | SpellSubschoolMapCreateOrConnectWithoutSpellInput[]
    createMany?: SpellSubschoolMapCreateManySpellInputEnvelope
    connect?: SpellSubschoolMapWhereUniqueInput | SpellSubschoolMapWhereUniqueInput[]
  }

  export type SpellDescriptorMapUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellDescriptorMapCreateWithoutSpellInput, SpellDescriptorMapUncheckedCreateWithoutSpellInput> | SpellDescriptorMapCreateWithoutSpellInput[] | SpellDescriptorMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellDescriptorMapCreateOrConnectWithoutSpellInput | SpellDescriptorMapCreateOrConnectWithoutSpellInput[]
    upsert?: SpellDescriptorMapUpsertWithWhereUniqueWithoutSpellInput | SpellDescriptorMapUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellDescriptorMapCreateManySpellInputEnvelope
    set?: SpellDescriptorMapWhereUniqueInput | SpellDescriptorMapWhereUniqueInput[]
    disconnect?: SpellDescriptorMapWhereUniqueInput | SpellDescriptorMapWhereUniqueInput[]
    delete?: SpellDescriptorMapWhereUniqueInput | SpellDescriptorMapWhereUniqueInput[]
    connect?: SpellDescriptorMapWhereUniqueInput | SpellDescriptorMapWhereUniqueInput[]
    update?: SpellDescriptorMapUpdateWithWhereUniqueWithoutSpellInput | SpellDescriptorMapUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellDescriptorMapUpdateManyWithWhereWithoutSpellInput | SpellDescriptorMapUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellDescriptorMapScalarWhereInput | SpellDescriptorMapScalarWhereInput[]
  }

  export type SpellLevelMapUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellLevelMapCreateWithoutSpellInput, SpellLevelMapUncheckedCreateWithoutSpellInput> | SpellLevelMapCreateWithoutSpellInput[] | SpellLevelMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellLevelMapCreateOrConnectWithoutSpellInput | SpellLevelMapCreateOrConnectWithoutSpellInput[]
    upsert?: SpellLevelMapUpsertWithWhereUniqueWithoutSpellInput | SpellLevelMapUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellLevelMapCreateManySpellInputEnvelope
    set?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    disconnect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    delete?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    connect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    update?: SpellLevelMapUpdateWithWhereUniqueWithoutSpellInput | SpellLevelMapUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellLevelMapUpdateManyWithWhereWithoutSpellInput | SpellLevelMapUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellLevelMapScalarWhereInput | SpellLevelMapScalarWhereInput[]
  }

  export type SpellSchoolMapUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellSchoolMapCreateWithoutSpellInput, SpellSchoolMapUncheckedCreateWithoutSpellInput> | SpellSchoolMapCreateWithoutSpellInput[] | SpellSchoolMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSchoolMapCreateOrConnectWithoutSpellInput | SpellSchoolMapCreateOrConnectWithoutSpellInput[]
    upsert?: SpellSchoolMapUpsertWithWhereUniqueWithoutSpellInput | SpellSchoolMapUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellSchoolMapCreateManySpellInputEnvelope
    set?: SpellSchoolMapWhereUniqueInput | SpellSchoolMapWhereUniqueInput[]
    disconnect?: SpellSchoolMapWhereUniqueInput | SpellSchoolMapWhereUniqueInput[]
    delete?: SpellSchoolMapWhereUniqueInput | SpellSchoolMapWhereUniqueInput[]
    connect?: SpellSchoolMapWhereUniqueInput | SpellSchoolMapWhereUniqueInput[]
    update?: SpellSchoolMapUpdateWithWhereUniqueWithoutSpellInput | SpellSchoolMapUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellSchoolMapUpdateManyWithWhereWithoutSpellInput | SpellSchoolMapUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellSchoolMapScalarWhereInput | SpellSchoolMapScalarWhereInput[]
  }

  export type SpellSourceMapUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellSourceMapCreateWithoutSpellInput, SpellSourceMapUncheckedCreateWithoutSpellInput> | SpellSourceMapCreateWithoutSpellInput[] | SpellSourceMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSourceMapCreateOrConnectWithoutSpellInput | SpellSourceMapCreateOrConnectWithoutSpellInput[]
    upsert?: SpellSourceMapUpsertWithWhereUniqueWithoutSpellInput | SpellSourceMapUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellSourceMapCreateManySpellInputEnvelope
    set?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    disconnect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    delete?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    connect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    update?: SpellSourceMapUpdateWithWhereUniqueWithoutSpellInput | SpellSourceMapUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellSourceMapUpdateManyWithWhereWithoutSpellInput | SpellSourceMapUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellSourceMapScalarWhereInput | SpellSourceMapScalarWhereInput[]
  }

  export type SpellSubschoolMapUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellSubschoolMapCreateWithoutSpellInput, SpellSubschoolMapUncheckedCreateWithoutSpellInput> | SpellSubschoolMapCreateWithoutSpellInput[] | SpellSubschoolMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSubschoolMapCreateOrConnectWithoutSpellInput | SpellSubschoolMapCreateOrConnectWithoutSpellInput[]
    upsert?: SpellSubschoolMapUpsertWithWhereUniqueWithoutSpellInput | SpellSubschoolMapUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellSubschoolMapCreateManySpellInputEnvelope
    set?: SpellSubschoolMapWhereUniqueInput | SpellSubschoolMapWhereUniqueInput[]
    disconnect?: SpellSubschoolMapWhereUniqueInput | SpellSubschoolMapWhereUniqueInput[]
    delete?: SpellSubschoolMapWhereUniqueInput | SpellSubschoolMapWhereUniqueInput[]
    connect?: SpellSubschoolMapWhereUniqueInput | SpellSubschoolMapWhereUniqueInput[]
    update?: SpellSubschoolMapUpdateWithWhereUniqueWithoutSpellInput | SpellSubschoolMapUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellSubschoolMapUpdateManyWithWhereWithoutSpellInput | SpellSubschoolMapUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellSubschoolMapScalarWhereInput | SpellSubschoolMapScalarWhereInput[]
  }

  export type SpellDescriptorMapUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellDescriptorMapCreateWithoutSpellInput, SpellDescriptorMapUncheckedCreateWithoutSpellInput> | SpellDescriptorMapCreateWithoutSpellInput[] | SpellDescriptorMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellDescriptorMapCreateOrConnectWithoutSpellInput | SpellDescriptorMapCreateOrConnectWithoutSpellInput[]
    upsert?: SpellDescriptorMapUpsertWithWhereUniqueWithoutSpellInput | SpellDescriptorMapUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellDescriptorMapCreateManySpellInputEnvelope
    set?: SpellDescriptorMapWhereUniqueInput | SpellDescriptorMapWhereUniqueInput[]
    disconnect?: SpellDescriptorMapWhereUniqueInput | SpellDescriptorMapWhereUniqueInput[]
    delete?: SpellDescriptorMapWhereUniqueInput | SpellDescriptorMapWhereUniqueInput[]
    connect?: SpellDescriptorMapWhereUniqueInput | SpellDescriptorMapWhereUniqueInput[]
    update?: SpellDescriptorMapUpdateWithWhereUniqueWithoutSpellInput | SpellDescriptorMapUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellDescriptorMapUpdateManyWithWhereWithoutSpellInput | SpellDescriptorMapUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellDescriptorMapScalarWhereInput | SpellDescriptorMapScalarWhereInput[]
  }

  export type SpellLevelMapUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellLevelMapCreateWithoutSpellInput, SpellLevelMapUncheckedCreateWithoutSpellInput> | SpellLevelMapCreateWithoutSpellInput[] | SpellLevelMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellLevelMapCreateOrConnectWithoutSpellInput | SpellLevelMapCreateOrConnectWithoutSpellInput[]
    upsert?: SpellLevelMapUpsertWithWhereUniqueWithoutSpellInput | SpellLevelMapUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellLevelMapCreateManySpellInputEnvelope
    set?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    disconnect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    delete?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    connect?: SpellLevelMapWhereUniqueInput | SpellLevelMapWhereUniqueInput[]
    update?: SpellLevelMapUpdateWithWhereUniqueWithoutSpellInput | SpellLevelMapUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellLevelMapUpdateManyWithWhereWithoutSpellInput | SpellLevelMapUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellLevelMapScalarWhereInput | SpellLevelMapScalarWhereInput[]
  }

  export type SpellSchoolMapUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellSchoolMapCreateWithoutSpellInput, SpellSchoolMapUncheckedCreateWithoutSpellInput> | SpellSchoolMapCreateWithoutSpellInput[] | SpellSchoolMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSchoolMapCreateOrConnectWithoutSpellInput | SpellSchoolMapCreateOrConnectWithoutSpellInput[]
    upsert?: SpellSchoolMapUpsertWithWhereUniqueWithoutSpellInput | SpellSchoolMapUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellSchoolMapCreateManySpellInputEnvelope
    set?: SpellSchoolMapWhereUniqueInput | SpellSchoolMapWhereUniqueInput[]
    disconnect?: SpellSchoolMapWhereUniqueInput | SpellSchoolMapWhereUniqueInput[]
    delete?: SpellSchoolMapWhereUniqueInput | SpellSchoolMapWhereUniqueInput[]
    connect?: SpellSchoolMapWhereUniqueInput | SpellSchoolMapWhereUniqueInput[]
    update?: SpellSchoolMapUpdateWithWhereUniqueWithoutSpellInput | SpellSchoolMapUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellSchoolMapUpdateManyWithWhereWithoutSpellInput | SpellSchoolMapUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellSchoolMapScalarWhereInput | SpellSchoolMapScalarWhereInput[]
  }

  export type SpellSourceMapUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellSourceMapCreateWithoutSpellInput, SpellSourceMapUncheckedCreateWithoutSpellInput> | SpellSourceMapCreateWithoutSpellInput[] | SpellSourceMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSourceMapCreateOrConnectWithoutSpellInput | SpellSourceMapCreateOrConnectWithoutSpellInput[]
    upsert?: SpellSourceMapUpsertWithWhereUniqueWithoutSpellInput | SpellSourceMapUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellSourceMapCreateManySpellInputEnvelope
    set?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    disconnect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    delete?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    connect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    update?: SpellSourceMapUpdateWithWhereUniqueWithoutSpellInput | SpellSourceMapUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellSourceMapUpdateManyWithWhereWithoutSpellInput | SpellSourceMapUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellSourceMapScalarWhereInput | SpellSourceMapScalarWhereInput[]
  }

  export type SpellSubschoolMapUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellSubschoolMapCreateWithoutSpellInput, SpellSubschoolMapUncheckedCreateWithoutSpellInput> | SpellSubschoolMapCreateWithoutSpellInput[] | SpellSubschoolMapUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSubschoolMapCreateOrConnectWithoutSpellInput | SpellSubschoolMapCreateOrConnectWithoutSpellInput[]
    upsert?: SpellSubschoolMapUpsertWithWhereUniqueWithoutSpellInput | SpellSubschoolMapUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellSubschoolMapCreateManySpellInputEnvelope
    set?: SpellSubschoolMapWhereUniqueInput | SpellSubschoolMapWhereUniqueInput[]
    disconnect?: SpellSubschoolMapWhereUniqueInput | SpellSubschoolMapWhereUniqueInput[]
    delete?: SpellSubschoolMapWhereUniqueInput | SpellSubschoolMapWhereUniqueInput[]
    connect?: SpellSubschoolMapWhereUniqueInput | SpellSubschoolMapWhereUniqueInput[]
    update?: SpellSubschoolMapUpdateWithWhereUniqueWithoutSpellInput | SpellSubschoolMapUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellSubschoolMapUpdateManyWithWhereWithoutSpellInput | SpellSubschoolMapUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellSubschoolMapScalarWhereInput | SpellSubschoolMapScalarWhereInput[]
  }

  export type SpellCreateNestedOneWithoutDescriptorsInput = {
    create?: XOR<SpellCreateWithoutDescriptorsInput, SpellUncheckedCreateWithoutDescriptorsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutDescriptorsInput
    connect?: SpellWhereUniqueInput
  }

  export type SpellUpdateOneRequiredWithoutDescriptorsNestedInput = {
    create?: XOR<SpellCreateWithoutDescriptorsInput, SpellUncheckedCreateWithoutDescriptorsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutDescriptorsInput
    upsert?: SpellUpsertWithoutDescriptorsInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutDescriptorsInput, SpellUpdateWithoutDescriptorsInput>, SpellUncheckedUpdateWithoutDescriptorsInput>
  }

  export type SpellCreateNestedOneWithoutSchoolsInput = {
    create?: XOR<SpellCreateWithoutSchoolsInput, SpellUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSchoolsInput
    connect?: SpellWhereUniqueInput
  }

  export type SpellUpdateOneRequiredWithoutSchoolsNestedInput = {
    create?: XOR<SpellCreateWithoutSchoolsInput, SpellUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSchoolsInput
    upsert?: SpellUpsertWithoutSchoolsInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutSchoolsInput, SpellUpdateWithoutSchoolsInput>, SpellUncheckedUpdateWithoutSchoolsInput>
  }

  export type SpellCreateNestedOneWithoutSourcesInput = {
    create?: XOR<SpellCreateWithoutSourcesInput, SpellUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSourcesInput
    connect?: SpellWhereUniqueInput
  }

  export type SourceBookCreateNestedOneWithoutSpellsInput = {
    create?: XOR<SourceBookCreateWithoutSpellsInput, SourceBookUncheckedCreateWithoutSpellsInput>
    connectOrCreate?: SourceBookCreateOrConnectWithoutSpellsInput
    connect?: SourceBookWhereUniqueInput
  }

  export type SpellUpdateOneRequiredWithoutSourcesNestedInput = {
    create?: XOR<SpellCreateWithoutSourcesInput, SpellUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSourcesInput
    upsert?: SpellUpsertWithoutSourcesInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutSourcesInput, SpellUpdateWithoutSourcesInput>, SpellUncheckedUpdateWithoutSourcesInput>
  }

  export type SourceBookUpdateOneWithoutSpellsNestedInput = {
    create?: XOR<SourceBookCreateWithoutSpellsInput, SourceBookUncheckedCreateWithoutSpellsInput>
    connectOrCreate?: SourceBookCreateOrConnectWithoutSpellsInput
    upsert?: SourceBookUpsertWithoutSpellsInput
    disconnect?: SourceBookWhereInput | boolean
    delete?: SourceBookWhereInput | boolean
    connect?: SourceBookWhereUniqueInput
    update?: XOR<XOR<SourceBookUpdateToOneWithWhereWithoutSpellsInput, SourceBookUpdateWithoutSpellsInput>, SourceBookUncheckedUpdateWithoutSpellsInput>
  }

  export type SpellCreateNestedOneWithoutSubschoolsInput = {
    create?: XOR<SpellCreateWithoutSubschoolsInput, SpellUncheckedCreateWithoutSubschoolsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSubschoolsInput
    connect?: SpellWhereUniqueInput
  }

  export type SpellUpdateOneRequiredWithoutSubschoolsNestedInput = {
    create?: XOR<SpellCreateWithoutSubschoolsInput, SpellUncheckedCreateWithoutSubschoolsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSubschoolsInput
    upsert?: SpellUpsertWithoutSubschoolsInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutSubschoolsInput, SpellUpdateWithoutSubschoolsInput>, SpellUncheckedUpdateWithoutSubschoolsInput>
  }

  export type ClassSkillMapCreateNestedManyWithoutSkillInput = {
    create?: XOR<ClassSkillMapCreateWithoutSkillInput, ClassSkillMapUncheckedCreateWithoutSkillInput> | ClassSkillMapCreateWithoutSkillInput[] | ClassSkillMapUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ClassSkillMapCreateOrConnectWithoutSkillInput | ClassSkillMapCreateOrConnectWithoutSkillInput[]
    createMany?: ClassSkillMapCreateManySkillInputEnvelope
    connect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
  }

  export type ClassSkillMapUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<ClassSkillMapCreateWithoutSkillInput, ClassSkillMapUncheckedCreateWithoutSkillInput> | ClassSkillMapCreateWithoutSkillInput[] | ClassSkillMapUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ClassSkillMapCreateOrConnectWithoutSkillInput | ClassSkillMapCreateOrConnectWithoutSkillInput[]
    createMany?: ClassSkillMapCreateManySkillInputEnvelope
    connect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ClassSkillMapUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ClassSkillMapCreateWithoutSkillInput, ClassSkillMapUncheckedCreateWithoutSkillInput> | ClassSkillMapCreateWithoutSkillInput[] | ClassSkillMapUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ClassSkillMapCreateOrConnectWithoutSkillInput | ClassSkillMapCreateOrConnectWithoutSkillInput[]
    upsert?: ClassSkillMapUpsertWithWhereUniqueWithoutSkillInput | ClassSkillMapUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ClassSkillMapCreateManySkillInputEnvelope
    set?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    disconnect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    delete?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    connect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    update?: ClassSkillMapUpdateWithWhereUniqueWithoutSkillInput | ClassSkillMapUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ClassSkillMapUpdateManyWithWhereWithoutSkillInput | ClassSkillMapUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ClassSkillMapScalarWhereInput | ClassSkillMapScalarWhereInput[]
  }

  export type ClassSkillMapUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ClassSkillMapCreateWithoutSkillInput, ClassSkillMapUncheckedCreateWithoutSkillInput> | ClassSkillMapCreateWithoutSkillInput[] | ClassSkillMapUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ClassSkillMapCreateOrConnectWithoutSkillInput | ClassSkillMapCreateOrConnectWithoutSkillInput[]
    upsert?: ClassSkillMapUpsertWithWhereUniqueWithoutSkillInput | ClassSkillMapUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ClassSkillMapCreateManySkillInputEnvelope
    set?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    disconnect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    delete?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    connect?: ClassSkillMapWhereUniqueInput | ClassSkillMapWhereUniqueInput[]
    update?: ClassSkillMapUpdateWithWhereUniqueWithoutSkillInput | ClassSkillMapUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ClassSkillMapUpdateManyWithWhereWithoutSkillInput | ClassSkillMapUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ClassSkillMapScalarWhereInput | ClassSkillMapScalarWhereInput[]
  }

  export type FeatBenefitMapCreateNestedManyWithoutFeatInput = {
    create?: XOR<FeatBenefitMapCreateWithoutFeatInput, FeatBenefitMapUncheckedCreateWithoutFeatInput> | FeatBenefitMapCreateWithoutFeatInput[] | FeatBenefitMapUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatBenefitMapCreateOrConnectWithoutFeatInput | FeatBenefitMapCreateOrConnectWithoutFeatInput[]
    createMany?: FeatBenefitMapCreateManyFeatInputEnvelope
    connect?: FeatBenefitMapWhereUniqueInput | FeatBenefitMapWhereUniqueInput[]
  }

  export type FeatPrerequisiteMapCreateNestedManyWithoutFeatInput = {
    create?: XOR<FeatPrerequisiteMapCreateWithoutFeatInput, FeatPrerequisiteMapUncheckedCreateWithoutFeatInput> | FeatPrerequisiteMapCreateWithoutFeatInput[] | FeatPrerequisiteMapUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatPrerequisiteMapCreateOrConnectWithoutFeatInput | FeatPrerequisiteMapCreateOrConnectWithoutFeatInput[]
    createMany?: FeatPrerequisiteMapCreateManyFeatInputEnvelope
    connect?: FeatPrerequisiteMapWhereUniqueInput | FeatPrerequisiteMapWhereUniqueInput[]
  }

  export type FeatBenefitMapUncheckedCreateNestedManyWithoutFeatInput = {
    create?: XOR<FeatBenefitMapCreateWithoutFeatInput, FeatBenefitMapUncheckedCreateWithoutFeatInput> | FeatBenefitMapCreateWithoutFeatInput[] | FeatBenefitMapUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatBenefitMapCreateOrConnectWithoutFeatInput | FeatBenefitMapCreateOrConnectWithoutFeatInput[]
    createMany?: FeatBenefitMapCreateManyFeatInputEnvelope
    connect?: FeatBenefitMapWhereUniqueInput | FeatBenefitMapWhereUniqueInput[]
  }

  export type FeatPrerequisiteMapUncheckedCreateNestedManyWithoutFeatInput = {
    create?: XOR<FeatPrerequisiteMapCreateWithoutFeatInput, FeatPrerequisiteMapUncheckedCreateWithoutFeatInput> | FeatPrerequisiteMapCreateWithoutFeatInput[] | FeatPrerequisiteMapUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatPrerequisiteMapCreateOrConnectWithoutFeatInput | FeatPrerequisiteMapCreateOrConnectWithoutFeatInput[]
    createMany?: FeatPrerequisiteMapCreateManyFeatInputEnvelope
    connect?: FeatPrerequisiteMapWhereUniqueInput | FeatPrerequisiteMapWhereUniqueInput[]
  }

  export type FeatBenefitMapUpdateManyWithoutFeatNestedInput = {
    create?: XOR<FeatBenefitMapCreateWithoutFeatInput, FeatBenefitMapUncheckedCreateWithoutFeatInput> | FeatBenefitMapCreateWithoutFeatInput[] | FeatBenefitMapUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatBenefitMapCreateOrConnectWithoutFeatInput | FeatBenefitMapCreateOrConnectWithoutFeatInput[]
    upsert?: FeatBenefitMapUpsertWithWhereUniqueWithoutFeatInput | FeatBenefitMapUpsertWithWhereUniqueWithoutFeatInput[]
    createMany?: FeatBenefitMapCreateManyFeatInputEnvelope
    set?: FeatBenefitMapWhereUniqueInput | FeatBenefitMapWhereUniqueInput[]
    disconnect?: FeatBenefitMapWhereUniqueInput | FeatBenefitMapWhereUniqueInput[]
    delete?: FeatBenefitMapWhereUniqueInput | FeatBenefitMapWhereUniqueInput[]
    connect?: FeatBenefitMapWhereUniqueInput | FeatBenefitMapWhereUniqueInput[]
    update?: FeatBenefitMapUpdateWithWhereUniqueWithoutFeatInput | FeatBenefitMapUpdateWithWhereUniqueWithoutFeatInput[]
    updateMany?: FeatBenefitMapUpdateManyWithWhereWithoutFeatInput | FeatBenefitMapUpdateManyWithWhereWithoutFeatInput[]
    deleteMany?: FeatBenefitMapScalarWhereInput | FeatBenefitMapScalarWhereInput[]
  }

  export type FeatPrerequisiteMapUpdateManyWithoutFeatNestedInput = {
    create?: XOR<FeatPrerequisiteMapCreateWithoutFeatInput, FeatPrerequisiteMapUncheckedCreateWithoutFeatInput> | FeatPrerequisiteMapCreateWithoutFeatInput[] | FeatPrerequisiteMapUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatPrerequisiteMapCreateOrConnectWithoutFeatInput | FeatPrerequisiteMapCreateOrConnectWithoutFeatInput[]
    upsert?: FeatPrerequisiteMapUpsertWithWhereUniqueWithoutFeatInput | FeatPrerequisiteMapUpsertWithWhereUniqueWithoutFeatInput[]
    createMany?: FeatPrerequisiteMapCreateManyFeatInputEnvelope
    set?: FeatPrerequisiteMapWhereUniqueInput | FeatPrerequisiteMapWhereUniqueInput[]
    disconnect?: FeatPrerequisiteMapWhereUniqueInput | FeatPrerequisiteMapWhereUniqueInput[]
    delete?: FeatPrerequisiteMapWhereUniqueInput | FeatPrerequisiteMapWhereUniqueInput[]
    connect?: FeatPrerequisiteMapWhereUniqueInput | FeatPrerequisiteMapWhereUniqueInput[]
    update?: FeatPrerequisiteMapUpdateWithWhereUniqueWithoutFeatInput | FeatPrerequisiteMapUpdateWithWhereUniqueWithoutFeatInput[]
    updateMany?: FeatPrerequisiteMapUpdateManyWithWhereWithoutFeatInput | FeatPrerequisiteMapUpdateManyWithWhereWithoutFeatInput[]
    deleteMany?: FeatPrerequisiteMapScalarWhereInput | FeatPrerequisiteMapScalarWhereInput[]
  }

  export type FeatBenefitMapUncheckedUpdateManyWithoutFeatNestedInput = {
    create?: XOR<FeatBenefitMapCreateWithoutFeatInput, FeatBenefitMapUncheckedCreateWithoutFeatInput> | FeatBenefitMapCreateWithoutFeatInput[] | FeatBenefitMapUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatBenefitMapCreateOrConnectWithoutFeatInput | FeatBenefitMapCreateOrConnectWithoutFeatInput[]
    upsert?: FeatBenefitMapUpsertWithWhereUniqueWithoutFeatInput | FeatBenefitMapUpsertWithWhereUniqueWithoutFeatInput[]
    createMany?: FeatBenefitMapCreateManyFeatInputEnvelope
    set?: FeatBenefitMapWhereUniqueInput | FeatBenefitMapWhereUniqueInput[]
    disconnect?: FeatBenefitMapWhereUniqueInput | FeatBenefitMapWhereUniqueInput[]
    delete?: FeatBenefitMapWhereUniqueInput | FeatBenefitMapWhereUniqueInput[]
    connect?: FeatBenefitMapWhereUniqueInput | FeatBenefitMapWhereUniqueInput[]
    update?: FeatBenefitMapUpdateWithWhereUniqueWithoutFeatInput | FeatBenefitMapUpdateWithWhereUniqueWithoutFeatInput[]
    updateMany?: FeatBenefitMapUpdateManyWithWhereWithoutFeatInput | FeatBenefitMapUpdateManyWithWhereWithoutFeatInput[]
    deleteMany?: FeatBenefitMapScalarWhereInput | FeatBenefitMapScalarWhereInput[]
  }

  export type FeatPrerequisiteMapUncheckedUpdateManyWithoutFeatNestedInput = {
    create?: XOR<FeatPrerequisiteMapCreateWithoutFeatInput, FeatPrerequisiteMapUncheckedCreateWithoutFeatInput> | FeatPrerequisiteMapCreateWithoutFeatInput[] | FeatPrerequisiteMapUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatPrerequisiteMapCreateOrConnectWithoutFeatInput | FeatPrerequisiteMapCreateOrConnectWithoutFeatInput[]
    upsert?: FeatPrerequisiteMapUpsertWithWhereUniqueWithoutFeatInput | FeatPrerequisiteMapUpsertWithWhereUniqueWithoutFeatInput[]
    createMany?: FeatPrerequisiteMapCreateManyFeatInputEnvelope
    set?: FeatPrerequisiteMapWhereUniqueInput | FeatPrerequisiteMapWhereUniqueInput[]
    disconnect?: FeatPrerequisiteMapWhereUniqueInput | FeatPrerequisiteMapWhereUniqueInput[]
    delete?: FeatPrerequisiteMapWhereUniqueInput | FeatPrerequisiteMapWhereUniqueInput[]
    connect?: FeatPrerequisiteMapWhereUniqueInput | FeatPrerequisiteMapWhereUniqueInput[]
    update?: FeatPrerequisiteMapUpdateWithWhereUniqueWithoutFeatInput | FeatPrerequisiteMapUpdateWithWhereUniqueWithoutFeatInput[]
    updateMany?: FeatPrerequisiteMapUpdateManyWithWhereWithoutFeatInput | FeatPrerequisiteMapUpdateManyWithWhereWithoutFeatInput[]
    deleteMany?: FeatPrerequisiteMapScalarWhereInput | FeatPrerequisiteMapScalarWhereInput[]
  }

  export type FeatCreateNestedOneWithoutBenefitsInput = {
    create?: XOR<FeatCreateWithoutBenefitsInput, FeatUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: FeatCreateOrConnectWithoutBenefitsInput
    connect?: FeatWhereUniqueInput
  }

  export type FeatUpdateOneRequiredWithoutBenefitsNestedInput = {
    create?: XOR<FeatCreateWithoutBenefitsInput, FeatUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: FeatCreateOrConnectWithoutBenefitsInput
    upsert?: FeatUpsertWithoutBenefitsInput
    connect?: FeatWhereUniqueInput
    update?: XOR<XOR<FeatUpdateToOneWithWhereWithoutBenefitsInput, FeatUpdateWithoutBenefitsInput>, FeatUncheckedUpdateWithoutBenefitsInput>
  }

  export type FeatCreateNestedOneWithoutPrerequisitesMapInput = {
    create?: XOR<FeatCreateWithoutPrerequisitesMapInput, FeatUncheckedCreateWithoutPrerequisitesMapInput>
    connectOrCreate?: FeatCreateOrConnectWithoutPrerequisitesMapInput
    connect?: FeatWhereUniqueInput
  }

  export type FeatUpdateOneRequiredWithoutPrerequisitesMapNestedInput = {
    create?: XOR<FeatCreateWithoutPrerequisitesMapInput, FeatUncheckedCreateWithoutPrerequisitesMapInput>
    connectOrCreate?: FeatCreateOrConnectWithoutPrerequisitesMapInput
    upsert?: FeatUpsertWithoutPrerequisitesMapInput
    connect?: FeatWhereUniqueInput
    update?: XOR<XOR<FeatUpdateToOneWithWhereWithoutPrerequisitesMapInput, FeatUpdateWithoutPrerequisitesMapInput>, FeatUncheckedUpdateWithoutPrerequisitesMapInput>
  }

  export type RaceAbilityAdjustmentCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceAbilityAdjustmentCreateWithoutRaceInput, RaceAbilityAdjustmentUncheckedCreateWithoutRaceInput> | RaceAbilityAdjustmentCreateWithoutRaceInput[] | RaceAbilityAdjustmentUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceAbilityAdjustmentCreateOrConnectWithoutRaceInput | RaceAbilityAdjustmentCreateOrConnectWithoutRaceInput[]
    createMany?: RaceAbilityAdjustmentCreateManyRaceInputEnvelope
    connect?: RaceAbilityAdjustmentWhereUniqueInput | RaceAbilityAdjustmentWhereUniqueInput[]
  }

  export type RaceLanguageMapCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceLanguageMapCreateWithoutRaceInput, RaceLanguageMapUncheckedCreateWithoutRaceInput> | RaceLanguageMapCreateWithoutRaceInput[] | RaceLanguageMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceLanguageMapCreateOrConnectWithoutRaceInput | RaceLanguageMapCreateOrConnectWithoutRaceInput[]
    createMany?: RaceLanguageMapCreateManyRaceInputEnvelope
    connect?: RaceLanguageMapWhereUniqueInput | RaceLanguageMapWhereUniqueInput[]
  }

  export type RaceSourceMapCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceSourceMapCreateWithoutRaceInput, RaceSourceMapUncheckedCreateWithoutRaceInput> | RaceSourceMapCreateWithoutRaceInput[] | RaceSourceMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceSourceMapCreateOrConnectWithoutRaceInput | RaceSourceMapCreateOrConnectWithoutRaceInput[]
    createMany?: RaceSourceMapCreateManyRaceInputEnvelope
    connect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
  }

  export type RaceTraitMapCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceTraitMapCreateWithoutRaceInput, RaceTraitMapUncheckedCreateWithoutRaceInput> | RaceTraitMapCreateWithoutRaceInput[] | RaceTraitMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceTraitMapCreateOrConnectWithoutRaceInput | RaceTraitMapCreateOrConnectWithoutRaceInput[]
    createMany?: RaceTraitMapCreateManyRaceInputEnvelope
    connect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
  }

  export type UserCharacterCreateNestedManyWithoutRaceInput = {
    create?: XOR<UserCharacterCreateWithoutRaceInput, UserCharacterUncheckedCreateWithoutRaceInput> | UserCharacterCreateWithoutRaceInput[] | UserCharacterUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: UserCharacterCreateOrConnectWithoutRaceInput | UserCharacterCreateOrConnectWithoutRaceInput[]
    createMany?: UserCharacterCreateManyRaceInputEnvelope
    connect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
  }

  export type RaceAbilityAdjustmentUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceAbilityAdjustmentCreateWithoutRaceInput, RaceAbilityAdjustmentUncheckedCreateWithoutRaceInput> | RaceAbilityAdjustmentCreateWithoutRaceInput[] | RaceAbilityAdjustmentUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceAbilityAdjustmentCreateOrConnectWithoutRaceInput | RaceAbilityAdjustmentCreateOrConnectWithoutRaceInput[]
    createMany?: RaceAbilityAdjustmentCreateManyRaceInputEnvelope
    connect?: RaceAbilityAdjustmentWhereUniqueInput | RaceAbilityAdjustmentWhereUniqueInput[]
  }

  export type RaceLanguageMapUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceLanguageMapCreateWithoutRaceInput, RaceLanguageMapUncheckedCreateWithoutRaceInput> | RaceLanguageMapCreateWithoutRaceInput[] | RaceLanguageMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceLanguageMapCreateOrConnectWithoutRaceInput | RaceLanguageMapCreateOrConnectWithoutRaceInput[]
    createMany?: RaceLanguageMapCreateManyRaceInputEnvelope
    connect?: RaceLanguageMapWhereUniqueInput | RaceLanguageMapWhereUniqueInput[]
  }

  export type RaceSourceMapUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceSourceMapCreateWithoutRaceInput, RaceSourceMapUncheckedCreateWithoutRaceInput> | RaceSourceMapCreateWithoutRaceInput[] | RaceSourceMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceSourceMapCreateOrConnectWithoutRaceInput | RaceSourceMapCreateOrConnectWithoutRaceInput[]
    createMany?: RaceSourceMapCreateManyRaceInputEnvelope
    connect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
  }

  export type RaceTraitMapUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceTraitMapCreateWithoutRaceInput, RaceTraitMapUncheckedCreateWithoutRaceInput> | RaceTraitMapCreateWithoutRaceInput[] | RaceTraitMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceTraitMapCreateOrConnectWithoutRaceInput | RaceTraitMapCreateOrConnectWithoutRaceInput[]
    createMany?: RaceTraitMapCreateManyRaceInputEnvelope
    connect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
  }

  export type UserCharacterUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<UserCharacterCreateWithoutRaceInput, UserCharacterUncheckedCreateWithoutRaceInput> | UserCharacterCreateWithoutRaceInput[] | UserCharacterUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: UserCharacterCreateOrConnectWithoutRaceInput | UserCharacterCreateOrConnectWithoutRaceInput[]
    createMany?: UserCharacterCreateManyRaceInputEnvelope
    connect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
  }

  export type RaceAbilityAdjustmentUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceAbilityAdjustmentCreateWithoutRaceInput, RaceAbilityAdjustmentUncheckedCreateWithoutRaceInput> | RaceAbilityAdjustmentCreateWithoutRaceInput[] | RaceAbilityAdjustmentUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceAbilityAdjustmentCreateOrConnectWithoutRaceInput | RaceAbilityAdjustmentCreateOrConnectWithoutRaceInput[]
    upsert?: RaceAbilityAdjustmentUpsertWithWhereUniqueWithoutRaceInput | RaceAbilityAdjustmentUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceAbilityAdjustmentCreateManyRaceInputEnvelope
    set?: RaceAbilityAdjustmentWhereUniqueInput | RaceAbilityAdjustmentWhereUniqueInput[]
    disconnect?: RaceAbilityAdjustmentWhereUniqueInput | RaceAbilityAdjustmentWhereUniqueInput[]
    delete?: RaceAbilityAdjustmentWhereUniqueInput | RaceAbilityAdjustmentWhereUniqueInput[]
    connect?: RaceAbilityAdjustmentWhereUniqueInput | RaceAbilityAdjustmentWhereUniqueInput[]
    update?: RaceAbilityAdjustmentUpdateWithWhereUniqueWithoutRaceInput | RaceAbilityAdjustmentUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceAbilityAdjustmentUpdateManyWithWhereWithoutRaceInput | RaceAbilityAdjustmentUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceAbilityAdjustmentScalarWhereInput | RaceAbilityAdjustmentScalarWhereInput[]
  }

  export type RaceLanguageMapUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceLanguageMapCreateWithoutRaceInput, RaceLanguageMapUncheckedCreateWithoutRaceInput> | RaceLanguageMapCreateWithoutRaceInput[] | RaceLanguageMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceLanguageMapCreateOrConnectWithoutRaceInput | RaceLanguageMapCreateOrConnectWithoutRaceInput[]
    upsert?: RaceLanguageMapUpsertWithWhereUniqueWithoutRaceInput | RaceLanguageMapUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceLanguageMapCreateManyRaceInputEnvelope
    set?: RaceLanguageMapWhereUniqueInput | RaceLanguageMapWhereUniqueInput[]
    disconnect?: RaceLanguageMapWhereUniqueInput | RaceLanguageMapWhereUniqueInput[]
    delete?: RaceLanguageMapWhereUniqueInput | RaceLanguageMapWhereUniqueInput[]
    connect?: RaceLanguageMapWhereUniqueInput | RaceLanguageMapWhereUniqueInput[]
    update?: RaceLanguageMapUpdateWithWhereUniqueWithoutRaceInput | RaceLanguageMapUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceLanguageMapUpdateManyWithWhereWithoutRaceInput | RaceLanguageMapUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceLanguageMapScalarWhereInput | RaceLanguageMapScalarWhereInput[]
  }

  export type RaceSourceMapUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceSourceMapCreateWithoutRaceInput, RaceSourceMapUncheckedCreateWithoutRaceInput> | RaceSourceMapCreateWithoutRaceInput[] | RaceSourceMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceSourceMapCreateOrConnectWithoutRaceInput | RaceSourceMapCreateOrConnectWithoutRaceInput[]
    upsert?: RaceSourceMapUpsertWithWhereUniqueWithoutRaceInput | RaceSourceMapUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceSourceMapCreateManyRaceInputEnvelope
    set?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    disconnect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    delete?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    connect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    update?: RaceSourceMapUpdateWithWhereUniqueWithoutRaceInput | RaceSourceMapUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceSourceMapUpdateManyWithWhereWithoutRaceInput | RaceSourceMapUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceSourceMapScalarWhereInput | RaceSourceMapScalarWhereInput[]
  }

  export type RaceTraitMapUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceTraitMapCreateWithoutRaceInput, RaceTraitMapUncheckedCreateWithoutRaceInput> | RaceTraitMapCreateWithoutRaceInput[] | RaceTraitMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceTraitMapCreateOrConnectWithoutRaceInput | RaceTraitMapCreateOrConnectWithoutRaceInput[]
    upsert?: RaceTraitMapUpsertWithWhereUniqueWithoutRaceInput | RaceTraitMapUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceTraitMapCreateManyRaceInputEnvelope
    set?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    disconnect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    delete?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    connect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    update?: RaceTraitMapUpdateWithWhereUniqueWithoutRaceInput | RaceTraitMapUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceTraitMapUpdateManyWithWhereWithoutRaceInput | RaceTraitMapUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceTraitMapScalarWhereInput | RaceTraitMapScalarWhereInput[]
  }

  export type UserCharacterUpdateManyWithoutRaceNestedInput = {
    create?: XOR<UserCharacterCreateWithoutRaceInput, UserCharacterUncheckedCreateWithoutRaceInput> | UserCharacterCreateWithoutRaceInput[] | UserCharacterUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: UserCharacterCreateOrConnectWithoutRaceInput | UserCharacterCreateOrConnectWithoutRaceInput[]
    upsert?: UserCharacterUpsertWithWhereUniqueWithoutRaceInput | UserCharacterUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: UserCharacterCreateManyRaceInputEnvelope
    set?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    disconnect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    delete?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    connect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    update?: UserCharacterUpdateWithWhereUniqueWithoutRaceInput | UserCharacterUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: UserCharacterUpdateManyWithWhereWithoutRaceInput | UserCharacterUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: UserCharacterScalarWhereInput | UserCharacterScalarWhereInput[]
  }

  export type RaceAbilityAdjustmentUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceAbilityAdjustmentCreateWithoutRaceInput, RaceAbilityAdjustmentUncheckedCreateWithoutRaceInput> | RaceAbilityAdjustmentCreateWithoutRaceInput[] | RaceAbilityAdjustmentUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceAbilityAdjustmentCreateOrConnectWithoutRaceInput | RaceAbilityAdjustmentCreateOrConnectWithoutRaceInput[]
    upsert?: RaceAbilityAdjustmentUpsertWithWhereUniqueWithoutRaceInput | RaceAbilityAdjustmentUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceAbilityAdjustmentCreateManyRaceInputEnvelope
    set?: RaceAbilityAdjustmentWhereUniqueInput | RaceAbilityAdjustmentWhereUniqueInput[]
    disconnect?: RaceAbilityAdjustmentWhereUniqueInput | RaceAbilityAdjustmentWhereUniqueInput[]
    delete?: RaceAbilityAdjustmentWhereUniqueInput | RaceAbilityAdjustmentWhereUniqueInput[]
    connect?: RaceAbilityAdjustmentWhereUniqueInput | RaceAbilityAdjustmentWhereUniqueInput[]
    update?: RaceAbilityAdjustmentUpdateWithWhereUniqueWithoutRaceInput | RaceAbilityAdjustmentUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceAbilityAdjustmentUpdateManyWithWhereWithoutRaceInput | RaceAbilityAdjustmentUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceAbilityAdjustmentScalarWhereInput | RaceAbilityAdjustmentScalarWhereInput[]
  }

  export type RaceLanguageMapUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceLanguageMapCreateWithoutRaceInput, RaceLanguageMapUncheckedCreateWithoutRaceInput> | RaceLanguageMapCreateWithoutRaceInput[] | RaceLanguageMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceLanguageMapCreateOrConnectWithoutRaceInput | RaceLanguageMapCreateOrConnectWithoutRaceInput[]
    upsert?: RaceLanguageMapUpsertWithWhereUniqueWithoutRaceInput | RaceLanguageMapUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceLanguageMapCreateManyRaceInputEnvelope
    set?: RaceLanguageMapWhereUniqueInput | RaceLanguageMapWhereUniqueInput[]
    disconnect?: RaceLanguageMapWhereUniqueInput | RaceLanguageMapWhereUniqueInput[]
    delete?: RaceLanguageMapWhereUniqueInput | RaceLanguageMapWhereUniqueInput[]
    connect?: RaceLanguageMapWhereUniqueInput | RaceLanguageMapWhereUniqueInput[]
    update?: RaceLanguageMapUpdateWithWhereUniqueWithoutRaceInput | RaceLanguageMapUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceLanguageMapUpdateManyWithWhereWithoutRaceInput | RaceLanguageMapUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceLanguageMapScalarWhereInput | RaceLanguageMapScalarWhereInput[]
  }

  export type RaceSourceMapUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceSourceMapCreateWithoutRaceInput, RaceSourceMapUncheckedCreateWithoutRaceInput> | RaceSourceMapCreateWithoutRaceInput[] | RaceSourceMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceSourceMapCreateOrConnectWithoutRaceInput | RaceSourceMapCreateOrConnectWithoutRaceInput[]
    upsert?: RaceSourceMapUpsertWithWhereUniqueWithoutRaceInput | RaceSourceMapUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceSourceMapCreateManyRaceInputEnvelope
    set?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    disconnect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    delete?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    connect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    update?: RaceSourceMapUpdateWithWhereUniqueWithoutRaceInput | RaceSourceMapUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceSourceMapUpdateManyWithWhereWithoutRaceInput | RaceSourceMapUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceSourceMapScalarWhereInput | RaceSourceMapScalarWhereInput[]
  }

  export type RaceTraitMapUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceTraitMapCreateWithoutRaceInput, RaceTraitMapUncheckedCreateWithoutRaceInput> | RaceTraitMapCreateWithoutRaceInput[] | RaceTraitMapUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceTraitMapCreateOrConnectWithoutRaceInput | RaceTraitMapCreateOrConnectWithoutRaceInput[]
    upsert?: RaceTraitMapUpsertWithWhereUniqueWithoutRaceInput | RaceTraitMapUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceTraitMapCreateManyRaceInputEnvelope
    set?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    disconnect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    delete?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    connect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    update?: RaceTraitMapUpdateWithWhereUniqueWithoutRaceInput | RaceTraitMapUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceTraitMapUpdateManyWithWhereWithoutRaceInput | RaceTraitMapUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceTraitMapScalarWhereInput | RaceTraitMapScalarWhereInput[]
  }

  export type UserCharacterUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<UserCharacterCreateWithoutRaceInput, UserCharacterUncheckedCreateWithoutRaceInput> | UserCharacterCreateWithoutRaceInput[] | UserCharacterUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: UserCharacterCreateOrConnectWithoutRaceInput | UserCharacterCreateOrConnectWithoutRaceInput[]
    upsert?: UserCharacterUpsertWithWhereUniqueWithoutRaceInput | UserCharacterUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: UserCharacterCreateManyRaceInputEnvelope
    set?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    disconnect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    delete?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    connect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    update?: UserCharacterUpdateWithWhereUniqueWithoutRaceInput | UserCharacterUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: UserCharacterUpdateManyWithWhereWithoutRaceInput | UserCharacterUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: UserCharacterScalarWhereInput | UserCharacterScalarWhereInput[]
  }

  export type RaceTraitMapCreateNestedManyWithoutTraitInput = {
    create?: XOR<RaceTraitMapCreateWithoutTraitInput, RaceTraitMapUncheckedCreateWithoutTraitInput> | RaceTraitMapCreateWithoutTraitInput[] | RaceTraitMapUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: RaceTraitMapCreateOrConnectWithoutTraitInput | RaceTraitMapCreateOrConnectWithoutTraitInput[]
    createMany?: RaceTraitMapCreateManyTraitInputEnvelope
    connect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
  }

  export type RaceTraitMapUncheckedCreateNestedManyWithoutTraitInput = {
    create?: XOR<RaceTraitMapCreateWithoutTraitInput, RaceTraitMapUncheckedCreateWithoutTraitInput> | RaceTraitMapCreateWithoutTraitInput[] | RaceTraitMapUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: RaceTraitMapCreateOrConnectWithoutTraitInput | RaceTraitMapCreateOrConnectWithoutTraitInput[]
    createMany?: RaceTraitMapCreateManyTraitInputEnvelope
    connect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
  }

  export type RaceTraitMapUpdateManyWithoutTraitNestedInput = {
    create?: XOR<RaceTraitMapCreateWithoutTraitInput, RaceTraitMapUncheckedCreateWithoutTraitInput> | RaceTraitMapCreateWithoutTraitInput[] | RaceTraitMapUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: RaceTraitMapCreateOrConnectWithoutTraitInput | RaceTraitMapCreateOrConnectWithoutTraitInput[]
    upsert?: RaceTraitMapUpsertWithWhereUniqueWithoutTraitInput | RaceTraitMapUpsertWithWhereUniqueWithoutTraitInput[]
    createMany?: RaceTraitMapCreateManyTraitInputEnvelope
    set?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    disconnect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    delete?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    connect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    update?: RaceTraitMapUpdateWithWhereUniqueWithoutTraitInput | RaceTraitMapUpdateWithWhereUniqueWithoutTraitInput[]
    updateMany?: RaceTraitMapUpdateManyWithWhereWithoutTraitInput | RaceTraitMapUpdateManyWithWhereWithoutTraitInput[]
    deleteMany?: RaceTraitMapScalarWhereInput | RaceTraitMapScalarWhereInput[]
  }

  export type RaceTraitMapUncheckedUpdateManyWithoutTraitNestedInput = {
    create?: XOR<RaceTraitMapCreateWithoutTraitInput, RaceTraitMapUncheckedCreateWithoutTraitInput> | RaceTraitMapCreateWithoutTraitInput[] | RaceTraitMapUncheckedCreateWithoutTraitInput[]
    connectOrCreate?: RaceTraitMapCreateOrConnectWithoutTraitInput | RaceTraitMapCreateOrConnectWithoutTraitInput[]
    upsert?: RaceTraitMapUpsertWithWhereUniqueWithoutTraitInput | RaceTraitMapUpsertWithWhereUniqueWithoutTraitInput[]
    createMany?: RaceTraitMapCreateManyTraitInputEnvelope
    set?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    disconnect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    delete?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    connect?: RaceTraitMapWhereUniqueInput | RaceTraitMapWhereUniqueInput[]
    update?: RaceTraitMapUpdateWithWhereUniqueWithoutTraitInput | RaceTraitMapUpdateWithWhereUniqueWithoutTraitInput[]
    updateMany?: RaceTraitMapUpdateManyWithWhereWithoutTraitInput | RaceTraitMapUpdateManyWithWhereWithoutTraitInput[]
    deleteMany?: RaceTraitMapScalarWhereInput | RaceTraitMapScalarWhereInput[]
  }

  export type RaceCreateNestedOneWithoutTraitsInput = {
    create?: XOR<RaceCreateWithoutTraitsInput, RaceUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutTraitsInput
    connect?: RaceWhereUniqueInput
  }

  export type RaceTraitCreateNestedOneWithoutRaceLinksInput = {
    create?: XOR<RaceTraitCreateWithoutRaceLinksInput, RaceTraitUncheckedCreateWithoutRaceLinksInput>
    connectOrCreate?: RaceTraitCreateOrConnectWithoutRaceLinksInput
    connect?: RaceTraitWhereUniqueInput
  }

  export type RaceUpdateOneRequiredWithoutTraitsNestedInput = {
    create?: XOR<RaceCreateWithoutTraitsInput, RaceUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutTraitsInput
    upsert?: RaceUpsertWithoutTraitsInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutTraitsInput, RaceUpdateWithoutTraitsInput>, RaceUncheckedUpdateWithoutTraitsInput>
  }

  export type RaceTraitUpdateOneRequiredWithoutRaceLinksNestedInput = {
    create?: XOR<RaceTraitCreateWithoutRaceLinksInput, RaceTraitUncheckedCreateWithoutRaceLinksInput>
    connectOrCreate?: RaceTraitCreateOrConnectWithoutRaceLinksInput
    upsert?: RaceTraitUpsertWithoutRaceLinksInput
    connect?: RaceTraitWhereUniqueInput
    update?: XOR<XOR<RaceTraitUpdateToOneWithWhereWithoutRaceLinksInput, RaceTraitUpdateWithoutRaceLinksInput>, RaceTraitUncheckedUpdateWithoutRaceLinksInput>
  }

  export type RaceCreateNestedOneWithoutAbilityAdjustmentsInput = {
    create?: XOR<RaceCreateWithoutAbilityAdjustmentsInput, RaceUncheckedCreateWithoutAbilityAdjustmentsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutAbilityAdjustmentsInput
    connect?: RaceWhereUniqueInput
  }

  export type RaceUpdateOneRequiredWithoutAbilityAdjustmentsNestedInput = {
    create?: XOR<RaceCreateWithoutAbilityAdjustmentsInput, RaceUncheckedCreateWithoutAbilityAdjustmentsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutAbilityAdjustmentsInput
    upsert?: RaceUpsertWithoutAbilityAdjustmentsInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutAbilityAdjustmentsInput, RaceUpdateWithoutAbilityAdjustmentsInput>, RaceUncheckedUpdateWithoutAbilityAdjustmentsInput>
  }

  export type RaceCreateNestedOneWithoutLanguagesInput = {
    create?: XOR<RaceCreateWithoutLanguagesInput, RaceUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutLanguagesInput
    connect?: RaceWhereUniqueInput
  }

  export type RaceUpdateOneRequiredWithoutLanguagesNestedInput = {
    create?: XOR<RaceCreateWithoutLanguagesInput, RaceUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutLanguagesInput
    upsert?: RaceUpsertWithoutLanguagesInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutLanguagesInput, RaceUpdateWithoutLanguagesInput>, RaceUncheckedUpdateWithoutLanguagesInput>
  }

  export type RaceCreateNestedOneWithoutSourcesInput = {
    create?: XOR<RaceCreateWithoutSourcesInput, RaceUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutSourcesInput
    connect?: RaceWhereUniqueInput
  }

  export type SourceBookCreateNestedOneWithoutRacesInput = {
    create?: XOR<SourceBookCreateWithoutRacesInput, SourceBookUncheckedCreateWithoutRacesInput>
    connectOrCreate?: SourceBookCreateOrConnectWithoutRacesInput
    connect?: SourceBookWhereUniqueInput
  }

  export type RaceUpdateOneRequiredWithoutSourcesNestedInput = {
    create?: XOR<RaceCreateWithoutSourcesInput, RaceUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutSourcesInput
    upsert?: RaceUpsertWithoutSourcesInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutSourcesInput, RaceUpdateWithoutSourcesInput>, RaceUncheckedUpdateWithoutSourcesInput>
  }

  export type SourceBookUpdateOneWithoutRacesNestedInput = {
    create?: XOR<SourceBookCreateWithoutRacesInput, SourceBookUncheckedCreateWithoutRacesInput>
    connectOrCreate?: SourceBookCreateOrConnectWithoutRacesInput
    upsert?: SourceBookUpsertWithoutRacesInput
    disconnect?: SourceBookWhereInput | boolean
    delete?: SourceBookWhereInput | boolean
    connect?: SourceBookWhereUniqueInput
    update?: XOR<XOR<SourceBookUpdateToOneWithWhereWithoutRacesInput, SourceBookUpdateWithoutRacesInput>, SourceBookUncheckedUpdateWithoutRacesInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ClassSourceMapCreateNestedManyWithoutSourceBookInput = {
    create?: XOR<ClassSourceMapCreateWithoutSourceBookInput, ClassSourceMapUncheckedCreateWithoutSourceBookInput> | ClassSourceMapCreateWithoutSourceBookInput[] | ClassSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: ClassSourceMapCreateOrConnectWithoutSourceBookInput | ClassSourceMapCreateOrConnectWithoutSourceBookInput[]
    createMany?: ClassSourceMapCreateManySourceBookInputEnvelope
    connect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
  }

  export type RaceSourceMapCreateNestedManyWithoutSourceBookInput = {
    create?: XOR<RaceSourceMapCreateWithoutSourceBookInput, RaceSourceMapUncheckedCreateWithoutSourceBookInput> | RaceSourceMapCreateWithoutSourceBookInput[] | RaceSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: RaceSourceMapCreateOrConnectWithoutSourceBookInput | RaceSourceMapCreateOrConnectWithoutSourceBookInput[]
    createMany?: RaceSourceMapCreateManySourceBookInputEnvelope
    connect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
  }

  export type SpellSourceMapCreateNestedManyWithoutSourceBookInput = {
    create?: XOR<SpellSourceMapCreateWithoutSourceBookInput, SpellSourceMapUncheckedCreateWithoutSourceBookInput> | SpellSourceMapCreateWithoutSourceBookInput[] | SpellSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: SpellSourceMapCreateOrConnectWithoutSourceBookInput | SpellSourceMapCreateOrConnectWithoutSourceBookInput[]
    createMany?: SpellSourceMapCreateManySourceBookInputEnvelope
    connect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
  }

  export type ClassSourceMapUncheckedCreateNestedManyWithoutSourceBookInput = {
    create?: XOR<ClassSourceMapCreateWithoutSourceBookInput, ClassSourceMapUncheckedCreateWithoutSourceBookInput> | ClassSourceMapCreateWithoutSourceBookInput[] | ClassSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: ClassSourceMapCreateOrConnectWithoutSourceBookInput | ClassSourceMapCreateOrConnectWithoutSourceBookInput[]
    createMany?: ClassSourceMapCreateManySourceBookInputEnvelope
    connect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
  }

  export type RaceSourceMapUncheckedCreateNestedManyWithoutSourceBookInput = {
    create?: XOR<RaceSourceMapCreateWithoutSourceBookInput, RaceSourceMapUncheckedCreateWithoutSourceBookInput> | RaceSourceMapCreateWithoutSourceBookInput[] | RaceSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: RaceSourceMapCreateOrConnectWithoutSourceBookInput | RaceSourceMapCreateOrConnectWithoutSourceBookInput[]
    createMany?: RaceSourceMapCreateManySourceBookInputEnvelope
    connect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
  }

  export type SpellSourceMapUncheckedCreateNestedManyWithoutSourceBookInput = {
    create?: XOR<SpellSourceMapCreateWithoutSourceBookInput, SpellSourceMapUncheckedCreateWithoutSourceBookInput> | SpellSourceMapCreateWithoutSourceBookInput[] | SpellSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: SpellSourceMapCreateOrConnectWithoutSourceBookInput | SpellSourceMapCreateOrConnectWithoutSourceBookInput[]
    createMany?: SpellSourceMapCreateManySourceBookInputEnvelope
    connect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClassSourceMapUpdateManyWithoutSourceBookNestedInput = {
    create?: XOR<ClassSourceMapCreateWithoutSourceBookInput, ClassSourceMapUncheckedCreateWithoutSourceBookInput> | ClassSourceMapCreateWithoutSourceBookInput[] | ClassSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: ClassSourceMapCreateOrConnectWithoutSourceBookInput | ClassSourceMapCreateOrConnectWithoutSourceBookInput[]
    upsert?: ClassSourceMapUpsertWithWhereUniqueWithoutSourceBookInput | ClassSourceMapUpsertWithWhereUniqueWithoutSourceBookInput[]
    createMany?: ClassSourceMapCreateManySourceBookInputEnvelope
    set?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    disconnect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    delete?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    connect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    update?: ClassSourceMapUpdateWithWhereUniqueWithoutSourceBookInput | ClassSourceMapUpdateWithWhereUniqueWithoutSourceBookInput[]
    updateMany?: ClassSourceMapUpdateManyWithWhereWithoutSourceBookInput | ClassSourceMapUpdateManyWithWhereWithoutSourceBookInput[]
    deleteMany?: ClassSourceMapScalarWhereInput | ClassSourceMapScalarWhereInput[]
  }

  export type RaceSourceMapUpdateManyWithoutSourceBookNestedInput = {
    create?: XOR<RaceSourceMapCreateWithoutSourceBookInput, RaceSourceMapUncheckedCreateWithoutSourceBookInput> | RaceSourceMapCreateWithoutSourceBookInput[] | RaceSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: RaceSourceMapCreateOrConnectWithoutSourceBookInput | RaceSourceMapCreateOrConnectWithoutSourceBookInput[]
    upsert?: RaceSourceMapUpsertWithWhereUniqueWithoutSourceBookInput | RaceSourceMapUpsertWithWhereUniqueWithoutSourceBookInput[]
    createMany?: RaceSourceMapCreateManySourceBookInputEnvelope
    set?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    disconnect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    delete?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    connect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    update?: RaceSourceMapUpdateWithWhereUniqueWithoutSourceBookInput | RaceSourceMapUpdateWithWhereUniqueWithoutSourceBookInput[]
    updateMany?: RaceSourceMapUpdateManyWithWhereWithoutSourceBookInput | RaceSourceMapUpdateManyWithWhereWithoutSourceBookInput[]
    deleteMany?: RaceSourceMapScalarWhereInput | RaceSourceMapScalarWhereInput[]
  }

  export type SpellSourceMapUpdateManyWithoutSourceBookNestedInput = {
    create?: XOR<SpellSourceMapCreateWithoutSourceBookInput, SpellSourceMapUncheckedCreateWithoutSourceBookInput> | SpellSourceMapCreateWithoutSourceBookInput[] | SpellSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: SpellSourceMapCreateOrConnectWithoutSourceBookInput | SpellSourceMapCreateOrConnectWithoutSourceBookInput[]
    upsert?: SpellSourceMapUpsertWithWhereUniqueWithoutSourceBookInput | SpellSourceMapUpsertWithWhereUniqueWithoutSourceBookInput[]
    createMany?: SpellSourceMapCreateManySourceBookInputEnvelope
    set?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    disconnect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    delete?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    connect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    update?: SpellSourceMapUpdateWithWhereUniqueWithoutSourceBookInput | SpellSourceMapUpdateWithWhereUniqueWithoutSourceBookInput[]
    updateMany?: SpellSourceMapUpdateManyWithWhereWithoutSourceBookInput | SpellSourceMapUpdateManyWithWhereWithoutSourceBookInput[]
    deleteMany?: SpellSourceMapScalarWhereInput | SpellSourceMapScalarWhereInput[]
  }

  export type ClassSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput = {
    create?: XOR<ClassSourceMapCreateWithoutSourceBookInput, ClassSourceMapUncheckedCreateWithoutSourceBookInput> | ClassSourceMapCreateWithoutSourceBookInput[] | ClassSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: ClassSourceMapCreateOrConnectWithoutSourceBookInput | ClassSourceMapCreateOrConnectWithoutSourceBookInput[]
    upsert?: ClassSourceMapUpsertWithWhereUniqueWithoutSourceBookInput | ClassSourceMapUpsertWithWhereUniqueWithoutSourceBookInput[]
    createMany?: ClassSourceMapCreateManySourceBookInputEnvelope
    set?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    disconnect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    delete?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    connect?: ClassSourceMapWhereUniqueInput | ClassSourceMapWhereUniqueInput[]
    update?: ClassSourceMapUpdateWithWhereUniqueWithoutSourceBookInput | ClassSourceMapUpdateWithWhereUniqueWithoutSourceBookInput[]
    updateMany?: ClassSourceMapUpdateManyWithWhereWithoutSourceBookInput | ClassSourceMapUpdateManyWithWhereWithoutSourceBookInput[]
    deleteMany?: ClassSourceMapScalarWhereInput | ClassSourceMapScalarWhereInput[]
  }

  export type RaceSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput = {
    create?: XOR<RaceSourceMapCreateWithoutSourceBookInput, RaceSourceMapUncheckedCreateWithoutSourceBookInput> | RaceSourceMapCreateWithoutSourceBookInput[] | RaceSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: RaceSourceMapCreateOrConnectWithoutSourceBookInput | RaceSourceMapCreateOrConnectWithoutSourceBookInput[]
    upsert?: RaceSourceMapUpsertWithWhereUniqueWithoutSourceBookInput | RaceSourceMapUpsertWithWhereUniqueWithoutSourceBookInput[]
    createMany?: RaceSourceMapCreateManySourceBookInputEnvelope
    set?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    disconnect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    delete?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    connect?: RaceSourceMapWhereUniqueInput | RaceSourceMapWhereUniqueInput[]
    update?: RaceSourceMapUpdateWithWhereUniqueWithoutSourceBookInput | RaceSourceMapUpdateWithWhereUniqueWithoutSourceBookInput[]
    updateMany?: RaceSourceMapUpdateManyWithWhereWithoutSourceBookInput | RaceSourceMapUpdateManyWithWhereWithoutSourceBookInput[]
    deleteMany?: RaceSourceMapScalarWhereInput | RaceSourceMapScalarWhereInput[]
  }

  export type SpellSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput = {
    create?: XOR<SpellSourceMapCreateWithoutSourceBookInput, SpellSourceMapUncheckedCreateWithoutSourceBookInput> | SpellSourceMapCreateWithoutSourceBookInput[] | SpellSourceMapUncheckedCreateWithoutSourceBookInput[]
    connectOrCreate?: SpellSourceMapCreateOrConnectWithoutSourceBookInput | SpellSourceMapCreateOrConnectWithoutSourceBookInput[]
    upsert?: SpellSourceMapUpsertWithWhereUniqueWithoutSourceBookInput | SpellSourceMapUpsertWithWhereUniqueWithoutSourceBookInput[]
    createMany?: SpellSourceMapCreateManySourceBookInputEnvelope
    set?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    disconnect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    delete?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    connect?: SpellSourceMapWhereUniqueInput | SpellSourceMapWhereUniqueInput[]
    update?: SpellSourceMapUpdateWithWhereUniqueWithoutSourceBookInput | SpellSourceMapUpdateWithWhereUniqueWithoutSourceBookInput[]
    updateMany?: SpellSourceMapUpdateManyWithWhereWithoutSourceBookInput | SpellSourceMapUpdateManyWithWhereWithoutSourceBookInput[]
    deleteMany?: SpellSourceMapScalarWhereInput | SpellSourceMapScalarWhereInput[]
  }

  export type ReferenceTableColumnCreateNestedManyWithoutTableInput = {
    create?: XOR<ReferenceTableColumnCreateWithoutTableInput, ReferenceTableColumnUncheckedCreateWithoutTableInput> | ReferenceTableColumnCreateWithoutTableInput[] | ReferenceTableColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReferenceTableColumnCreateOrConnectWithoutTableInput | ReferenceTableColumnCreateOrConnectWithoutTableInput[]
    createMany?: ReferenceTableColumnCreateManyTableInputEnvelope
    connect?: ReferenceTableColumnWhereUniqueInput | ReferenceTableColumnWhereUniqueInput[]
  }

  export type ReferenceTableRowCreateNestedManyWithoutTableInput = {
    create?: XOR<ReferenceTableRowCreateWithoutTableInput, ReferenceTableRowUncheckedCreateWithoutTableInput> | ReferenceTableRowCreateWithoutTableInput[] | ReferenceTableRowUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReferenceTableRowCreateOrConnectWithoutTableInput | ReferenceTableRowCreateOrConnectWithoutTableInput[]
    createMany?: ReferenceTableRowCreateManyTableInputEnvelope
    connect?: ReferenceTableRowWhereUniqueInput | ReferenceTableRowWhereUniqueInput[]
  }

  export type ReferenceTableColumnUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<ReferenceTableColumnCreateWithoutTableInput, ReferenceTableColumnUncheckedCreateWithoutTableInput> | ReferenceTableColumnCreateWithoutTableInput[] | ReferenceTableColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReferenceTableColumnCreateOrConnectWithoutTableInput | ReferenceTableColumnCreateOrConnectWithoutTableInput[]
    createMany?: ReferenceTableColumnCreateManyTableInputEnvelope
    connect?: ReferenceTableColumnWhereUniqueInput | ReferenceTableColumnWhereUniqueInput[]
  }

  export type ReferenceTableRowUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<ReferenceTableRowCreateWithoutTableInput, ReferenceTableRowUncheckedCreateWithoutTableInput> | ReferenceTableRowCreateWithoutTableInput[] | ReferenceTableRowUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReferenceTableRowCreateOrConnectWithoutTableInput | ReferenceTableRowCreateOrConnectWithoutTableInput[]
    createMany?: ReferenceTableRowCreateManyTableInputEnvelope
    connect?: ReferenceTableRowWhereUniqueInput | ReferenceTableRowWhereUniqueInput[]
  }

  export type ReferenceTableColumnUpdateManyWithoutTableNestedInput = {
    create?: XOR<ReferenceTableColumnCreateWithoutTableInput, ReferenceTableColumnUncheckedCreateWithoutTableInput> | ReferenceTableColumnCreateWithoutTableInput[] | ReferenceTableColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReferenceTableColumnCreateOrConnectWithoutTableInput | ReferenceTableColumnCreateOrConnectWithoutTableInput[]
    upsert?: ReferenceTableColumnUpsertWithWhereUniqueWithoutTableInput | ReferenceTableColumnUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: ReferenceTableColumnCreateManyTableInputEnvelope
    set?: ReferenceTableColumnWhereUniqueInput | ReferenceTableColumnWhereUniqueInput[]
    disconnect?: ReferenceTableColumnWhereUniqueInput | ReferenceTableColumnWhereUniqueInput[]
    delete?: ReferenceTableColumnWhereUniqueInput | ReferenceTableColumnWhereUniqueInput[]
    connect?: ReferenceTableColumnWhereUniqueInput | ReferenceTableColumnWhereUniqueInput[]
    update?: ReferenceTableColumnUpdateWithWhereUniqueWithoutTableInput | ReferenceTableColumnUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: ReferenceTableColumnUpdateManyWithWhereWithoutTableInput | ReferenceTableColumnUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: ReferenceTableColumnScalarWhereInput | ReferenceTableColumnScalarWhereInput[]
  }

  export type ReferenceTableRowUpdateManyWithoutTableNestedInput = {
    create?: XOR<ReferenceTableRowCreateWithoutTableInput, ReferenceTableRowUncheckedCreateWithoutTableInput> | ReferenceTableRowCreateWithoutTableInput[] | ReferenceTableRowUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReferenceTableRowCreateOrConnectWithoutTableInput | ReferenceTableRowCreateOrConnectWithoutTableInput[]
    upsert?: ReferenceTableRowUpsertWithWhereUniqueWithoutTableInput | ReferenceTableRowUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: ReferenceTableRowCreateManyTableInputEnvelope
    set?: ReferenceTableRowWhereUniqueInput | ReferenceTableRowWhereUniqueInput[]
    disconnect?: ReferenceTableRowWhereUniqueInput | ReferenceTableRowWhereUniqueInput[]
    delete?: ReferenceTableRowWhereUniqueInput | ReferenceTableRowWhereUniqueInput[]
    connect?: ReferenceTableRowWhereUniqueInput | ReferenceTableRowWhereUniqueInput[]
    update?: ReferenceTableRowUpdateWithWhereUniqueWithoutTableInput | ReferenceTableRowUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: ReferenceTableRowUpdateManyWithWhereWithoutTableInput | ReferenceTableRowUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: ReferenceTableRowScalarWhereInput | ReferenceTableRowScalarWhereInput[]
  }

  export type ReferenceTableColumnUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<ReferenceTableColumnCreateWithoutTableInput, ReferenceTableColumnUncheckedCreateWithoutTableInput> | ReferenceTableColumnCreateWithoutTableInput[] | ReferenceTableColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReferenceTableColumnCreateOrConnectWithoutTableInput | ReferenceTableColumnCreateOrConnectWithoutTableInput[]
    upsert?: ReferenceTableColumnUpsertWithWhereUniqueWithoutTableInput | ReferenceTableColumnUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: ReferenceTableColumnCreateManyTableInputEnvelope
    set?: ReferenceTableColumnWhereUniqueInput | ReferenceTableColumnWhereUniqueInput[]
    disconnect?: ReferenceTableColumnWhereUniqueInput | ReferenceTableColumnWhereUniqueInput[]
    delete?: ReferenceTableColumnWhereUniqueInput | ReferenceTableColumnWhereUniqueInput[]
    connect?: ReferenceTableColumnWhereUniqueInput | ReferenceTableColumnWhereUniqueInput[]
    update?: ReferenceTableColumnUpdateWithWhereUniqueWithoutTableInput | ReferenceTableColumnUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: ReferenceTableColumnUpdateManyWithWhereWithoutTableInput | ReferenceTableColumnUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: ReferenceTableColumnScalarWhereInput | ReferenceTableColumnScalarWhereInput[]
  }

  export type ReferenceTableRowUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<ReferenceTableRowCreateWithoutTableInput, ReferenceTableRowUncheckedCreateWithoutTableInput> | ReferenceTableRowCreateWithoutTableInput[] | ReferenceTableRowUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReferenceTableRowCreateOrConnectWithoutTableInput | ReferenceTableRowCreateOrConnectWithoutTableInput[]
    upsert?: ReferenceTableRowUpsertWithWhereUniqueWithoutTableInput | ReferenceTableRowUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: ReferenceTableRowCreateManyTableInputEnvelope
    set?: ReferenceTableRowWhereUniqueInput | ReferenceTableRowWhereUniqueInput[]
    disconnect?: ReferenceTableRowWhereUniqueInput | ReferenceTableRowWhereUniqueInput[]
    delete?: ReferenceTableRowWhereUniqueInput | ReferenceTableRowWhereUniqueInput[]
    connect?: ReferenceTableRowWhereUniqueInput | ReferenceTableRowWhereUniqueInput[]
    update?: ReferenceTableRowUpdateWithWhereUniqueWithoutTableInput | ReferenceTableRowUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: ReferenceTableRowUpdateManyWithWhereWithoutTableInput | ReferenceTableRowUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: ReferenceTableRowScalarWhereInput | ReferenceTableRowScalarWhereInput[]
  }

  export type ReferenceTableCellCreateNestedManyWithoutColumnInput = {
    create?: XOR<ReferenceTableCellCreateWithoutColumnInput, ReferenceTableCellUncheckedCreateWithoutColumnInput> | ReferenceTableCellCreateWithoutColumnInput[] | ReferenceTableCellUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: ReferenceTableCellCreateOrConnectWithoutColumnInput | ReferenceTableCellCreateOrConnectWithoutColumnInput[]
    createMany?: ReferenceTableCellCreateManyColumnInputEnvelope
    connect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
  }

  export type ReferenceTableCreateNestedOneWithoutColumnsInput = {
    create?: XOR<ReferenceTableCreateWithoutColumnsInput, ReferenceTableUncheckedCreateWithoutColumnsInput>
    connectOrCreate?: ReferenceTableCreateOrConnectWithoutColumnsInput
    connect?: ReferenceTableWhereUniqueInput
  }

  export type ReferenceTableCellUncheckedCreateNestedManyWithoutColumnInput = {
    create?: XOR<ReferenceTableCellCreateWithoutColumnInput, ReferenceTableCellUncheckedCreateWithoutColumnInput> | ReferenceTableCellCreateWithoutColumnInput[] | ReferenceTableCellUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: ReferenceTableCellCreateOrConnectWithoutColumnInput | ReferenceTableCellCreateOrConnectWithoutColumnInput[]
    createMany?: ReferenceTableCellCreateManyColumnInputEnvelope
    connect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
  }

  export type ReferenceTableCellUpdateManyWithoutColumnNestedInput = {
    create?: XOR<ReferenceTableCellCreateWithoutColumnInput, ReferenceTableCellUncheckedCreateWithoutColumnInput> | ReferenceTableCellCreateWithoutColumnInput[] | ReferenceTableCellUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: ReferenceTableCellCreateOrConnectWithoutColumnInput | ReferenceTableCellCreateOrConnectWithoutColumnInput[]
    upsert?: ReferenceTableCellUpsertWithWhereUniqueWithoutColumnInput | ReferenceTableCellUpsertWithWhereUniqueWithoutColumnInput[]
    createMany?: ReferenceTableCellCreateManyColumnInputEnvelope
    set?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    disconnect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    delete?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    connect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    update?: ReferenceTableCellUpdateWithWhereUniqueWithoutColumnInput | ReferenceTableCellUpdateWithWhereUniqueWithoutColumnInput[]
    updateMany?: ReferenceTableCellUpdateManyWithWhereWithoutColumnInput | ReferenceTableCellUpdateManyWithWhereWithoutColumnInput[]
    deleteMany?: ReferenceTableCellScalarWhereInput | ReferenceTableCellScalarWhereInput[]
  }

  export type ReferenceTableUpdateOneRequiredWithoutColumnsNestedInput = {
    create?: XOR<ReferenceTableCreateWithoutColumnsInput, ReferenceTableUncheckedCreateWithoutColumnsInput>
    connectOrCreate?: ReferenceTableCreateOrConnectWithoutColumnsInput
    upsert?: ReferenceTableUpsertWithoutColumnsInput
    connect?: ReferenceTableWhereUniqueInput
    update?: XOR<XOR<ReferenceTableUpdateToOneWithWhereWithoutColumnsInput, ReferenceTableUpdateWithoutColumnsInput>, ReferenceTableUncheckedUpdateWithoutColumnsInput>
  }

  export type ReferenceTableCellUncheckedUpdateManyWithoutColumnNestedInput = {
    create?: XOR<ReferenceTableCellCreateWithoutColumnInput, ReferenceTableCellUncheckedCreateWithoutColumnInput> | ReferenceTableCellCreateWithoutColumnInput[] | ReferenceTableCellUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: ReferenceTableCellCreateOrConnectWithoutColumnInput | ReferenceTableCellCreateOrConnectWithoutColumnInput[]
    upsert?: ReferenceTableCellUpsertWithWhereUniqueWithoutColumnInput | ReferenceTableCellUpsertWithWhereUniqueWithoutColumnInput[]
    createMany?: ReferenceTableCellCreateManyColumnInputEnvelope
    set?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    disconnect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    delete?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    connect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    update?: ReferenceTableCellUpdateWithWhereUniqueWithoutColumnInput | ReferenceTableCellUpdateWithWhereUniqueWithoutColumnInput[]
    updateMany?: ReferenceTableCellUpdateManyWithWhereWithoutColumnInput | ReferenceTableCellUpdateManyWithWhereWithoutColumnInput[]
    deleteMany?: ReferenceTableCellScalarWhereInput | ReferenceTableCellScalarWhereInput[]
  }

  export type ReferenceTableCellCreateNestedManyWithoutRowInput = {
    create?: XOR<ReferenceTableCellCreateWithoutRowInput, ReferenceTableCellUncheckedCreateWithoutRowInput> | ReferenceTableCellCreateWithoutRowInput[] | ReferenceTableCellUncheckedCreateWithoutRowInput[]
    connectOrCreate?: ReferenceTableCellCreateOrConnectWithoutRowInput | ReferenceTableCellCreateOrConnectWithoutRowInput[]
    createMany?: ReferenceTableCellCreateManyRowInputEnvelope
    connect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
  }

  export type ReferenceTableCreateNestedOneWithoutRowsInput = {
    create?: XOR<ReferenceTableCreateWithoutRowsInput, ReferenceTableUncheckedCreateWithoutRowsInput>
    connectOrCreate?: ReferenceTableCreateOrConnectWithoutRowsInput
    connect?: ReferenceTableWhereUniqueInput
  }

  export type ReferenceTableCellUncheckedCreateNestedManyWithoutRowInput = {
    create?: XOR<ReferenceTableCellCreateWithoutRowInput, ReferenceTableCellUncheckedCreateWithoutRowInput> | ReferenceTableCellCreateWithoutRowInput[] | ReferenceTableCellUncheckedCreateWithoutRowInput[]
    connectOrCreate?: ReferenceTableCellCreateOrConnectWithoutRowInput | ReferenceTableCellCreateOrConnectWithoutRowInput[]
    createMany?: ReferenceTableCellCreateManyRowInputEnvelope
    connect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
  }

  export type ReferenceTableCellUpdateManyWithoutRowNestedInput = {
    create?: XOR<ReferenceTableCellCreateWithoutRowInput, ReferenceTableCellUncheckedCreateWithoutRowInput> | ReferenceTableCellCreateWithoutRowInput[] | ReferenceTableCellUncheckedCreateWithoutRowInput[]
    connectOrCreate?: ReferenceTableCellCreateOrConnectWithoutRowInput | ReferenceTableCellCreateOrConnectWithoutRowInput[]
    upsert?: ReferenceTableCellUpsertWithWhereUniqueWithoutRowInput | ReferenceTableCellUpsertWithWhereUniqueWithoutRowInput[]
    createMany?: ReferenceTableCellCreateManyRowInputEnvelope
    set?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    disconnect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    delete?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    connect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    update?: ReferenceTableCellUpdateWithWhereUniqueWithoutRowInput | ReferenceTableCellUpdateWithWhereUniqueWithoutRowInput[]
    updateMany?: ReferenceTableCellUpdateManyWithWhereWithoutRowInput | ReferenceTableCellUpdateManyWithWhereWithoutRowInput[]
    deleteMany?: ReferenceTableCellScalarWhereInput | ReferenceTableCellScalarWhereInput[]
  }

  export type ReferenceTableUpdateOneRequiredWithoutRowsNestedInput = {
    create?: XOR<ReferenceTableCreateWithoutRowsInput, ReferenceTableUncheckedCreateWithoutRowsInput>
    connectOrCreate?: ReferenceTableCreateOrConnectWithoutRowsInput
    upsert?: ReferenceTableUpsertWithoutRowsInput
    connect?: ReferenceTableWhereUniqueInput
    update?: XOR<XOR<ReferenceTableUpdateToOneWithWhereWithoutRowsInput, ReferenceTableUpdateWithoutRowsInput>, ReferenceTableUncheckedUpdateWithoutRowsInput>
  }

  export type ReferenceTableCellUncheckedUpdateManyWithoutRowNestedInput = {
    create?: XOR<ReferenceTableCellCreateWithoutRowInput, ReferenceTableCellUncheckedCreateWithoutRowInput> | ReferenceTableCellCreateWithoutRowInput[] | ReferenceTableCellUncheckedCreateWithoutRowInput[]
    connectOrCreate?: ReferenceTableCellCreateOrConnectWithoutRowInput | ReferenceTableCellCreateOrConnectWithoutRowInput[]
    upsert?: ReferenceTableCellUpsertWithWhereUniqueWithoutRowInput | ReferenceTableCellUpsertWithWhereUniqueWithoutRowInput[]
    createMany?: ReferenceTableCellCreateManyRowInputEnvelope
    set?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    disconnect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    delete?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    connect?: ReferenceTableCellWhereUniqueInput | ReferenceTableCellWhereUniqueInput[]
    update?: ReferenceTableCellUpdateWithWhereUniqueWithoutRowInput | ReferenceTableCellUpdateWithWhereUniqueWithoutRowInput[]
    updateMany?: ReferenceTableCellUpdateManyWithWhereWithoutRowInput | ReferenceTableCellUpdateManyWithWhereWithoutRowInput[]
    deleteMany?: ReferenceTableCellScalarWhereInput | ReferenceTableCellScalarWhereInput[]
  }

  export type ReferenceTableColumnCreateNestedOneWithoutCellsInput = {
    create?: XOR<ReferenceTableColumnCreateWithoutCellsInput, ReferenceTableColumnUncheckedCreateWithoutCellsInput>
    connectOrCreate?: ReferenceTableColumnCreateOrConnectWithoutCellsInput
    connect?: ReferenceTableColumnWhereUniqueInput
  }

  export type ReferenceTableRowCreateNestedOneWithoutCellsInput = {
    create?: XOR<ReferenceTableRowCreateWithoutCellsInput, ReferenceTableRowUncheckedCreateWithoutCellsInput>
    connectOrCreate?: ReferenceTableRowCreateOrConnectWithoutCellsInput
    connect?: ReferenceTableRowWhereUniqueInput
  }

  export type ReferenceTableColumnUpdateOneRequiredWithoutCellsNestedInput = {
    create?: XOR<ReferenceTableColumnCreateWithoutCellsInput, ReferenceTableColumnUncheckedCreateWithoutCellsInput>
    connectOrCreate?: ReferenceTableColumnCreateOrConnectWithoutCellsInput
    upsert?: ReferenceTableColumnUpsertWithoutCellsInput
    connect?: ReferenceTableColumnWhereUniqueInput
    update?: XOR<XOR<ReferenceTableColumnUpdateToOneWithWhereWithoutCellsInput, ReferenceTableColumnUpdateWithoutCellsInput>, ReferenceTableColumnUncheckedUpdateWithoutCellsInput>
  }

  export type ReferenceTableRowUpdateOneRequiredWithoutCellsNestedInput = {
    create?: XOR<ReferenceTableRowCreateWithoutCellsInput, ReferenceTableRowUncheckedCreateWithoutCellsInput>
    connectOrCreate?: ReferenceTableRowCreateOrConnectWithoutCellsInput
    upsert?: ReferenceTableRowUpsertWithoutCellsInput
    connect?: ReferenceTableRowWhereUniqueInput
    update?: XOR<XOR<ReferenceTableRowUpdateToOneWithWhereWithoutCellsInput, ReferenceTableRowUpdateWithoutCellsInput>, ReferenceTableRowUncheckedUpdateWithoutCellsInput>
  }

  export type UserCharacterAttributeCreateNestedManyWithoutCharacterInput = {
    create?: XOR<UserCharacterAttributeCreateWithoutCharacterInput, UserCharacterAttributeUncheckedCreateWithoutCharacterInput> | UserCharacterAttributeCreateWithoutCharacterInput[] | UserCharacterAttributeUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: UserCharacterAttributeCreateOrConnectWithoutCharacterInput | UserCharacterAttributeCreateOrConnectWithoutCharacterInput[]
    createMany?: UserCharacterAttributeCreateManyCharacterInputEnvelope
    connect?: UserCharacterAttributeWhereUniqueInput | UserCharacterAttributeWhereUniqueInput[]
  }

  export type RaceCreateNestedOneWithoutUserCharacterInput = {
    create?: XOR<RaceCreateWithoutUserCharacterInput, RaceUncheckedCreateWithoutUserCharacterInput>
    connectOrCreate?: RaceCreateOrConnectWithoutUserCharacterInput
    connect?: RaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCharactersInput = {
    create?: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharactersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCharacterAttributeUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<UserCharacterAttributeCreateWithoutCharacterInput, UserCharacterAttributeUncheckedCreateWithoutCharacterInput> | UserCharacterAttributeCreateWithoutCharacterInput[] | UserCharacterAttributeUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: UserCharacterAttributeCreateOrConnectWithoutCharacterInput | UserCharacterAttributeCreateOrConnectWithoutCharacterInput[]
    createMany?: UserCharacterAttributeCreateManyCharacterInputEnvelope
    connect?: UserCharacterAttributeWhereUniqueInput | UserCharacterAttributeWhereUniqueInput[]
  }

  export type UserCharacterAttributeUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<UserCharacterAttributeCreateWithoutCharacterInput, UserCharacterAttributeUncheckedCreateWithoutCharacterInput> | UserCharacterAttributeCreateWithoutCharacterInput[] | UserCharacterAttributeUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: UserCharacterAttributeCreateOrConnectWithoutCharacterInput | UserCharacterAttributeCreateOrConnectWithoutCharacterInput[]
    upsert?: UserCharacterAttributeUpsertWithWhereUniqueWithoutCharacterInput | UserCharacterAttributeUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: UserCharacterAttributeCreateManyCharacterInputEnvelope
    set?: UserCharacterAttributeWhereUniqueInput | UserCharacterAttributeWhereUniqueInput[]
    disconnect?: UserCharacterAttributeWhereUniqueInput | UserCharacterAttributeWhereUniqueInput[]
    delete?: UserCharacterAttributeWhereUniqueInput | UserCharacterAttributeWhereUniqueInput[]
    connect?: UserCharacterAttributeWhereUniqueInput | UserCharacterAttributeWhereUniqueInput[]
    update?: UserCharacterAttributeUpdateWithWhereUniqueWithoutCharacterInput | UserCharacterAttributeUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: UserCharacterAttributeUpdateManyWithWhereWithoutCharacterInput | UserCharacterAttributeUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: UserCharacterAttributeScalarWhereInput | UserCharacterAttributeScalarWhereInput[]
  }

  export type RaceUpdateOneRequiredWithoutUserCharacterNestedInput = {
    create?: XOR<RaceCreateWithoutUserCharacterInput, RaceUncheckedCreateWithoutUserCharacterInput>
    connectOrCreate?: RaceCreateOrConnectWithoutUserCharacterInput
    upsert?: RaceUpsertWithoutUserCharacterInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutUserCharacterInput, RaceUpdateWithoutUserCharacterInput>, RaceUncheckedUpdateWithoutUserCharacterInput>
  }

  export type UserUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharactersInput
    upsert?: UserUpsertWithoutCharactersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCharactersInput, UserUpdateWithoutCharactersInput>, UserUncheckedUpdateWithoutCharactersInput>
  }

  export type UserCharacterAttributeUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<UserCharacterAttributeCreateWithoutCharacterInput, UserCharacterAttributeUncheckedCreateWithoutCharacterInput> | UserCharacterAttributeCreateWithoutCharacterInput[] | UserCharacterAttributeUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: UserCharacterAttributeCreateOrConnectWithoutCharacterInput | UserCharacterAttributeCreateOrConnectWithoutCharacterInput[]
    upsert?: UserCharacterAttributeUpsertWithWhereUniqueWithoutCharacterInput | UserCharacterAttributeUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: UserCharacterAttributeCreateManyCharacterInputEnvelope
    set?: UserCharacterAttributeWhereUniqueInput | UserCharacterAttributeWhereUniqueInput[]
    disconnect?: UserCharacterAttributeWhereUniqueInput | UserCharacterAttributeWhereUniqueInput[]
    delete?: UserCharacterAttributeWhereUniqueInput | UserCharacterAttributeWhereUniqueInput[]
    connect?: UserCharacterAttributeWhereUniqueInput | UserCharacterAttributeWhereUniqueInput[]
    update?: UserCharacterAttributeUpdateWithWhereUniqueWithoutCharacterInput | UserCharacterAttributeUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: UserCharacterAttributeUpdateManyWithWhereWithoutCharacterInput | UserCharacterAttributeUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: UserCharacterAttributeScalarWhereInput | UserCharacterAttributeScalarWhereInput[]
  }

  export type UserCharacterCreateNestedOneWithoutAttributesInput = {
    create?: XOR<UserCharacterCreateWithoutAttributesInput, UserCharacterUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: UserCharacterCreateOrConnectWithoutAttributesInput
    connect?: UserCharacterWhereUniqueInput
  }

  export type UserCharacterUpdateOneRequiredWithoutAttributesNestedInput = {
    create?: XOR<UserCharacterCreateWithoutAttributesInput, UserCharacterUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: UserCharacterCreateOrConnectWithoutAttributesInput
    upsert?: UserCharacterUpsertWithoutAttributesInput
    connect?: UserCharacterWhereUniqueInput
    update?: XOR<XOR<UserCharacterUpdateToOneWithWhereWithoutAttributesInput, UserCharacterUpdateWithoutAttributesInput>, UserCharacterUncheckedUpdateWithoutAttributesInput>
  }

  export type UserCharacterCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCharacterCreateWithoutUserInput, UserCharacterUncheckedCreateWithoutUserInput> | UserCharacterCreateWithoutUserInput[] | UserCharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCharacterCreateOrConnectWithoutUserInput | UserCharacterCreateOrConnectWithoutUserInput[]
    createMany?: UserCharacterCreateManyUserInputEnvelope
    connect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
  }

  export type UserCharacterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCharacterCreateWithoutUserInput, UserCharacterUncheckedCreateWithoutUserInput> | UserCharacterCreateWithoutUserInput[] | UserCharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCharacterCreateOrConnectWithoutUserInput | UserCharacterCreateOrConnectWithoutUserInput[]
    createMany?: UserCharacterCreateManyUserInputEnvelope
    connect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserCharacterUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCharacterCreateWithoutUserInput, UserCharacterUncheckedCreateWithoutUserInput> | UserCharacterCreateWithoutUserInput[] | UserCharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCharacterCreateOrConnectWithoutUserInput | UserCharacterCreateOrConnectWithoutUserInput[]
    upsert?: UserCharacterUpsertWithWhereUniqueWithoutUserInput | UserCharacterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCharacterCreateManyUserInputEnvelope
    set?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    disconnect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    delete?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    connect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    update?: UserCharacterUpdateWithWhereUniqueWithoutUserInput | UserCharacterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCharacterUpdateManyWithWhereWithoutUserInput | UserCharacterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCharacterScalarWhereInput | UserCharacterScalarWhereInput[]
  }

  export type UserCharacterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCharacterCreateWithoutUserInput, UserCharacterUncheckedCreateWithoutUserInput> | UserCharacterCreateWithoutUserInput[] | UserCharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCharacterCreateOrConnectWithoutUserInput | UserCharacterCreateOrConnectWithoutUserInput[]
    upsert?: UserCharacterUpsertWithWhereUniqueWithoutUserInput | UserCharacterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCharacterCreateManyUserInputEnvelope
    set?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    disconnect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    delete?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    connect?: UserCharacterWhereUniqueInput | UserCharacterWhereUniqueInput[]
    update?: UserCharacterUpdateWithWhereUniqueWithoutUserInput | UserCharacterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCharacterUpdateManyWithWhereWithoutUserInput | UserCharacterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCharacterScalarWhereInput | UserCharacterScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ClassFeatureCreateWithoutClassInput = {
    name: string
    description?: string | null
    level?: number | null
  }

  export type ClassFeatureUncheckedCreateWithoutClassInput = {
    id?: number
    name: string
    description?: string | null
    level?: number | null
  }

  export type ClassFeatureCreateOrConnectWithoutClassInput = {
    where: ClassFeatureWhereUniqueInput
    create: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput>
  }

  export type ClassFeatureCreateManyClassInputEnvelope = {
    data: ClassFeatureCreateManyClassInput | ClassFeatureCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassLevelAttributeCreateWithoutClassInput = {
    baseAttackBonus: number
    fortSave: number
    refSave: number
    willSave: number
  }

  export type ClassLevelAttributeUncheckedCreateWithoutClassInput = {
    id?: number
    baseAttackBonus: number
    fortSave: number
    refSave: number
    willSave: number
  }

  export type ClassLevelAttributeCreateOrConnectWithoutClassInput = {
    where: ClassLevelAttributeWhereUniqueInput
    create: XOR<ClassLevelAttributeCreateWithoutClassInput, ClassLevelAttributeUncheckedCreateWithoutClassInput>
  }

  export type ClassLevelAttributeCreateManyClassInputEnvelope = {
    data: ClassLevelAttributeCreateManyClassInput | ClassLevelAttributeCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassSpellLevelCreateWithoutClassInput = {
    spellLevel: number
  }

  export type ClassSpellLevelUncheckedCreateWithoutClassInput = {
    id?: number
    spellLevel: number
  }

  export type ClassSpellLevelCreateOrConnectWithoutClassInput = {
    where: ClassSpellLevelWhereUniqueInput
    create: XOR<ClassSpellLevelCreateWithoutClassInput, ClassSpellLevelUncheckedCreateWithoutClassInput>
  }

  export type ClassSpellLevelCreateManyClassInputEnvelope = {
    data: ClassSpellLevelCreateManyClassInput | ClassSpellLevelCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassSkillMapCreateWithoutClassInput = {
    Skill: SkillCreateNestedOneWithoutClassesInput
  }

  export type ClassSkillMapUncheckedCreateWithoutClassInput = {
    id?: number
    skillId: number
  }

  export type ClassSkillMapCreateOrConnectWithoutClassInput = {
    where: ClassSkillMapWhereUniqueInput
    create: XOR<ClassSkillMapCreateWithoutClassInput, ClassSkillMapUncheckedCreateWithoutClassInput>
  }

  export type ClassSkillMapCreateManyClassInputEnvelope = {
    data: ClassSkillMapCreateManyClassInput | ClassSkillMapCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassSourceMapCreateWithoutClassInput = {
    bookId: number
    pageNumber?: number | null
    SourceBook?: SourceBookCreateNestedOneWithoutClassesInput
  }

  export type ClassSourceMapUncheckedCreateWithoutClassInput = {
    id?: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type ClassSourceMapCreateOrConnectWithoutClassInput = {
    where: ClassSourceMapWhereUniqueInput
    create: XOR<ClassSourceMapCreateWithoutClassInput, ClassSourceMapUncheckedCreateWithoutClassInput>
  }

  export type ClassSourceMapCreateManyClassInputEnvelope = {
    data: ClassSourceMapCreateManyClassInput | ClassSourceMapCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type SpellLevelMapCreateWithoutClassInput = {
    level: number
    isVisible?: boolean
    spell: SpellCreateNestedOneWithoutLevelMappingInput
  }

  export type SpellLevelMapUncheckedCreateWithoutClassInput = {
    id?: number
    spellId: number
    level: number
    isVisible?: boolean
  }

  export type SpellLevelMapCreateOrConnectWithoutClassInput = {
    where: SpellLevelMapWhereUniqueInput
    create: XOR<SpellLevelMapCreateWithoutClassInput, SpellLevelMapUncheckedCreateWithoutClassInput>
  }

  export type SpellLevelMapCreateManyClassInputEnvelope = {
    data: SpellLevelMapCreateManyClassInput | SpellLevelMapCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassFeatureUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassFeatureWhereUniqueInput
    update: XOR<ClassFeatureUpdateWithoutClassInput, ClassFeatureUncheckedUpdateWithoutClassInput>
    create: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput>
  }

  export type ClassFeatureUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassFeatureWhereUniqueInput
    data: XOR<ClassFeatureUpdateWithoutClassInput, ClassFeatureUncheckedUpdateWithoutClassInput>
  }

  export type ClassFeatureUpdateManyWithWhereWithoutClassInput = {
    where: ClassFeatureScalarWhereInput
    data: XOR<ClassFeatureUpdateManyMutationInput, ClassFeatureUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassFeatureScalarWhereInput = {
    AND?: ClassFeatureScalarWhereInput | ClassFeatureScalarWhereInput[]
    OR?: ClassFeatureScalarWhereInput[]
    NOT?: ClassFeatureScalarWhereInput | ClassFeatureScalarWhereInput[]
    id?: IntFilter<"ClassFeature"> | number
    classId?: IntFilter<"ClassFeature"> | number
    name?: StringFilter<"ClassFeature"> | string
    description?: StringNullableFilter<"ClassFeature"> | string | null
    level?: IntNullableFilter<"ClassFeature"> | number | null
  }

  export type ClassLevelAttributeUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassLevelAttributeWhereUniqueInput
    update: XOR<ClassLevelAttributeUpdateWithoutClassInput, ClassLevelAttributeUncheckedUpdateWithoutClassInput>
    create: XOR<ClassLevelAttributeCreateWithoutClassInput, ClassLevelAttributeUncheckedCreateWithoutClassInput>
  }

  export type ClassLevelAttributeUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassLevelAttributeWhereUniqueInput
    data: XOR<ClassLevelAttributeUpdateWithoutClassInput, ClassLevelAttributeUncheckedUpdateWithoutClassInput>
  }

  export type ClassLevelAttributeUpdateManyWithWhereWithoutClassInput = {
    where: ClassLevelAttributeScalarWhereInput
    data: XOR<ClassLevelAttributeUpdateManyMutationInput, ClassLevelAttributeUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassLevelAttributeScalarWhereInput = {
    AND?: ClassLevelAttributeScalarWhereInput | ClassLevelAttributeScalarWhereInput[]
    OR?: ClassLevelAttributeScalarWhereInput[]
    NOT?: ClassLevelAttributeScalarWhereInput | ClassLevelAttributeScalarWhereInput[]
    id?: IntFilter<"ClassLevelAttribute"> | number
    classId?: IntFilter<"ClassLevelAttribute"> | number
    baseAttackBonus?: IntFilter<"ClassLevelAttribute"> | number
    fortSave?: IntFilter<"ClassLevelAttribute"> | number
    refSave?: IntFilter<"ClassLevelAttribute"> | number
    willSave?: IntFilter<"ClassLevelAttribute"> | number
  }

  export type ClassSpellLevelUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassSpellLevelWhereUniqueInput
    update: XOR<ClassSpellLevelUpdateWithoutClassInput, ClassSpellLevelUncheckedUpdateWithoutClassInput>
    create: XOR<ClassSpellLevelCreateWithoutClassInput, ClassSpellLevelUncheckedCreateWithoutClassInput>
  }

  export type ClassSpellLevelUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassSpellLevelWhereUniqueInput
    data: XOR<ClassSpellLevelUpdateWithoutClassInput, ClassSpellLevelUncheckedUpdateWithoutClassInput>
  }

  export type ClassSpellLevelUpdateManyWithWhereWithoutClassInput = {
    where: ClassSpellLevelScalarWhereInput
    data: XOR<ClassSpellLevelUpdateManyMutationInput, ClassSpellLevelUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassSpellLevelScalarWhereInput = {
    AND?: ClassSpellLevelScalarWhereInput | ClassSpellLevelScalarWhereInput[]
    OR?: ClassSpellLevelScalarWhereInput[]
    NOT?: ClassSpellLevelScalarWhereInput | ClassSpellLevelScalarWhereInput[]
    id?: IntFilter<"ClassSpellLevel"> | number
    classId?: IntFilter<"ClassSpellLevel"> | number
    spellLevel?: IntFilter<"ClassSpellLevel"> | number
  }

  export type ClassSkillMapUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassSkillMapWhereUniqueInput
    update: XOR<ClassSkillMapUpdateWithoutClassInput, ClassSkillMapUncheckedUpdateWithoutClassInput>
    create: XOR<ClassSkillMapCreateWithoutClassInput, ClassSkillMapUncheckedCreateWithoutClassInput>
  }

  export type ClassSkillMapUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassSkillMapWhereUniqueInput
    data: XOR<ClassSkillMapUpdateWithoutClassInput, ClassSkillMapUncheckedUpdateWithoutClassInput>
  }

  export type ClassSkillMapUpdateManyWithWhereWithoutClassInput = {
    where: ClassSkillMapScalarWhereInput
    data: XOR<ClassSkillMapUpdateManyMutationInput, ClassSkillMapUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassSkillMapScalarWhereInput = {
    AND?: ClassSkillMapScalarWhereInput | ClassSkillMapScalarWhereInput[]
    OR?: ClassSkillMapScalarWhereInput[]
    NOT?: ClassSkillMapScalarWhereInput | ClassSkillMapScalarWhereInput[]
    id?: IntFilter<"ClassSkillMap"> | number
    classId?: IntFilter<"ClassSkillMap"> | number
    skillId?: IntFilter<"ClassSkillMap"> | number
  }

  export type ClassSourceMapUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassSourceMapWhereUniqueInput
    update: XOR<ClassSourceMapUpdateWithoutClassInput, ClassSourceMapUncheckedUpdateWithoutClassInput>
    create: XOR<ClassSourceMapCreateWithoutClassInput, ClassSourceMapUncheckedCreateWithoutClassInput>
  }

  export type ClassSourceMapUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassSourceMapWhereUniqueInput
    data: XOR<ClassSourceMapUpdateWithoutClassInput, ClassSourceMapUncheckedUpdateWithoutClassInput>
  }

  export type ClassSourceMapUpdateManyWithWhereWithoutClassInput = {
    where: ClassSourceMapScalarWhereInput
    data: XOR<ClassSourceMapUpdateManyMutationInput, ClassSourceMapUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassSourceMapScalarWhereInput = {
    AND?: ClassSourceMapScalarWhereInput | ClassSourceMapScalarWhereInput[]
    OR?: ClassSourceMapScalarWhereInput[]
    NOT?: ClassSourceMapScalarWhereInput | ClassSourceMapScalarWhereInput[]
    id?: IntFilter<"ClassSourceMap"> | number
    classId?: IntFilter<"ClassSourceMap"> | number
    bookId?: IntFilter<"ClassSourceMap"> | number
    pageNumber?: IntNullableFilter<"ClassSourceMap"> | number | null
    sourceBookId?: IntNullableFilter<"ClassSourceMap"> | number | null
  }

  export type SpellLevelMapUpsertWithWhereUniqueWithoutClassInput = {
    where: SpellLevelMapWhereUniqueInput
    update: XOR<SpellLevelMapUpdateWithoutClassInput, SpellLevelMapUncheckedUpdateWithoutClassInput>
    create: XOR<SpellLevelMapCreateWithoutClassInput, SpellLevelMapUncheckedCreateWithoutClassInput>
  }

  export type SpellLevelMapUpdateWithWhereUniqueWithoutClassInput = {
    where: SpellLevelMapWhereUniqueInput
    data: XOR<SpellLevelMapUpdateWithoutClassInput, SpellLevelMapUncheckedUpdateWithoutClassInput>
  }

  export type SpellLevelMapUpdateManyWithWhereWithoutClassInput = {
    where: SpellLevelMapScalarWhereInput
    data: XOR<SpellLevelMapUpdateManyMutationInput, SpellLevelMapUncheckedUpdateManyWithoutClassInput>
  }

  export type SpellLevelMapScalarWhereInput = {
    AND?: SpellLevelMapScalarWhereInput | SpellLevelMapScalarWhereInput[]
    OR?: SpellLevelMapScalarWhereInput[]
    NOT?: SpellLevelMapScalarWhereInput | SpellLevelMapScalarWhereInput[]
    id?: IntFilter<"SpellLevelMap"> | number
    classId?: IntFilter<"SpellLevelMap"> | number
    spellId?: IntFilter<"SpellLevelMap"> | number
    level?: IntFilter<"SpellLevelMap"> | number
    isVisible?: BoolFilter<"SpellLevelMap"> | boolean
  }

  export type ClassCreateWithoutFeaturesInput = {
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    attributes?: ClassLevelAttributeCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutFeaturesInput = {
    id?: number
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    attributes?: ClassLevelAttributeUncheckedCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelUncheckedCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapUncheckedCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapUncheckedCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutFeaturesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutFeaturesInput, ClassUncheckedCreateWithoutFeaturesInput>
  }

  export type ClassUpsertWithoutFeaturesInput = {
    update: XOR<ClassUpdateWithoutFeaturesInput, ClassUncheckedUpdateWithoutFeaturesInput>
    create: XOR<ClassCreateWithoutFeaturesInput, ClassUncheckedCreateWithoutFeaturesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutFeaturesInput, ClassUncheckedUpdateWithoutFeaturesInput>
  }

  export type ClassUpdateWithoutFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    attributes?: ClassLevelAttributeUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutFeaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    attributes?: ClassLevelAttributeUncheckedUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUncheckedUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUncheckedUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUncheckedUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateWithoutSpellProgressionInput = {
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureCreateNestedManyWithoutClassInput
    attributes?: ClassLevelAttributeCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSpellProgressionInput = {
    id?: number
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureUncheckedCreateNestedManyWithoutClassInput
    attributes?: ClassLevelAttributeUncheckedCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapUncheckedCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapUncheckedCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSpellProgressionInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSpellProgressionInput, ClassUncheckedCreateWithoutSpellProgressionInput>
  }

  export type ClassUpsertWithoutSpellProgressionInput = {
    update: XOR<ClassUpdateWithoutSpellProgressionInput, ClassUncheckedUpdateWithoutSpellProgressionInput>
    create: XOR<ClassCreateWithoutSpellProgressionInput, ClassUncheckedCreateWithoutSpellProgressionInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSpellProgressionInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSpellProgressionInput, ClassUncheckedUpdateWithoutSpellProgressionInput>
  }

  export type ClassUpdateWithoutSpellProgressionInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUpdateManyWithoutClassNestedInput
    attributes?: ClassLevelAttributeUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSpellProgressionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUncheckedUpdateManyWithoutClassNestedInput
    attributes?: ClassLevelAttributeUncheckedUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUncheckedUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUncheckedUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateWithoutAttributesInput = {
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutAttributesInput = {
    id?: number
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureUncheckedCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelUncheckedCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapUncheckedCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapUncheckedCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutAttributesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutAttributesInput, ClassUncheckedCreateWithoutAttributesInput>
  }

  export type ClassUpsertWithoutAttributesInput = {
    update: XOR<ClassUpdateWithoutAttributesInput, ClassUncheckedUpdateWithoutAttributesInput>
    create: XOR<ClassCreateWithoutAttributesInput, ClassUncheckedCreateWithoutAttributesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutAttributesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutAttributesInput, ClassUncheckedUpdateWithoutAttributesInput>
  }

  export type ClassUpdateWithoutAttributesInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutAttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUncheckedUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUncheckedUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUncheckedUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUncheckedUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateWithoutSkillsInput = {
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureCreateNestedManyWithoutClassInput
    attributes?: ClassLevelAttributeCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSkillsInput = {
    id?: number
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureUncheckedCreateNestedManyWithoutClassInput
    attributes?: ClassLevelAttributeUncheckedCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelUncheckedCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapUncheckedCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSkillsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSkillsInput, ClassUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutClassesInput = {
    name: string
    abilityId?: number
    checkDescription?: string | null
    actionDescription?: string | null
    retryTypeId?: number | null
    retryDescription?: string | null
    specialNotes?: string | null
    synergyNotes?: string | null
    untrainedNotes?: string | null
    affectedByArmor?: boolean
    description?: string | null
    trainedOnly?: boolean | null
  }

  export type SkillUncheckedCreateWithoutClassesInput = {
    id?: number
    name: string
    abilityId?: number
    checkDescription?: string | null
    actionDescription?: string | null
    retryTypeId?: number | null
    retryDescription?: string | null
    specialNotes?: string | null
    synergyNotes?: string | null
    untrainedNotes?: string | null
    affectedByArmor?: boolean
    description?: string | null
    trainedOnly?: boolean | null
  }

  export type SkillCreateOrConnectWithoutClassesInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutClassesInput, SkillUncheckedCreateWithoutClassesInput>
  }

  export type ClassUpsertWithoutSkillsInput = {
    update: XOR<ClassUpdateWithoutSkillsInput, ClassUncheckedUpdateWithoutSkillsInput>
    create: XOR<ClassCreateWithoutSkillsInput, ClassUncheckedCreateWithoutSkillsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSkillsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSkillsInput, ClassUncheckedUpdateWithoutSkillsInput>
  }

  export type ClassUpdateWithoutSkillsInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUpdateManyWithoutClassNestedInput
    attributes?: ClassLevelAttributeUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUncheckedUpdateManyWithoutClassNestedInput
    attributes?: ClassLevelAttributeUncheckedUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUncheckedUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUncheckedUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SkillUpsertWithoutClassesInput = {
    update: XOR<SkillUpdateWithoutClassesInput, SkillUncheckedUpdateWithoutClassesInput>
    create: XOR<SkillCreateWithoutClassesInput, SkillUncheckedCreateWithoutClassesInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutClassesInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutClassesInput, SkillUncheckedUpdateWithoutClassesInput>
  }

  export type SkillUpdateWithoutClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    abilityId?: IntFieldUpdateOperationsInput | number
    checkDescription?: NullableStringFieldUpdateOperationsInput | string | null
    actionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    retryTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    retryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    synergyNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untrainedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    affectedByArmor?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainedOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SkillUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilityId?: IntFieldUpdateOperationsInput | number
    checkDescription?: NullableStringFieldUpdateOperationsInput | string | null
    actionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    retryTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    retryDescription?: NullableStringFieldUpdateOperationsInput | string | null
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    synergyNotes?: NullableStringFieldUpdateOperationsInput | string | null
    untrainedNotes?: NullableStringFieldUpdateOperationsInput | string | null
    affectedByArmor?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainedOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ClassCreateWithoutSourcesInput = {
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureCreateNestedManyWithoutClassInput
    attributes?: ClassLevelAttributeCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSourcesInput = {
    id?: number
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureUncheckedCreateNestedManyWithoutClassInput
    attributes?: ClassLevelAttributeUncheckedCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelUncheckedCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapUncheckedCreateNestedManyWithoutClassInput
    spellLevels?: SpellLevelMapUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSourcesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSourcesInput, ClassUncheckedCreateWithoutSourcesInput>
  }

  export type SourceBookCreateWithoutClassesInput = {
    name: string
    abbreviation: string
    releaseDate?: Date | string | null
    editionId?: number | null
    description?: string | null
    isVisible?: boolean
    races?: RaceSourceMapCreateNestedManyWithoutSourceBookInput
    spells?: SpellSourceMapCreateNestedManyWithoutSourceBookInput
  }

  export type SourceBookUncheckedCreateWithoutClassesInput = {
    id?: number
    name: string
    abbreviation: string
    releaseDate?: Date | string | null
    editionId?: number | null
    description?: string | null
    isVisible?: boolean
    races?: RaceSourceMapUncheckedCreateNestedManyWithoutSourceBookInput
    spells?: SpellSourceMapUncheckedCreateNestedManyWithoutSourceBookInput
  }

  export type SourceBookCreateOrConnectWithoutClassesInput = {
    where: SourceBookWhereUniqueInput
    create: XOR<SourceBookCreateWithoutClassesInput, SourceBookUncheckedCreateWithoutClassesInput>
  }

  export type ClassUpsertWithoutSourcesInput = {
    update: XOR<ClassUpdateWithoutSourcesInput, ClassUncheckedUpdateWithoutSourcesInput>
    create: XOR<ClassCreateWithoutSourcesInput, ClassUncheckedCreateWithoutSourcesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSourcesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSourcesInput, ClassUncheckedUpdateWithoutSourcesInput>
  }

  export type ClassUpdateWithoutSourcesInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUpdateManyWithoutClassNestedInput
    attributes?: ClassLevelAttributeUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUncheckedUpdateManyWithoutClassNestedInput
    attributes?: ClassLevelAttributeUncheckedUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUncheckedUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUncheckedUpdateManyWithoutClassNestedInput
    spellLevels?: SpellLevelMapUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SourceBookUpsertWithoutClassesInput = {
    update: XOR<SourceBookUpdateWithoutClassesInput, SourceBookUncheckedUpdateWithoutClassesInput>
    create: XOR<SourceBookCreateWithoutClassesInput, SourceBookUncheckedCreateWithoutClassesInput>
    where?: SourceBookWhereInput
  }

  export type SourceBookUpdateToOneWithWhereWithoutClassesInput = {
    where?: SourceBookWhereInput
    data: XOR<SourceBookUpdateWithoutClassesInput, SourceBookUncheckedUpdateWithoutClassesInput>
  }

  export type SourceBookUpdateWithoutClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    races?: RaceSourceMapUpdateManyWithoutSourceBookNestedInput
    spells?: SpellSourceMapUpdateManyWithoutSourceBookNestedInput
  }

  export type SourceBookUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    races?: RaceSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput
    spells?: SpellSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput
  }

  export type SpellCreateWithoutLevelMappingInput = {
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    descriptors?: SpellDescriptorMapCreateNestedManyWithoutSpellInput
    schools?: SpellSchoolMapCreateNestedManyWithoutSpellInput
    sources?: SpellSourceMapCreateNestedManyWithoutSpellInput
    subschools?: SpellSubschoolMapCreateNestedManyWithoutSpellInput
  }

  export type SpellUncheckedCreateWithoutLevelMappingInput = {
    id?: number
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    descriptors?: SpellDescriptorMapUncheckedCreateNestedManyWithoutSpellInput
    schools?: SpellSchoolMapUncheckedCreateNestedManyWithoutSpellInput
    sources?: SpellSourceMapUncheckedCreateNestedManyWithoutSpellInput
    subschools?: SpellSubschoolMapUncheckedCreateNestedManyWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutLevelMappingInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutLevelMappingInput, SpellUncheckedCreateWithoutLevelMappingInput>
  }

  export type ClassCreateWithoutSpellLevelsInput = {
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureCreateNestedManyWithoutClassInput
    attributes?: ClassLevelAttributeCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSpellLevelsInput = {
    id?: number
    name: string
    abbreviation: string
    editionId?: number | null
    isPrestige?: boolean
    isVisible?: boolean
    canCastSpells?: boolean
    hitDie?: number
    description?: string | null
    skillPoints: number
    castingAbilityId?: number | null
    features?: ClassFeatureUncheckedCreateNestedManyWithoutClassInput
    attributes?: ClassLevelAttributeUncheckedCreateNestedManyWithoutClassInput
    spellProgression?: ClassSpellLevelUncheckedCreateNestedManyWithoutClassInput
    skills?: ClassSkillMapUncheckedCreateNestedManyWithoutClassInput
    sources?: ClassSourceMapUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSpellLevelsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSpellLevelsInput, ClassUncheckedCreateWithoutSpellLevelsInput>
  }

  export type SpellUpsertWithoutLevelMappingInput = {
    update: XOR<SpellUpdateWithoutLevelMappingInput, SpellUncheckedUpdateWithoutLevelMappingInput>
    create: XOR<SpellCreateWithoutLevelMappingInput, SpellUncheckedCreateWithoutLevelMappingInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutLevelMappingInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutLevelMappingInput, SpellUncheckedUpdateWithoutLevelMappingInput>
  }

  export type SpellUpdateWithoutLevelMappingInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    descriptors?: SpellDescriptorMapUpdateManyWithoutSpellNestedInput
    schools?: SpellSchoolMapUpdateManyWithoutSpellNestedInput
    sources?: SpellSourceMapUpdateManyWithoutSpellNestedInput
    subschools?: SpellSubschoolMapUpdateManyWithoutSpellNestedInput
  }

  export type SpellUncheckedUpdateWithoutLevelMappingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    descriptors?: SpellDescriptorMapUncheckedUpdateManyWithoutSpellNestedInput
    schools?: SpellSchoolMapUncheckedUpdateManyWithoutSpellNestedInput
    sources?: SpellSourceMapUncheckedUpdateManyWithoutSpellNestedInput
    subschools?: SpellSubschoolMapUncheckedUpdateManyWithoutSpellNestedInput
  }

  export type ClassUpsertWithoutSpellLevelsInput = {
    update: XOR<ClassUpdateWithoutSpellLevelsInput, ClassUncheckedUpdateWithoutSpellLevelsInput>
    create: XOR<ClassCreateWithoutSpellLevelsInput, ClassUncheckedCreateWithoutSpellLevelsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSpellLevelsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSpellLevelsInput, ClassUncheckedUpdateWithoutSpellLevelsInput>
  }

  export type ClassUpdateWithoutSpellLevelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUpdateManyWithoutClassNestedInput
    attributes?: ClassLevelAttributeUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSpellLevelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPrestige?: BoolFieldUpdateOperationsInput | boolean
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    canCastSpells?: BoolFieldUpdateOperationsInput | boolean
    hitDie?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    skillPoints?: IntFieldUpdateOperationsInput | number
    castingAbilityId?: NullableIntFieldUpdateOperationsInput | number | null
    features?: ClassFeatureUncheckedUpdateManyWithoutClassNestedInput
    attributes?: ClassLevelAttributeUncheckedUpdateManyWithoutClassNestedInput
    spellProgression?: ClassSpellLevelUncheckedUpdateManyWithoutClassNestedInput
    skills?: ClassSkillMapUncheckedUpdateManyWithoutClassNestedInput
    sources?: ClassSourceMapUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SpellDescriptorMapCreateWithoutSpellInput = {
    descriptorId: number
  }

  export type SpellDescriptorMapUncheckedCreateWithoutSpellInput = {
    id?: number
    descriptorId: number
  }

  export type SpellDescriptorMapCreateOrConnectWithoutSpellInput = {
    where: SpellDescriptorMapWhereUniqueInput
    create: XOR<SpellDescriptorMapCreateWithoutSpellInput, SpellDescriptorMapUncheckedCreateWithoutSpellInput>
  }

  export type SpellDescriptorMapCreateManySpellInputEnvelope = {
    data: SpellDescriptorMapCreateManySpellInput | SpellDescriptorMapCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellLevelMapCreateWithoutSpellInput = {
    level: number
    isVisible?: boolean
    class: ClassCreateNestedOneWithoutSpellLevelsInput
  }

  export type SpellLevelMapUncheckedCreateWithoutSpellInput = {
    id?: number
    classId: number
    level: number
    isVisible?: boolean
  }

  export type SpellLevelMapCreateOrConnectWithoutSpellInput = {
    where: SpellLevelMapWhereUniqueInput
    create: XOR<SpellLevelMapCreateWithoutSpellInput, SpellLevelMapUncheckedCreateWithoutSpellInput>
  }

  export type SpellLevelMapCreateManySpellInputEnvelope = {
    data: SpellLevelMapCreateManySpellInput | SpellLevelMapCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellSchoolMapCreateWithoutSpellInput = {
    schoolId: number
  }

  export type SpellSchoolMapUncheckedCreateWithoutSpellInput = {
    id?: number
    schoolId: number
  }

  export type SpellSchoolMapCreateOrConnectWithoutSpellInput = {
    where: SpellSchoolMapWhereUniqueInput
    create: XOR<SpellSchoolMapCreateWithoutSpellInput, SpellSchoolMapUncheckedCreateWithoutSpellInput>
  }

  export type SpellSchoolMapCreateManySpellInputEnvelope = {
    data: SpellSchoolMapCreateManySpellInput | SpellSchoolMapCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellSourceMapCreateWithoutSpellInput = {
    bookId: number
    pageNumber?: number | null
    SourceBook?: SourceBookCreateNestedOneWithoutSpellsInput
  }

  export type SpellSourceMapUncheckedCreateWithoutSpellInput = {
    id?: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type SpellSourceMapCreateOrConnectWithoutSpellInput = {
    where: SpellSourceMapWhereUniqueInput
    create: XOR<SpellSourceMapCreateWithoutSpellInput, SpellSourceMapUncheckedCreateWithoutSpellInput>
  }

  export type SpellSourceMapCreateManySpellInputEnvelope = {
    data: SpellSourceMapCreateManySpellInput | SpellSourceMapCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellSubschoolMapCreateWithoutSpellInput = {
    schoolId: number
  }

  export type SpellSubschoolMapUncheckedCreateWithoutSpellInput = {
    id?: number
    schoolId: number
  }

  export type SpellSubschoolMapCreateOrConnectWithoutSpellInput = {
    where: SpellSubschoolMapWhereUniqueInput
    create: XOR<SpellSubschoolMapCreateWithoutSpellInput, SpellSubschoolMapUncheckedCreateWithoutSpellInput>
  }

  export type SpellSubschoolMapCreateManySpellInputEnvelope = {
    data: SpellSubschoolMapCreateManySpellInput | SpellSubschoolMapCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellDescriptorMapUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellDescriptorMapWhereUniqueInput
    update: XOR<SpellDescriptorMapUpdateWithoutSpellInput, SpellDescriptorMapUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellDescriptorMapCreateWithoutSpellInput, SpellDescriptorMapUncheckedCreateWithoutSpellInput>
  }

  export type SpellDescriptorMapUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellDescriptorMapWhereUniqueInput
    data: XOR<SpellDescriptorMapUpdateWithoutSpellInput, SpellDescriptorMapUncheckedUpdateWithoutSpellInput>
  }

  export type SpellDescriptorMapUpdateManyWithWhereWithoutSpellInput = {
    where: SpellDescriptorMapScalarWhereInput
    data: XOR<SpellDescriptorMapUpdateManyMutationInput, SpellDescriptorMapUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellDescriptorMapScalarWhereInput = {
    AND?: SpellDescriptorMapScalarWhereInput | SpellDescriptorMapScalarWhereInput[]
    OR?: SpellDescriptorMapScalarWhereInput[]
    NOT?: SpellDescriptorMapScalarWhereInput | SpellDescriptorMapScalarWhereInput[]
    id?: IntFilter<"SpellDescriptorMap"> | number
    spellId?: IntFilter<"SpellDescriptorMap"> | number
    descriptorId?: IntFilter<"SpellDescriptorMap"> | number
  }

  export type SpellLevelMapUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellLevelMapWhereUniqueInput
    update: XOR<SpellLevelMapUpdateWithoutSpellInput, SpellLevelMapUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellLevelMapCreateWithoutSpellInput, SpellLevelMapUncheckedCreateWithoutSpellInput>
  }

  export type SpellLevelMapUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellLevelMapWhereUniqueInput
    data: XOR<SpellLevelMapUpdateWithoutSpellInput, SpellLevelMapUncheckedUpdateWithoutSpellInput>
  }

  export type SpellLevelMapUpdateManyWithWhereWithoutSpellInput = {
    where: SpellLevelMapScalarWhereInput
    data: XOR<SpellLevelMapUpdateManyMutationInput, SpellLevelMapUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellSchoolMapUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellSchoolMapWhereUniqueInput
    update: XOR<SpellSchoolMapUpdateWithoutSpellInput, SpellSchoolMapUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellSchoolMapCreateWithoutSpellInput, SpellSchoolMapUncheckedCreateWithoutSpellInput>
  }

  export type SpellSchoolMapUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellSchoolMapWhereUniqueInput
    data: XOR<SpellSchoolMapUpdateWithoutSpellInput, SpellSchoolMapUncheckedUpdateWithoutSpellInput>
  }

  export type SpellSchoolMapUpdateManyWithWhereWithoutSpellInput = {
    where: SpellSchoolMapScalarWhereInput
    data: XOR<SpellSchoolMapUpdateManyMutationInput, SpellSchoolMapUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellSchoolMapScalarWhereInput = {
    AND?: SpellSchoolMapScalarWhereInput | SpellSchoolMapScalarWhereInput[]
    OR?: SpellSchoolMapScalarWhereInput[]
    NOT?: SpellSchoolMapScalarWhereInput | SpellSchoolMapScalarWhereInput[]
    id?: IntFilter<"SpellSchoolMap"> | number
    spellId?: IntFilter<"SpellSchoolMap"> | number
    schoolId?: IntFilter<"SpellSchoolMap"> | number
  }

  export type SpellSourceMapUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellSourceMapWhereUniqueInput
    update: XOR<SpellSourceMapUpdateWithoutSpellInput, SpellSourceMapUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellSourceMapCreateWithoutSpellInput, SpellSourceMapUncheckedCreateWithoutSpellInput>
  }

  export type SpellSourceMapUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellSourceMapWhereUniqueInput
    data: XOR<SpellSourceMapUpdateWithoutSpellInput, SpellSourceMapUncheckedUpdateWithoutSpellInput>
  }

  export type SpellSourceMapUpdateManyWithWhereWithoutSpellInput = {
    where: SpellSourceMapScalarWhereInput
    data: XOR<SpellSourceMapUpdateManyMutationInput, SpellSourceMapUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellSourceMapScalarWhereInput = {
    AND?: SpellSourceMapScalarWhereInput | SpellSourceMapScalarWhereInput[]
    OR?: SpellSourceMapScalarWhereInput[]
    NOT?: SpellSourceMapScalarWhereInput | SpellSourceMapScalarWhereInput[]
    id?: IntFilter<"SpellSourceMap"> | number
    spellId?: IntFilter<"SpellSourceMap"> | number
    bookId?: IntFilter<"SpellSourceMap"> | number
    pageNumber?: IntNullableFilter<"SpellSourceMap"> | number | null
    sourceBookId?: IntNullableFilter<"SpellSourceMap"> | number | null
  }

  export type SpellSubschoolMapUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellSubschoolMapWhereUniqueInput
    update: XOR<SpellSubschoolMapUpdateWithoutSpellInput, SpellSubschoolMapUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellSubschoolMapCreateWithoutSpellInput, SpellSubschoolMapUncheckedCreateWithoutSpellInput>
  }

  export type SpellSubschoolMapUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellSubschoolMapWhereUniqueInput
    data: XOR<SpellSubschoolMapUpdateWithoutSpellInput, SpellSubschoolMapUncheckedUpdateWithoutSpellInput>
  }

  export type SpellSubschoolMapUpdateManyWithWhereWithoutSpellInput = {
    where: SpellSubschoolMapScalarWhereInput
    data: XOR<SpellSubschoolMapUpdateManyMutationInput, SpellSubschoolMapUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellSubschoolMapScalarWhereInput = {
    AND?: SpellSubschoolMapScalarWhereInput | SpellSubschoolMapScalarWhereInput[]
    OR?: SpellSubschoolMapScalarWhereInput[]
    NOT?: SpellSubschoolMapScalarWhereInput | SpellSubschoolMapScalarWhereInput[]
    id?: IntFilter<"SpellSubschoolMap"> | number
    spellId?: IntFilter<"SpellSubschoolMap"> | number
    schoolId?: IntFilter<"SpellSubschoolMap"> | number
  }

  export type SpellCreateWithoutDescriptorsInput = {
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    levelMapping?: SpellLevelMapCreateNestedManyWithoutSpellInput
    schools?: SpellSchoolMapCreateNestedManyWithoutSpellInput
    sources?: SpellSourceMapCreateNestedManyWithoutSpellInput
    subschools?: SpellSubschoolMapCreateNestedManyWithoutSpellInput
  }

  export type SpellUncheckedCreateWithoutDescriptorsInput = {
    id?: number
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    levelMapping?: SpellLevelMapUncheckedCreateNestedManyWithoutSpellInput
    schools?: SpellSchoolMapUncheckedCreateNestedManyWithoutSpellInput
    sources?: SpellSourceMapUncheckedCreateNestedManyWithoutSpellInput
    subschools?: SpellSubschoolMapUncheckedCreateNestedManyWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutDescriptorsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutDescriptorsInput, SpellUncheckedCreateWithoutDescriptorsInput>
  }

  export type SpellUpsertWithoutDescriptorsInput = {
    update: XOR<SpellUpdateWithoutDescriptorsInput, SpellUncheckedUpdateWithoutDescriptorsInput>
    create: XOR<SpellCreateWithoutDescriptorsInput, SpellUncheckedCreateWithoutDescriptorsInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutDescriptorsInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutDescriptorsInput, SpellUncheckedUpdateWithoutDescriptorsInput>
  }

  export type SpellUpdateWithoutDescriptorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    levelMapping?: SpellLevelMapUpdateManyWithoutSpellNestedInput
    schools?: SpellSchoolMapUpdateManyWithoutSpellNestedInput
    sources?: SpellSourceMapUpdateManyWithoutSpellNestedInput
    subschools?: SpellSubschoolMapUpdateManyWithoutSpellNestedInput
  }

  export type SpellUncheckedUpdateWithoutDescriptorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    levelMapping?: SpellLevelMapUncheckedUpdateManyWithoutSpellNestedInput
    schools?: SpellSchoolMapUncheckedUpdateManyWithoutSpellNestedInput
    sources?: SpellSourceMapUncheckedUpdateManyWithoutSpellNestedInput
    subschools?: SpellSubschoolMapUncheckedUpdateManyWithoutSpellNestedInput
  }

  export type SpellCreateWithoutSchoolsInput = {
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    descriptors?: SpellDescriptorMapCreateNestedManyWithoutSpellInput
    levelMapping?: SpellLevelMapCreateNestedManyWithoutSpellInput
    sources?: SpellSourceMapCreateNestedManyWithoutSpellInput
    subschools?: SpellSubschoolMapCreateNestedManyWithoutSpellInput
  }

  export type SpellUncheckedCreateWithoutSchoolsInput = {
    id?: number
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    descriptors?: SpellDescriptorMapUncheckedCreateNestedManyWithoutSpellInput
    levelMapping?: SpellLevelMapUncheckedCreateNestedManyWithoutSpellInput
    sources?: SpellSourceMapUncheckedCreateNestedManyWithoutSpellInput
    subschools?: SpellSubschoolMapUncheckedCreateNestedManyWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutSchoolsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutSchoolsInput, SpellUncheckedCreateWithoutSchoolsInput>
  }

  export type SpellUpsertWithoutSchoolsInput = {
    update: XOR<SpellUpdateWithoutSchoolsInput, SpellUncheckedUpdateWithoutSchoolsInput>
    create: XOR<SpellCreateWithoutSchoolsInput, SpellUncheckedCreateWithoutSchoolsInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutSchoolsInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutSchoolsInput, SpellUncheckedUpdateWithoutSchoolsInput>
  }

  export type SpellUpdateWithoutSchoolsInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    descriptors?: SpellDescriptorMapUpdateManyWithoutSpellNestedInput
    levelMapping?: SpellLevelMapUpdateManyWithoutSpellNestedInput
    sources?: SpellSourceMapUpdateManyWithoutSpellNestedInput
    subschools?: SpellSubschoolMapUpdateManyWithoutSpellNestedInput
  }

  export type SpellUncheckedUpdateWithoutSchoolsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    descriptors?: SpellDescriptorMapUncheckedUpdateManyWithoutSpellNestedInput
    levelMapping?: SpellLevelMapUncheckedUpdateManyWithoutSpellNestedInput
    sources?: SpellSourceMapUncheckedUpdateManyWithoutSpellNestedInput
    subschools?: SpellSubschoolMapUncheckedUpdateManyWithoutSpellNestedInput
  }

  export type SpellCreateWithoutSourcesInput = {
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    descriptors?: SpellDescriptorMapCreateNestedManyWithoutSpellInput
    levelMapping?: SpellLevelMapCreateNestedManyWithoutSpellInput
    schools?: SpellSchoolMapCreateNestedManyWithoutSpellInput
    subschools?: SpellSubschoolMapCreateNestedManyWithoutSpellInput
  }

  export type SpellUncheckedCreateWithoutSourcesInput = {
    id?: number
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    descriptors?: SpellDescriptorMapUncheckedCreateNestedManyWithoutSpellInput
    levelMapping?: SpellLevelMapUncheckedCreateNestedManyWithoutSpellInput
    schools?: SpellSchoolMapUncheckedCreateNestedManyWithoutSpellInput
    subschools?: SpellSubschoolMapUncheckedCreateNestedManyWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutSourcesInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutSourcesInput, SpellUncheckedCreateWithoutSourcesInput>
  }

  export type SourceBookCreateWithoutSpellsInput = {
    name: string
    abbreviation: string
    releaseDate?: Date | string | null
    editionId?: number | null
    description?: string | null
    isVisible?: boolean
    classes?: ClassSourceMapCreateNestedManyWithoutSourceBookInput
    races?: RaceSourceMapCreateNestedManyWithoutSourceBookInput
  }

  export type SourceBookUncheckedCreateWithoutSpellsInput = {
    id?: number
    name: string
    abbreviation: string
    releaseDate?: Date | string | null
    editionId?: number | null
    description?: string | null
    isVisible?: boolean
    classes?: ClassSourceMapUncheckedCreateNestedManyWithoutSourceBookInput
    races?: RaceSourceMapUncheckedCreateNestedManyWithoutSourceBookInput
  }

  export type SourceBookCreateOrConnectWithoutSpellsInput = {
    where: SourceBookWhereUniqueInput
    create: XOR<SourceBookCreateWithoutSpellsInput, SourceBookUncheckedCreateWithoutSpellsInput>
  }

  export type SpellUpsertWithoutSourcesInput = {
    update: XOR<SpellUpdateWithoutSourcesInput, SpellUncheckedUpdateWithoutSourcesInput>
    create: XOR<SpellCreateWithoutSourcesInput, SpellUncheckedCreateWithoutSourcesInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutSourcesInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutSourcesInput, SpellUncheckedUpdateWithoutSourcesInput>
  }

  export type SpellUpdateWithoutSourcesInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    descriptors?: SpellDescriptorMapUpdateManyWithoutSpellNestedInput
    levelMapping?: SpellLevelMapUpdateManyWithoutSpellNestedInput
    schools?: SpellSchoolMapUpdateManyWithoutSpellNestedInput
    subschools?: SpellSubschoolMapUpdateManyWithoutSpellNestedInput
  }

  export type SpellUncheckedUpdateWithoutSourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    descriptors?: SpellDescriptorMapUncheckedUpdateManyWithoutSpellNestedInput
    levelMapping?: SpellLevelMapUncheckedUpdateManyWithoutSpellNestedInput
    schools?: SpellSchoolMapUncheckedUpdateManyWithoutSpellNestedInput
    subschools?: SpellSubschoolMapUncheckedUpdateManyWithoutSpellNestedInput
  }

  export type SourceBookUpsertWithoutSpellsInput = {
    update: XOR<SourceBookUpdateWithoutSpellsInput, SourceBookUncheckedUpdateWithoutSpellsInput>
    create: XOR<SourceBookCreateWithoutSpellsInput, SourceBookUncheckedCreateWithoutSpellsInput>
    where?: SourceBookWhereInput
  }

  export type SourceBookUpdateToOneWithWhereWithoutSpellsInput = {
    where?: SourceBookWhereInput
    data: XOR<SourceBookUpdateWithoutSpellsInput, SourceBookUncheckedUpdateWithoutSpellsInput>
  }

  export type SourceBookUpdateWithoutSpellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassSourceMapUpdateManyWithoutSourceBookNestedInput
    races?: RaceSourceMapUpdateManyWithoutSourceBookNestedInput
  }

  export type SourceBookUncheckedUpdateWithoutSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput
    races?: RaceSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput
  }

  export type SpellCreateWithoutSubschoolsInput = {
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    descriptors?: SpellDescriptorMapCreateNestedManyWithoutSpellInput
    levelMapping?: SpellLevelMapCreateNestedManyWithoutSpellInput
    schools?: SpellSchoolMapCreateNestedManyWithoutSpellInput
    sources?: SpellSourceMapCreateNestedManyWithoutSpellInput
  }

  export type SpellUncheckedCreateWithoutSubschoolsInput = {
    id?: number
    name: string
    summary?: string | null
    description?: string | null
    castingTime?: string | null
    range?: string | null
    rangeTypeId?: number | null
    rangeValue?: string | null
    area?: string | null
    duration?: string | null
    savingThrow?: string | null
    spellResistance?: string | null
    editionId: number
    baseLevel: number
    effect?: string | null
    target?: string | null
    descriptors?: SpellDescriptorMapUncheckedCreateNestedManyWithoutSpellInput
    levelMapping?: SpellLevelMapUncheckedCreateNestedManyWithoutSpellInput
    schools?: SpellSchoolMapUncheckedCreateNestedManyWithoutSpellInput
    sources?: SpellSourceMapUncheckedCreateNestedManyWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutSubschoolsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutSubschoolsInput, SpellUncheckedCreateWithoutSubschoolsInput>
  }

  export type SpellUpsertWithoutSubschoolsInput = {
    update: XOR<SpellUpdateWithoutSubschoolsInput, SpellUncheckedUpdateWithoutSubschoolsInput>
    create: XOR<SpellCreateWithoutSubschoolsInput, SpellUncheckedCreateWithoutSubschoolsInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutSubschoolsInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutSubschoolsInput, SpellUncheckedUpdateWithoutSubschoolsInput>
  }

  export type SpellUpdateWithoutSubschoolsInput = {
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    descriptors?: SpellDescriptorMapUpdateManyWithoutSpellNestedInput
    levelMapping?: SpellLevelMapUpdateManyWithoutSpellNestedInput
    schools?: SpellSchoolMapUpdateManyWithoutSpellNestedInput
    sources?: SpellSourceMapUpdateManyWithoutSpellNestedInput
  }

  export type SpellUncheckedUpdateWithoutSubschoolsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    rangeTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    rangeValue?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrow?: NullableStringFieldUpdateOperationsInput | string | null
    spellResistance?: NullableStringFieldUpdateOperationsInput | string | null
    editionId?: IntFieldUpdateOperationsInput | number
    baseLevel?: IntFieldUpdateOperationsInput | number
    effect?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    descriptors?: SpellDescriptorMapUncheckedUpdateManyWithoutSpellNestedInput
    levelMapping?: SpellLevelMapUncheckedUpdateManyWithoutSpellNestedInput
    schools?: SpellSchoolMapUncheckedUpdateManyWithoutSpellNestedInput
    sources?: SpellSourceMapUncheckedUpdateManyWithoutSpellNestedInput
  }

  export type ClassSkillMapCreateWithoutSkillInput = {
    Class: ClassCreateNestedOneWithoutSkillsInput
  }

  export type ClassSkillMapUncheckedCreateWithoutSkillInput = {
    id?: number
    classId: number
  }

  export type ClassSkillMapCreateOrConnectWithoutSkillInput = {
    where: ClassSkillMapWhereUniqueInput
    create: XOR<ClassSkillMapCreateWithoutSkillInput, ClassSkillMapUncheckedCreateWithoutSkillInput>
  }

  export type ClassSkillMapCreateManySkillInputEnvelope = {
    data: ClassSkillMapCreateManySkillInput | ClassSkillMapCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type ClassSkillMapUpsertWithWhereUniqueWithoutSkillInput = {
    where: ClassSkillMapWhereUniqueInput
    update: XOR<ClassSkillMapUpdateWithoutSkillInput, ClassSkillMapUncheckedUpdateWithoutSkillInput>
    create: XOR<ClassSkillMapCreateWithoutSkillInput, ClassSkillMapUncheckedCreateWithoutSkillInput>
  }

  export type ClassSkillMapUpdateWithWhereUniqueWithoutSkillInput = {
    where: ClassSkillMapWhereUniqueInput
    data: XOR<ClassSkillMapUpdateWithoutSkillInput, ClassSkillMapUncheckedUpdateWithoutSkillInput>
  }

  export type ClassSkillMapUpdateManyWithWhereWithoutSkillInput = {
    where: ClassSkillMapScalarWhereInput
    data: XOR<ClassSkillMapUpdateManyMutationInput, ClassSkillMapUncheckedUpdateManyWithoutSkillInput>
  }

  export type FeatBenefitMapCreateWithoutFeatInput = {
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
  }

  export type FeatBenefitMapUncheckedCreateWithoutFeatInput = {
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
  }

  export type FeatBenefitMapCreateOrConnectWithoutFeatInput = {
    where: FeatBenefitMapWhereUniqueInput
    create: XOR<FeatBenefitMapCreateWithoutFeatInput, FeatBenefitMapUncheckedCreateWithoutFeatInput>
  }

  export type FeatBenefitMapCreateManyFeatInputEnvelope = {
    data: FeatBenefitMapCreateManyFeatInput | FeatBenefitMapCreateManyFeatInput[]
    skipDuplicates?: boolean
  }

  export type FeatPrerequisiteMapCreateWithoutFeatInput = {
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
  }

  export type FeatPrerequisiteMapUncheckedCreateWithoutFeatInput = {
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
  }

  export type FeatPrerequisiteMapCreateOrConnectWithoutFeatInput = {
    where: FeatPrerequisiteMapWhereUniqueInput
    create: XOR<FeatPrerequisiteMapCreateWithoutFeatInput, FeatPrerequisiteMapUncheckedCreateWithoutFeatInput>
  }

  export type FeatPrerequisiteMapCreateManyFeatInputEnvelope = {
    data: FeatPrerequisiteMapCreateManyFeatInput | FeatPrerequisiteMapCreateManyFeatInput[]
    skipDuplicates?: boolean
  }

  export type FeatBenefitMapUpsertWithWhereUniqueWithoutFeatInput = {
    where: FeatBenefitMapWhereUniqueInput
    update: XOR<FeatBenefitMapUpdateWithoutFeatInput, FeatBenefitMapUncheckedUpdateWithoutFeatInput>
    create: XOR<FeatBenefitMapCreateWithoutFeatInput, FeatBenefitMapUncheckedCreateWithoutFeatInput>
  }

  export type FeatBenefitMapUpdateWithWhereUniqueWithoutFeatInput = {
    where: FeatBenefitMapWhereUniqueInput
    data: XOR<FeatBenefitMapUpdateWithoutFeatInput, FeatBenefitMapUncheckedUpdateWithoutFeatInput>
  }

  export type FeatBenefitMapUpdateManyWithWhereWithoutFeatInput = {
    where: FeatBenefitMapScalarWhereInput
    data: XOR<FeatBenefitMapUpdateManyMutationInput, FeatBenefitMapUncheckedUpdateManyWithoutFeatInput>
  }

  export type FeatBenefitMapScalarWhereInput = {
    AND?: FeatBenefitMapScalarWhereInput | FeatBenefitMapScalarWhereInput[]
    OR?: FeatBenefitMapScalarWhereInput[]
    NOT?: FeatBenefitMapScalarWhereInput | FeatBenefitMapScalarWhereInput[]
    featId?: IntFilter<"FeatBenefitMap"> | number
    typeId?: IntFilter<"FeatBenefitMap"> | number
    referenceId?: IntNullableFilter<"FeatBenefitMap"> | number | null
    amount?: IntNullableFilter<"FeatBenefitMap"> | number | null
    index?: IntFilter<"FeatBenefitMap"> | number
  }

  export type FeatPrerequisiteMapUpsertWithWhereUniqueWithoutFeatInput = {
    where: FeatPrerequisiteMapWhereUniqueInput
    update: XOR<FeatPrerequisiteMapUpdateWithoutFeatInput, FeatPrerequisiteMapUncheckedUpdateWithoutFeatInput>
    create: XOR<FeatPrerequisiteMapCreateWithoutFeatInput, FeatPrerequisiteMapUncheckedCreateWithoutFeatInput>
  }

  export type FeatPrerequisiteMapUpdateWithWhereUniqueWithoutFeatInput = {
    where: FeatPrerequisiteMapWhereUniqueInput
    data: XOR<FeatPrerequisiteMapUpdateWithoutFeatInput, FeatPrerequisiteMapUncheckedUpdateWithoutFeatInput>
  }

  export type FeatPrerequisiteMapUpdateManyWithWhereWithoutFeatInput = {
    where: FeatPrerequisiteMapScalarWhereInput
    data: XOR<FeatPrerequisiteMapUpdateManyMutationInput, FeatPrerequisiteMapUncheckedUpdateManyWithoutFeatInput>
  }

  export type FeatPrerequisiteMapScalarWhereInput = {
    AND?: FeatPrerequisiteMapScalarWhereInput | FeatPrerequisiteMapScalarWhereInput[]
    OR?: FeatPrerequisiteMapScalarWhereInput[]
    NOT?: FeatPrerequisiteMapScalarWhereInput | FeatPrerequisiteMapScalarWhereInput[]
    featId?: IntFilter<"FeatPrerequisiteMap"> | number
    typeId?: IntFilter<"FeatPrerequisiteMap"> | number
    referenceId?: IntNullableFilter<"FeatPrerequisiteMap"> | number | null
    amount?: IntNullableFilter<"FeatPrerequisiteMap"> | number | null
    index?: IntFilter<"FeatPrerequisiteMap"> | number
  }

  export type FeatCreateWithoutBenefitsInput = {
    name: string
    typeId: number
    description?: string | null
    benefit?: string | null
    normalEffect?: string | null
    specialEffect?: string | null
    prerequisites?: string | null
    repeatable?: boolean | null
    fighterBonus?: boolean | null
    prerequisitesMap?: FeatPrerequisiteMapCreateNestedManyWithoutFeatInput
  }

  export type FeatUncheckedCreateWithoutBenefitsInput = {
    id?: number
    name: string
    typeId: number
    description?: string | null
    benefit?: string | null
    normalEffect?: string | null
    specialEffect?: string | null
    prerequisites?: string | null
    repeatable?: boolean | null
    fighterBonus?: boolean | null
    prerequisitesMap?: FeatPrerequisiteMapUncheckedCreateNestedManyWithoutFeatInput
  }

  export type FeatCreateOrConnectWithoutBenefitsInput = {
    where: FeatWhereUniqueInput
    create: XOR<FeatCreateWithoutBenefitsInput, FeatUncheckedCreateWithoutBenefitsInput>
  }

  export type FeatUpsertWithoutBenefitsInput = {
    update: XOR<FeatUpdateWithoutBenefitsInput, FeatUncheckedUpdateWithoutBenefitsInput>
    create: XOR<FeatCreateWithoutBenefitsInput, FeatUncheckedCreateWithoutBenefitsInput>
    where?: FeatWhereInput
  }

  export type FeatUpdateToOneWithWhereWithoutBenefitsInput = {
    where?: FeatWhereInput
    data: XOR<FeatUpdateWithoutBenefitsInput, FeatUncheckedUpdateWithoutBenefitsInput>
  }

  export type FeatUpdateWithoutBenefitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    typeId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    normalEffect?: NullableStringFieldUpdateOperationsInput | string | null
    specialEffect?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    repeatable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fighterBonus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prerequisitesMap?: FeatPrerequisiteMapUpdateManyWithoutFeatNestedInput
  }

  export type FeatUncheckedUpdateWithoutBenefitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    typeId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    normalEffect?: NullableStringFieldUpdateOperationsInput | string | null
    specialEffect?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    repeatable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fighterBonus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prerequisitesMap?: FeatPrerequisiteMapUncheckedUpdateManyWithoutFeatNestedInput
  }

  export type FeatCreateWithoutPrerequisitesMapInput = {
    name: string
    typeId: number
    description?: string | null
    benefit?: string | null
    normalEffect?: string | null
    specialEffect?: string | null
    prerequisites?: string | null
    repeatable?: boolean | null
    fighterBonus?: boolean | null
    benefits?: FeatBenefitMapCreateNestedManyWithoutFeatInput
  }

  export type FeatUncheckedCreateWithoutPrerequisitesMapInput = {
    id?: number
    name: string
    typeId: number
    description?: string | null
    benefit?: string | null
    normalEffect?: string | null
    specialEffect?: string | null
    prerequisites?: string | null
    repeatable?: boolean | null
    fighterBonus?: boolean | null
    benefits?: FeatBenefitMapUncheckedCreateNestedManyWithoutFeatInput
  }

  export type FeatCreateOrConnectWithoutPrerequisitesMapInput = {
    where: FeatWhereUniqueInput
    create: XOR<FeatCreateWithoutPrerequisitesMapInput, FeatUncheckedCreateWithoutPrerequisitesMapInput>
  }

  export type FeatUpsertWithoutPrerequisitesMapInput = {
    update: XOR<FeatUpdateWithoutPrerequisitesMapInput, FeatUncheckedUpdateWithoutPrerequisitesMapInput>
    create: XOR<FeatCreateWithoutPrerequisitesMapInput, FeatUncheckedCreateWithoutPrerequisitesMapInput>
    where?: FeatWhereInput
  }

  export type FeatUpdateToOneWithWhereWithoutPrerequisitesMapInput = {
    where?: FeatWhereInput
    data: XOR<FeatUpdateWithoutPrerequisitesMapInput, FeatUncheckedUpdateWithoutPrerequisitesMapInput>
  }

  export type FeatUpdateWithoutPrerequisitesMapInput = {
    name?: StringFieldUpdateOperationsInput | string
    typeId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    normalEffect?: NullableStringFieldUpdateOperationsInput | string | null
    specialEffect?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    repeatable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fighterBonus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    benefits?: FeatBenefitMapUpdateManyWithoutFeatNestedInput
  }

  export type FeatUncheckedUpdateWithoutPrerequisitesMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    typeId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    normalEffect?: NullableStringFieldUpdateOperationsInput | string | null
    specialEffect?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisites?: NullableStringFieldUpdateOperationsInput | string | null
    repeatable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fighterBonus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    benefits?: FeatBenefitMapUncheckedUpdateManyWithoutFeatNestedInput
  }

  export type RaceAbilityAdjustmentCreateWithoutRaceInput = {
    abilityId: number
    value: number
  }

  export type RaceAbilityAdjustmentUncheckedCreateWithoutRaceInput = {
    abilityId: number
    value: number
  }

  export type RaceAbilityAdjustmentCreateOrConnectWithoutRaceInput = {
    where: RaceAbilityAdjustmentWhereUniqueInput
    create: XOR<RaceAbilityAdjustmentCreateWithoutRaceInput, RaceAbilityAdjustmentUncheckedCreateWithoutRaceInput>
  }

  export type RaceAbilityAdjustmentCreateManyRaceInputEnvelope = {
    data: RaceAbilityAdjustmentCreateManyRaceInput | RaceAbilityAdjustmentCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type RaceLanguageMapCreateWithoutRaceInput = {
    languageId: number
    isAutomatic?: boolean
  }

  export type RaceLanguageMapUncheckedCreateWithoutRaceInput = {
    languageId: number
    isAutomatic?: boolean
  }

  export type RaceLanguageMapCreateOrConnectWithoutRaceInput = {
    where: RaceLanguageMapWhereUniqueInput
    create: XOR<RaceLanguageMapCreateWithoutRaceInput, RaceLanguageMapUncheckedCreateWithoutRaceInput>
  }

  export type RaceLanguageMapCreateManyRaceInputEnvelope = {
    data: RaceLanguageMapCreateManyRaceInput | RaceLanguageMapCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type RaceSourceMapCreateWithoutRaceInput = {
    bookId: number
    pageNumber?: number | null
    SourceBook?: SourceBookCreateNestedOneWithoutRacesInput
  }

  export type RaceSourceMapUncheckedCreateWithoutRaceInput = {
    id?: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type RaceSourceMapCreateOrConnectWithoutRaceInput = {
    where: RaceSourceMapWhereUniqueInput
    create: XOR<RaceSourceMapCreateWithoutRaceInput, RaceSourceMapUncheckedCreateWithoutRaceInput>
  }

  export type RaceSourceMapCreateManyRaceInputEnvelope = {
    data: RaceSourceMapCreateManyRaceInput | RaceSourceMapCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type RaceTraitMapCreateWithoutRaceInput = {
    value?: string | null
    trait: RaceTraitCreateNestedOneWithoutRaceLinksInput
  }

  export type RaceTraitMapUncheckedCreateWithoutRaceInput = {
    traitId: string
    value?: string | null
  }

  export type RaceTraitMapCreateOrConnectWithoutRaceInput = {
    where: RaceTraitMapWhereUniqueInput
    create: XOR<RaceTraitMapCreateWithoutRaceInput, RaceTraitMapUncheckedCreateWithoutRaceInput>
  }

  export type RaceTraitMapCreateManyRaceInputEnvelope = {
    data: RaceTraitMapCreateManyRaceInput | RaceTraitMapCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type UserCharacterCreateWithoutRaceInput = {
    name: string
    alignmentId: number
    age?: number | null
    height?: number | null
    weight?: number | null
    eyes?: string | null
    hair?: string | null
    gender?: string | null
    notes?: string | null
    attributes?: UserCharacterAttributeCreateNestedManyWithoutCharacterInput
    user: UserCreateNestedOneWithoutCharactersInput
  }

  export type UserCharacterUncheckedCreateWithoutRaceInput = {
    id?: number
    userId: number
    name: string
    alignmentId: number
    age?: number | null
    height?: number | null
    weight?: number | null
    eyes?: string | null
    hair?: string | null
    gender?: string | null
    notes?: string | null
    attributes?: UserCharacterAttributeUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type UserCharacterCreateOrConnectWithoutRaceInput = {
    where: UserCharacterWhereUniqueInput
    create: XOR<UserCharacterCreateWithoutRaceInput, UserCharacterUncheckedCreateWithoutRaceInput>
  }

  export type UserCharacterCreateManyRaceInputEnvelope = {
    data: UserCharacterCreateManyRaceInput | UserCharacterCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type RaceAbilityAdjustmentUpsertWithWhereUniqueWithoutRaceInput = {
    where: RaceAbilityAdjustmentWhereUniqueInput
    update: XOR<RaceAbilityAdjustmentUpdateWithoutRaceInput, RaceAbilityAdjustmentUncheckedUpdateWithoutRaceInput>
    create: XOR<RaceAbilityAdjustmentCreateWithoutRaceInput, RaceAbilityAdjustmentUncheckedCreateWithoutRaceInput>
  }

  export type RaceAbilityAdjustmentUpdateWithWhereUniqueWithoutRaceInput = {
    where: RaceAbilityAdjustmentWhereUniqueInput
    data: XOR<RaceAbilityAdjustmentUpdateWithoutRaceInput, RaceAbilityAdjustmentUncheckedUpdateWithoutRaceInput>
  }

  export type RaceAbilityAdjustmentUpdateManyWithWhereWithoutRaceInput = {
    where: RaceAbilityAdjustmentScalarWhereInput
    data: XOR<RaceAbilityAdjustmentUpdateManyMutationInput, RaceAbilityAdjustmentUncheckedUpdateManyWithoutRaceInput>
  }

  export type RaceAbilityAdjustmentScalarWhereInput = {
    AND?: RaceAbilityAdjustmentScalarWhereInput | RaceAbilityAdjustmentScalarWhereInput[]
    OR?: RaceAbilityAdjustmentScalarWhereInput[]
    NOT?: RaceAbilityAdjustmentScalarWhereInput | RaceAbilityAdjustmentScalarWhereInput[]
    raceId?: IntFilter<"RaceAbilityAdjustment"> | number
    abilityId?: IntFilter<"RaceAbilityAdjustment"> | number
    value?: IntFilter<"RaceAbilityAdjustment"> | number
  }

  export type RaceLanguageMapUpsertWithWhereUniqueWithoutRaceInput = {
    where: RaceLanguageMapWhereUniqueInput
    update: XOR<RaceLanguageMapUpdateWithoutRaceInput, RaceLanguageMapUncheckedUpdateWithoutRaceInput>
    create: XOR<RaceLanguageMapCreateWithoutRaceInput, RaceLanguageMapUncheckedCreateWithoutRaceInput>
  }

  export type RaceLanguageMapUpdateWithWhereUniqueWithoutRaceInput = {
    where: RaceLanguageMapWhereUniqueInput
    data: XOR<RaceLanguageMapUpdateWithoutRaceInput, RaceLanguageMapUncheckedUpdateWithoutRaceInput>
  }

  export type RaceLanguageMapUpdateManyWithWhereWithoutRaceInput = {
    where: RaceLanguageMapScalarWhereInput
    data: XOR<RaceLanguageMapUpdateManyMutationInput, RaceLanguageMapUncheckedUpdateManyWithoutRaceInput>
  }

  export type RaceLanguageMapScalarWhereInput = {
    AND?: RaceLanguageMapScalarWhereInput | RaceLanguageMapScalarWhereInput[]
    OR?: RaceLanguageMapScalarWhereInput[]
    NOT?: RaceLanguageMapScalarWhereInput | RaceLanguageMapScalarWhereInput[]
    raceId?: IntFilter<"RaceLanguageMap"> | number
    languageId?: IntFilter<"RaceLanguageMap"> | number
    isAutomatic?: BoolFilter<"RaceLanguageMap"> | boolean
  }

  export type RaceSourceMapUpsertWithWhereUniqueWithoutRaceInput = {
    where: RaceSourceMapWhereUniqueInput
    update: XOR<RaceSourceMapUpdateWithoutRaceInput, RaceSourceMapUncheckedUpdateWithoutRaceInput>
    create: XOR<RaceSourceMapCreateWithoutRaceInput, RaceSourceMapUncheckedCreateWithoutRaceInput>
  }

  export type RaceSourceMapUpdateWithWhereUniqueWithoutRaceInput = {
    where: RaceSourceMapWhereUniqueInput
    data: XOR<RaceSourceMapUpdateWithoutRaceInput, RaceSourceMapUncheckedUpdateWithoutRaceInput>
  }

  export type RaceSourceMapUpdateManyWithWhereWithoutRaceInput = {
    where: RaceSourceMapScalarWhereInput
    data: XOR<RaceSourceMapUpdateManyMutationInput, RaceSourceMapUncheckedUpdateManyWithoutRaceInput>
  }

  export type RaceSourceMapScalarWhereInput = {
    AND?: RaceSourceMapScalarWhereInput | RaceSourceMapScalarWhereInput[]
    OR?: RaceSourceMapScalarWhereInput[]
    NOT?: RaceSourceMapScalarWhereInput | RaceSourceMapScalarWhereInput[]
    id?: IntFilter<"RaceSourceMap"> | number
    raceId?: IntFilter<"RaceSourceMap"> | number
    bookId?: IntFilter<"RaceSourceMap"> | number
    pageNumber?: IntNullableFilter<"RaceSourceMap"> | number | null
    sourceBookId?: IntNullableFilter<"RaceSourceMap"> | number | null
  }

  export type RaceTraitMapUpsertWithWhereUniqueWithoutRaceInput = {
    where: RaceTraitMapWhereUniqueInput
    update: XOR<RaceTraitMapUpdateWithoutRaceInput, RaceTraitMapUncheckedUpdateWithoutRaceInput>
    create: XOR<RaceTraitMapCreateWithoutRaceInput, RaceTraitMapUncheckedCreateWithoutRaceInput>
  }

  export type RaceTraitMapUpdateWithWhereUniqueWithoutRaceInput = {
    where: RaceTraitMapWhereUniqueInput
    data: XOR<RaceTraitMapUpdateWithoutRaceInput, RaceTraitMapUncheckedUpdateWithoutRaceInput>
  }

  export type RaceTraitMapUpdateManyWithWhereWithoutRaceInput = {
    where: RaceTraitMapScalarWhereInput
    data: XOR<RaceTraitMapUpdateManyMutationInput, RaceTraitMapUncheckedUpdateManyWithoutRaceInput>
  }

  export type RaceTraitMapScalarWhereInput = {
    AND?: RaceTraitMapScalarWhereInput | RaceTraitMapScalarWhereInput[]
    OR?: RaceTraitMapScalarWhereInput[]
    NOT?: RaceTraitMapScalarWhereInput | RaceTraitMapScalarWhereInput[]
    raceId?: IntFilter<"RaceTraitMap"> | number
    traitId?: StringFilter<"RaceTraitMap"> | string
    value?: StringNullableFilter<"RaceTraitMap"> | string | null
  }

  export type UserCharacterUpsertWithWhereUniqueWithoutRaceInput = {
    where: UserCharacterWhereUniqueInput
    update: XOR<UserCharacterUpdateWithoutRaceInput, UserCharacterUncheckedUpdateWithoutRaceInput>
    create: XOR<UserCharacterCreateWithoutRaceInput, UserCharacterUncheckedCreateWithoutRaceInput>
  }

  export type UserCharacterUpdateWithWhereUniqueWithoutRaceInput = {
    where: UserCharacterWhereUniqueInput
    data: XOR<UserCharacterUpdateWithoutRaceInput, UserCharacterUncheckedUpdateWithoutRaceInput>
  }

  export type UserCharacterUpdateManyWithWhereWithoutRaceInput = {
    where: UserCharacterScalarWhereInput
    data: XOR<UserCharacterUpdateManyMutationInput, UserCharacterUncheckedUpdateManyWithoutRaceInput>
  }

  export type UserCharacterScalarWhereInput = {
    AND?: UserCharacterScalarWhereInput | UserCharacterScalarWhereInput[]
    OR?: UserCharacterScalarWhereInput[]
    NOT?: UserCharacterScalarWhereInput | UserCharacterScalarWhereInput[]
    id?: IntFilter<"UserCharacter"> | number
    userId?: IntFilter<"UserCharacter"> | number
    name?: StringFilter<"UserCharacter"> | string
    raceId?: IntFilter<"UserCharacter"> | number
    alignmentId?: IntFilter<"UserCharacter"> | number
    age?: IntNullableFilter<"UserCharacter"> | number | null
    height?: IntNullableFilter<"UserCharacter"> | number | null
    weight?: IntNullableFilter<"UserCharacter"> | number | null
    eyes?: StringNullableFilter<"UserCharacter"> | string | null
    hair?: StringNullableFilter<"UserCharacter"> | string | null
    gender?: StringNullableFilter<"UserCharacter"> | string | null
    notes?: StringNullableFilter<"UserCharacter"> | string | null
  }

  export type RaceTraitMapCreateWithoutTraitInput = {
    value?: string | null
    race: RaceCreateNestedOneWithoutTraitsInput
  }

  export type RaceTraitMapUncheckedCreateWithoutTraitInput = {
    raceId: number
    value?: string | null
  }

  export type RaceTraitMapCreateOrConnectWithoutTraitInput = {
    where: RaceTraitMapWhereUniqueInput
    create: XOR<RaceTraitMapCreateWithoutTraitInput, RaceTraitMapUncheckedCreateWithoutTraitInput>
  }

  export type RaceTraitMapCreateManyTraitInputEnvelope = {
    data: RaceTraitMapCreateManyTraitInput | RaceTraitMapCreateManyTraitInput[]
    skipDuplicates?: boolean
  }

  export type RaceTraitMapUpsertWithWhereUniqueWithoutTraitInput = {
    where: RaceTraitMapWhereUniqueInput
    update: XOR<RaceTraitMapUpdateWithoutTraitInput, RaceTraitMapUncheckedUpdateWithoutTraitInput>
    create: XOR<RaceTraitMapCreateWithoutTraitInput, RaceTraitMapUncheckedCreateWithoutTraitInput>
  }

  export type RaceTraitMapUpdateWithWhereUniqueWithoutTraitInput = {
    where: RaceTraitMapWhereUniqueInput
    data: XOR<RaceTraitMapUpdateWithoutTraitInput, RaceTraitMapUncheckedUpdateWithoutTraitInput>
  }

  export type RaceTraitMapUpdateManyWithWhereWithoutTraitInput = {
    where: RaceTraitMapScalarWhereInput
    data: XOR<RaceTraitMapUpdateManyMutationInput, RaceTraitMapUncheckedUpdateManyWithoutTraitInput>
  }

  export type RaceCreateWithoutTraitsInput = {
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    abilityAdjustments?: RaceAbilityAdjustmentCreateNestedManyWithoutRaceInput
    languages?: RaceLanguageMapCreateNestedManyWithoutRaceInput
    sources?: RaceSourceMapCreateNestedManyWithoutRaceInput
    UserCharacter?: UserCharacterCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutTraitsInput = {
    id?: number
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    abilityAdjustments?: RaceAbilityAdjustmentUncheckedCreateNestedManyWithoutRaceInput
    languages?: RaceLanguageMapUncheckedCreateNestedManyWithoutRaceInput
    sources?: RaceSourceMapUncheckedCreateNestedManyWithoutRaceInput
    UserCharacter?: UserCharacterUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutTraitsInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutTraitsInput, RaceUncheckedCreateWithoutTraitsInput>
  }

  export type RaceTraitCreateWithoutRaceLinksInput = {
    slug: string
    name?: string | null
    description?: string | null
    hasValue?: boolean
  }

  export type RaceTraitUncheckedCreateWithoutRaceLinksInput = {
    slug: string
    name?: string | null
    description?: string | null
    hasValue?: boolean
  }

  export type RaceTraitCreateOrConnectWithoutRaceLinksInput = {
    where: RaceTraitWhereUniqueInput
    create: XOR<RaceTraitCreateWithoutRaceLinksInput, RaceTraitUncheckedCreateWithoutRaceLinksInput>
  }

  export type RaceUpsertWithoutTraitsInput = {
    update: XOR<RaceUpdateWithoutTraitsInput, RaceUncheckedUpdateWithoutTraitsInput>
    create: XOR<RaceCreateWithoutTraitsInput, RaceUncheckedCreateWithoutTraitsInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutTraitsInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutTraitsInput, RaceUncheckedUpdateWithoutTraitsInput>
  }

  export type RaceUpdateWithoutTraitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    abilityAdjustments?: RaceAbilityAdjustmentUpdateManyWithoutRaceNestedInput
    languages?: RaceLanguageMapUpdateManyWithoutRaceNestedInput
    sources?: RaceSourceMapUpdateManyWithoutRaceNestedInput
    UserCharacter?: UserCharacterUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutTraitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    abilityAdjustments?: RaceAbilityAdjustmentUncheckedUpdateManyWithoutRaceNestedInput
    languages?: RaceLanguageMapUncheckedUpdateManyWithoutRaceNestedInput
    sources?: RaceSourceMapUncheckedUpdateManyWithoutRaceNestedInput
    UserCharacter?: UserCharacterUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceTraitUpsertWithoutRaceLinksInput = {
    update: XOR<RaceTraitUpdateWithoutRaceLinksInput, RaceTraitUncheckedUpdateWithoutRaceLinksInput>
    create: XOR<RaceTraitCreateWithoutRaceLinksInput, RaceTraitUncheckedCreateWithoutRaceLinksInput>
    where?: RaceTraitWhereInput
  }

  export type RaceTraitUpdateToOneWithWhereWithoutRaceLinksInput = {
    where?: RaceTraitWhereInput
    data: XOR<RaceTraitUpdateWithoutRaceLinksInput, RaceTraitUncheckedUpdateWithoutRaceLinksInput>
  }

  export type RaceTraitUpdateWithoutRaceLinksInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasValue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceTraitUncheckedUpdateWithoutRaceLinksInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasValue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceCreateWithoutAbilityAdjustmentsInput = {
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    languages?: RaceLanguageMapCreateNestedManyWithoutRaceInput
    sources?: RaceSourceMapCreateNestedManyWithoutRaceInput
    traits?: RaceTraitMapCreateNestedManyWithoutRaceInput
    UserCharacter?: UserCharacterCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutAbilityAdjustmentsInput = {
    id?: number
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    languages?: RaceLanguageMapUncheckedCreateNestedManyWithoutRaceInput
    sources?: RaceSourceMapUncheckedCreateNestedManyWithoutRaceInput
    traits?: RaceTraitMapUncheckedCreateNestedManyWithoutRaceInput
    UserCharacter?: UserCharacterUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutAbilityAdjustmentsInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutAbilityAdjustmentsInput, RaceUncheckedCreateWithoutAbilityAdjustmentsInput>
  }

  export type RaceUpsertWithoutAbilityAdjustmentsInput = {
    update: XOR<RaceUpdateWithoutAbilityAdjustmentsInput, RaceUncheckedUpdateWithoutAbilityAdjustmentsInput>
    create: XOR<RaceCreateWithoutAbilityAdjustmentsInput, RaceUncheckedCreateWithoutAbilityAdjustmentsInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutAbilityAdjustmentsInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutAbilityAdjustmentsInput, RaceUncheckedUpdateWithoutAbilityAdjustmentsInput>
  }

  export type RaceUpdateWithoutAbilityAdjustmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    languages?: RaceLanguageMapUpdateManyWithoutRaceNestedInput
    sources?: RaceSourceMapUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitMapUpdateManyWithoutRaceNestedInput
    UserCharacter?: UserCharacterUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutAbilityAdjustmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    languages?: RaceLanguageMapUncheckedUpdateManyWithoutRaceNestedInput
    sources?: RaceSourceMapUncheckedUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitMapUncheckedUpdateManyWithoutRaceNestedInput
    UserCharacter?: UserCharacterUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceCreateWithoutLanguagesInput = {
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    abilityAdjustments?: RaceAbilityAdjustmentCreateNestedManyWithoutRaceInput
    sources?: RaceSourceMapCreateNestedManyWithoutRaceInput
    traits?: RaceTraitMapCreateNestedManyWithoutRaceInput
    UserCharacter?: UserCharacterCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutLanguagesInput = {
    id?: number
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    abilityAdjustments?: RaceAbilityAdjustmentUncheckedCreateNestedManyWithoutRaceInput
    sources?: RaceSourceMapUncheckedCreateNestedManyWithoutRaceInput
    traits?: RaceTraitMapUncheckedCreateNestedManyWithoutRaceInput
    UserCharacter?: UserCharacterUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutLanguagesInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutLanguagesInput, RaceUncheckedCreateWithoutLanguagesInput>
  }

  export type RaceUpsertWithoutLanguagesInput = {
    update: XOR<RaceUpdateWithoutLanguagesInput, RaceUncheckedUpdateWithoutLanguagesInput>
    create: XOR<RaceCreateWithoutLanguagesInput, RaceUncheckedCreateWithoutLanguagesInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutLanguagesInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutLanguagesInput, RaceUncheckedUpdateWithoutLanguagesInput>
  }

  export type RaceUpdateWithoutLanguagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    abilityAdjustments?: RaceAbilityAdjustmentUpdateManyWithoutRaceNestedInput
    sources?: RaceSourceMapUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitMapUpdateManyWithoutRaceNestedInput
    UserCharacter?: UserCharacterUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutLanguagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    abilityAdjustments?: RaceAbilityAdjustmentUncheckedUpdateManyWithoutRaceNestedInput
    sources?: RaceSourceMapUncheckedUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitMapUncheckedUpdateManyWithoutRaceNestedInput
    UserCharacter?: UserCharacterUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceCreateWithoutSourcesInput = {
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    abilityAdjustments?: RaceAbilityAdjustmentCreateNestedManyWithoutRaceInput
    languages?: RaceLanguageMapCreateNestedManyWithoutRaceInput
    traits?: RaceTraitMapCreateNestedManyWithoutRaceInput
    UserCharacter?: UserCharacterCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutSourcesInput = {
    id?: number
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    abilityAdjustments?: RaceAbilityAdjustmentUncheckedCreateNestedManyWithoutRaceInput
    languages?: RaceLanguageMapUncheckedCreateNestedManyWithoutRaceInput
    traits?: RaceTraitMapUncheckedCreateNestedManyWithoutRaceInput
    UserCharacter?: UserCharacterUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutSourcesInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutSourcesInput, RaceUncheckedCreateWithoutSourcesInput>
  }

  export type SourceBookCreateWithoutRacesInput = {
    name: string
    abbreviation: string
    releaseDate?: Date | string | null
    editionId?: number | null
    description?: string | null
    isVisible?: boolean
    classes?: ClassSourceMapCreateNestedManyWithoutSourceBookInput
    spells?: SpellSourceMapCreateNestedManyWithoutSourceBookInput
  }

  export type SourceBookUncheckedCreateWithoutRacesInput = {
    id?: number
    name: string
    abbreviation: string
    releaseDate?: Date | string | null
    editionId?: number | null
    description?: string | null
    isVisible?: boolean
    classes?: ClassSourceMapUncheckedCreateNestedManyWithoutSourceBookInput
    spells?: SpellSourceMapUncheckedCreateNestedManyWithoutSourceBookInput
  }

  export type SourceBookCreateOrConnectWithoutRacesInput = {
    where: SourceBookWhereUniqueInput
    create: XOR<SourceBookCreateWithoutRacesInput, SourceBookUncheckedCreateWithoutRacesInput>
  }

  export type RaceUpsertWithoutSourcesInput = {
    update: XOR<RaceUpdateWithoutSourcesInput, RaceUncheckedUpdateWithoutSourcesInput>
    create: XOR<RaceCreateWithoutSourcesInput, RaceUncheckedCreateWithoutSourcesInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutSourcesInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutSourcesInput, RaceUncheckedUpdateWithoutSourcesInput>
  }

  export type RaceUpdateWithoutSourcesInput = {
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    abilityAdjustments?: RaceAbilityAdjustmentUpdateManyWithoutRaceNestedInput
    languages?: RaceLanguageMapUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitMapUpdateManyWithoutRaceNestedInput
    UserCharacter?: UserCharacterUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutSourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    abilityAdjustments?: RaceAbilityAdjustmentUncheckedUpdateManyWithoutRaceNestedInput
    languages?: RaceLanguageMapUncheckedUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitMapUncheckedUpdateManyWithoutRaceNestedInput
    UserCharacter?: UserCharacterUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type SourceBookUpsertWithoutRacesInput = {
    update: XOR<SourceBookUpdateWithoutRacesInput, SourceBookUncheckedUpdateWithoutRacesInput>
    create: XOR<SourceBookCreateWithoutRacesInput, SourceBookUncheckedCreateWithoutRacesInput>
    where?: SourceBookWhereInput
  }

  export type SourceBookUpdateToOneWithWhereWithoutRacesInput = {
    where?: SourceBookWhereInput
    data: XOR<SourceBookUpdateWithoutRacesInput, SourceBookUncheckedUpdateWithoutRacesInput>
  }

  export type SourceBookUpdateWithoutRacesInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassSourceMapUpdateManyWithoutSourceBookNestedInput
    spells?: SpellSourceMapUpdateManyWithoutSourceBookNestedInput
  }

  export type SourceBookUncheckedUpdateWithoutRacesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput
    spells?: SpellSourceMapUncheckedUpdateManyWithoutSourceBookNestedInput
  }

  export type ClassSourceMapCreateWithoutSourceBookInput = {
    bookId: number
    pageNumber?: number | null
    class: ClassCreateNestedOneWithoutSourcesInput
  }

  export type ClassSourceMapUncheckedCreateWithoutSourceBookInput = {
    id?: number
    classId: number
    bookId: number
    pageNumber?: number | null
  }

  export type ClassSourceMapCreateOrConnectWithoutSourceBookInput = {
    where: ClassSourceMapWhereUniqueInput
    create: XOR<ClassSourceMapCreateWithoutSourceBookInput, ClassSourceMapUncheckedCreateWithoutSourceBookInput>
  }

  export type ClassSourceMapCreateManySourceBookInputEnvelope = {
    data: ClassSourceMapCreateManySourceBookInput | ClassSourceMapCreateManySourceBookInput[]
    skipDuplicates?: boolean
  }

  export type RaceSourceMapCreateWithoutSourceBookInput = {
    bookId: number
    pageNumber?: number | null
    Race: RaceCreateNestedOneWithoutSourcesInput
  }

  export type RaceSourceMapUncheckedCreateWithoutSourceBookInput = {
    id?: number
    raceId: number
    bookId: number
    pageNumber?: number | null
  }

  export type RaceSourceMapCreateOrConnectWithoutSourceBookInput = {
    where: RaceSourceMapWhereUniqueInput
    create: XOR<RaceSourceMapCreateWithoutSourceBookInput, RaceSourceMapUncheckedCreateWithoutSourceBookInput>
  }

  export type RaceSourceMapCreateManySourceBookInputEnvelope = {
    data: RaceSourceMapCreateManySourceBookInput | RaceSourceMapCreateManySourceBookInput[]
    skipDuplicates?: boolean
  }

  export type SpellSourceMapCreateWithoutSourceBookInput = {
    bookId: number
    pageNumber?: number | null
    Spell: SpellCreateNestedOneWithoutSourcesInput
  }

  export type SpellSourceMapUncheckedCreateWithoutSourceBookInput = {
    id?: number
    spellId: number
    bookId: number
    pageNumber?: number | null
  }

  export type SpellSourceMapCreateOrConnectWithoutSourceBookInput = {
    where: SpellSourceMapWhereUniqueInput
    create: XOR<SpellSourceMapCreateWithoutSourceBookInput, SpellSourceMapUncheckedCreateWithoutSourceBookInput>
  }

  export type SpellSourceMapCreateManySourceBookInputEnvelope = {
    data: SpellSourceMapCreateManySourceBookInput | SpellSourceMapCreateManySourceBookInput[]
    skipDuplicates?: boolean
  }

  export type ClassSourceMapUpsertWithWhereUniqueWithoutSourceBookInput = {
    where: ClassSourceMapWhereUniqueInput
    update: XOR<ClassSourceMapUpdateWithoutSourceBookInput, ClassSourceMapUncheckedUpdateWithoutSourceBookInput>
    create: XOR<ClassSourceMapCreateWithoutSourceBookInput, ClassSourceMapUncheckedCreateWithoutSourceBookInput>
  }

  export type ClassSourceMapUpdateWithWhereUniqueWithoutSourceBookInput = {
    where: ClassSourceMapWhereUniqueInput
    data: XOR<ClassSourceMapUpdateWithoutSourceBookInput, ClassSourceMapUncheckedUpdateWithoutSourceBookInput>
  }

  export type ClassSourceMapUpdateManyWithWhereWithoutSourceBookInput = {
    where: ClassSourceMapScalarWhereInput
    data: XOR<ClassSourceMapUpdateManyMutationInput, ClassSourceMapUncheckedUpdateManyWithoutSourceBookInput>
  }

  export type RaceSourceMapUpsertWithWhereUniqueWithoutSourceBookInput = {
    where: RaceSourceMapWhereUniqueInput
    update: XOR<RaceSourceMapUpdateWithoutSourceBookInput, RaceSourceMapUncheckedUpdateWithoutSourceBookInput>
    create: XOR<RaceSourceMapCreateWithoutSourceBookInput, RaceSourceMapUncheckedCreateWithoutSourceBookInput>
  }

  export type RaceSourceMapUpdateWithWhereUniqueWithoutSourceBookInput = {
    where: RaceSourceMapWhereUniqueInput
    data: XOR<RaceSourceMapUpdateWithoutSourceBookInput, RaceSourceMapUncheckedUpdateWithoutSourceBookInput>
  }

  export type RaceSourceMapUpdateManyWithWhereWithoutSourceBookInput = {
    where: RaceSourceMapScalarWhereInput
    data: XOR<RaceSourceMapUpdateManyMutationInput, RaceSourceMapUncheckedUpdateManyWithoutSourceBookInput>
  }

  export type SpellSourceMapUpsertWithWhereUniqueWithoutSourceBookInput = {
    where: SpellSourceMapWhereUniqueInput
    update: XOR<SpellSourceMapUpdateWithoutSourceBookInput, SpellSourceMapUncheckedUpdateWithoutSourceBookInput>
    create: XOR<SpellSourceMapCreateWithoutSourceBookInput, SpellSourceMapUncheckedCreateWithoutSourceBookInput>
  }

  export type SpellSourceMapUpdateWithWhereUniqueWithoutSourceBookInput = {
    where: SpellSourceMapWhereUniqueInput
    data: XOR<SpellSourceMapUpdateWithoutSourceBookInput, SpellSourceMapUncheckedUpdateWithoutSourceBookInput>
  }

  export type SpellSourceMapUpdateManyWithWhereWithoutSourceBookInput = {
    where: SpellSourceMapScalarWhereInput
    data: XOR<SpellSourceMapUpdateManyMutationInput, SpellSourceMapUncheckedUpdateManyWithoutSourceBookInput>
  }

  export type ReferenceTableColumnCreateWithoutTableInput = {
    columnIndex: number
    header: string
    span?: number | null
    alignment?: string | null
    cells?: ReferenceTableCellCreateNestedManyWithoutColumnInput
  }

  export type ReferenceTableColumnUncheckedCreateWithoutTableInput = {
    id?: number
    columnIndex: number
    header: string
    span?: number | null
    alignment?: string | null
    cells?: ReferenceTableCellUncheckedCreateNestedManyWithoutColumnInput
  }

  export type ReferenceTableColumnCreateOrConnectWithoutTableInput = {
    where: ReferenceTableColumnWhereUniqueInput
    create: XOR<ReferenceTableColumnCreateWithoutTableInput, ReferenceTableColumnUncheckedCreateWithoutTableInput>
  }

  export type ReferenceTableColumnCreateManyTableInputEnvelope = {
    data: ReferenceTableColumnCreateManyTableInput | ReferenceTableColumnCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type ReferenceTableRowCreateWithoutTableInput = {
    rowIndex: number
    label?: string | null
    cells?: ReferenceTableCellCreateNestedManyWithoutRowInput
  }

  export type ReferenceTableRowUncheckedCreateWithoutTableInput = {
    id?: number
    rowIndex: number
    label?: string | null
    cells?: ReferenceTableCellUncheckedCreateNestedManyWithoutRowInput
  }

  export type ReferenceTableRowCreateOrConnectWithoutTableInput = {
    where: ReferenceTableRowWhereUniqueInput
    create: XOR<ReferenceTableRowCreateWithoutTableInput, ReferenceTableRowUncheckedCreateWithoutTableInput>
  }

  export type ReferenceTableRowCreateManyTableInputEnvelope = {
    data: ReferenceTableRowCreateManyTableInput | ReferenceTableRowCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type ReferenceTableColumnUpsertWithWhereUniqueWithoutTableInput = {
    where: ReferenceTableColumnWhereUniqueInput
    update: XOR<ReferenceTableColumnUpdateWithoutTableInput, ReferenceTableColumnUncheckedUpdateWithoutTableInput>
    create: XOR<ReferenceTableColumnCreateWithoutTableInput, ReferenceTableColumnUncheckedCreateWithoutTableInput>
  }

  export type ReferenceTableColumnUpdateWithWhereUniqueWithoutTableInput = {
    where: ReferenceTableColumnWhereUniqueInput
    data: XOR<ReferenceTableColumnUpdateWithoutTableInput, ReferenceTableColumnUncheckedUpdateWithoutTableInput>
  }

  export type ReferenceTableColumnUpdateManyWithWhereWithoutTableInput = {
    where: ReferenceTableColumnScalarWhereInput
    data: XOR<ReferenceTableColumnUpdateManyMutationInput, ReferenceTableColumnUncheckedUpdateManyWithoutTableInput>
  }

  export type ReferenceTableColumnScalarWhereInput = {
    AND?: ReferenceTableColumnScalarWhereInput | ReferenceTableColumnScalarWhereInput[]
    OR?: ReferenceTableColumnScalarWhereInput[]
    NOT?: ReferenceTableColumnScalarWhereInput | ReferenceTableColumnScalarWhereInput[]
    id?: IntFilter<"ReferenceTableColumn"> | number
    tableSlug?: StringFilter<"ReferenceTableColumn"> | string
    columnIndex?: IntFilter<"ReferenceTableColumn"> | number
    header?: StringFilter<"ReferenceTableColumn"> | string
    span?: IntNullableFilter<"ReferenceTableColumn"> | number | null
    alignment?: StringNullableFilter<"ReferenceTableColumn"> | string | null
  }

  export type ReferenceTableRowUpsertWithWhereUniqueWithoutTableInput = {
    where: ReferenceTableRowWhereUniqueInput
    update: XOR<ReferenceTableRowUpdateWithoutTableInput, ReferenceTableRowUncheckedUpdateWithoutTableInput>
    create: XOR<ReferenceTableRowCreateWithoutTableInput, ReferenceTableRowUncheckedCreateWithoutTableInput>
  }

  export type ReferenceTableRowUpdateWithWhereUniqueWithoutTableInput = {
    where: ReferenceTableRowWhereUniqueInput
    data: XOR<ReferenceTableRowUpdateWithoutTableInput, ReferenceTableRowUncheckedUpdateWithoutTableInput>
  }

  export type ReferenceTableRowUpdateManyWithWhereWithoutTableInput = {
    where: ReferenceTableRowScalarWhereInput
    data: XOR<ReferenceTableRowUpdateManyMutationInput, ReferenceTableRowUncheckedUpdateManyWithoutTableInput>
  }

  export type ReferenceTableRowScalarWhereInput = {
    AND?: ReferenceTableRowScalarWhereInput | ReferenceTableRowScalarWhereInput[]
    OR?: ReferenceTableRowScalarWhereInput[]
    NOT?: ReferenceTableRowScalarWhereInput | ReferenceTableRowScalarWhereInput[]
    id?: IntFilter<"ReferenceTableRow"> | number
    tableSlug?: StringFilter<"ReferenceTableRow"> | string
    rowIndex?: IntFilter<"ReferenceTableRow"> | number
    label?: StringNullableFilter<"ReferenceTableRow"> | string | null
  }

  export type ReferenceTableCellCreateWithoutColumnInput = {
    value?: string | null
    colSpan?: number | null
    rowSpan?: number | null
    row: ReferenceTableRowCreateNestedOneWithoutCellsInput
  }

  export type ReferenceTableCellUncheckedCreateWithoutColumnInput = {
    id?: number
    rowId: number
    value?: string | null
    colSpan?: number | null
    rowSpan?: number | null
  }

  export type ReferenceTableCellCreateOrConnectWithoutColumnInput = {
    where: ReferenceTableCellWhereUniqueInput
    create: XOR<ReferenceTableCellCreateWithoutColumnInput, ReferenceTableCellUncheckedCreateWithoutColumnInput>
  }

  export type ReferenceTableCellCreateManyColumnInputEnvelope = {
    data: ReferenceTableCellCreateManyColumnInput | ReferenceTableCellCreateManyColumnInput[]
    skipDuplicates?: boolean
  }

  export type ReferenceTableCreateWithoutColumnsInput = {
    slug: string
    name: string
    description?: string | null
    rows?: ReferenceTableRowCreateNestedManyWithoutTableInput
  }

  export type ReferenceTableUncheckedCreateWithoutColumnsInput = {
    slug: string
    name: string
    description?: string | null
    rows?: ReferenceTableRowUncheckedCreateNestedManyWithoutTableInput
  }

  export type ReferenceTableCreateOrConnectWithoutColumnsInput = {
    where: ReferenceTableWhereUniqueInput
    create: XOR<ReferenceTableCreateWithoutColumnsInput, ReferenceTableUncheckedCreateWithoutColumnsInput>
  }

  export type ReferenceTableCellUpsertWithWhereUniqueWithoutColumnInput = {
    where: ReferenceTableCellWhereUniqueInput
    update: XOR<ReferenceTableCellUpdateWithoutColumnInput, ReferenceTableCellUncheckedUpdateWithoutColumnInput>
    create: XOR<ReferenceTableCellCreateWithoutColumnInput, ReferenceTableCellUncheckedCreateWithoutColumnInput>
  }

  export type ReferenceTableCellUpdateWithWhereUniqueWithoutColumnInput = {
    where: ReferenceTableCellWhereUniqueInput
    data: XOR<ReferenceTableCellUpdateWithoutColumnInput, ReferenceTableCellUncheckedUpdateWithoutColumnInput>
  }

  export type ReferenceTableCellUpdateManyWithWhereWithoutColumnInput = {
    where: ReferenceTableCellScalarWhereInput
    data: XOR<ReferenceTableCellUpdateManyMutationInput, ReferenceTableCellUncheckedUpdateManyWithoutColumnInput>
  }

  export type ReferenceTableCellScalarWhereInput = {
    AND?: ReferenceTableCellScalarWhereInput | ReferenceTableCellScalarWhereInput[]
    OR?: ReferenceTableCellScalarWhereInput[]
    NOT?: ReferenceTableCellScalarWhereInput | ReferenceTableCellScalarWhereInput[]
    id?: IntFilter<"ReferenceTableCell"> | number
    rowId?: IntFilter<"ReferenceTableCell"> | number
    columnId?: IntFilter<"ReferenceTableCell"> | number
    value?: StringNullableFilter<"ReferenceTableCell"> | string | null
    colSpan?: IntNullableFilter<"ReferenceTableCell"> | number | null
    rowSpan?: IntNullableFilter<"ReferenceTableCell"> | number | null
  }

  export type ReferenceTableUpsertWithoutColumnsInput = {
    update: XOR<ReferenceTableUpdateWithoutColumnsInput, ReferenceTableUncheckedUpdateWithoutColumnsInput>
    create: XOR<ReferenceTableCreateWithoutColumnsInput, ReferenceTableUncheckedCreateWithoutColumnsInput>
    where?: ReferenceTableWhereInput
  }

  export type ReferenceTableUpdateToOneWithWhereWithoutColumnsInput = {
    where?: ReferenceTableWhereInput
    data: XOR<ReferenceTableUpdateWithoutColumnsInput, ReferenceTableUncheckedUpdateWithoutColumnsInput>
  }

  export type ReferenceTableUpdateWithoutColumnsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rows?: ReferenceTableRowUpdateManyWithoutTableNestedInput
  }

  export type ReferenceTableUncheckedUpdateWithoutColumnsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rows?: ReferenceTableRowUncheckedUpdateManyWithoutTableNestedInput
  }

  export type ReferenceTableCellCreateWithoutRowInput = {
    value?: string | null
    colSpan?: number | null
    rowSpan?: number | null
    column: ReferenceTableColumnCreateNestedOneWithoutCellsInput
  }

  export type ReferenceTableCellUncheckedCreateWithoutRowInput = {
    id?: number
    columnId: number
    value?: string | null
    colSpan?: number | null
    rowSpan?: number | null
  }

  export type ReferenceTableCellCreateOrConnectWithoutRowInput = {
    where: ReferenceTableCellWhereUniqueInput
    create: XOR<ReferenceTableCellCreateWithoutRowInput, ReferenceTableCellUncheckedCreateWithoutRowInput>
  }

  export type ReferenceTableCellCreateManyRowInputEnvelope = {
    data: ReferenceTableCellCreateManyRowInput | ReferenceTableCellCreateManyRowInput[]
    skipDuplicates?: boolean
  }

  export type ReferenceTableCreateWithoutRowsInput = {
    slug: string
    name: string
    description?: string | null
    columns?: ReferenceTableColumnCreateNestedManyWithoutTableInput
  }

  export type ReferenceTableUncheckedCreateWithoutRowsInput = {
    slug: string
    name: string
    description?: string | null
    columns?: ReferenceTableColumnUncheckedCreateNestedManyWithoutTableInput
  }

  export type ReferenceTableCreateOrConnectWithoutRowsInput = {
    where: ReferenceTableWhereUniqueInput
    create: XOR<ReferenceTableCreateWithoutRowsInput, ReferenceTableUncheckedCreateWithoutRowsInput>
  }

  export type ReferenceTableCellUpsertWithWhereUniqueWithoutRowInput = {
    where: ReferenceTableCellWhereUniqueInput
    update: XOR<ReferenceTableCellUpdateWithoutRowInput, ReferenceTableCellUncheckedUpdateWithoutRowInput>
    create: XOR<ReferenceTableCellCreateWithoutRowInput, ReferenceTableCellUncheckedCreateWithoutRowInput>
  }

  export type ReferenceTableCellUpdateWithWhereUniqueWithoutRowInput = {
    where: ReferenceTableCellWhereUniqueInput
    data: XOR<ReferenceTableCellUpdateWithoutRowInput, ReferenceTableCellUncheckedUpdateWithoutRowInput>
  }

  export type ReferenceTableCellUpdateManyWithWhereWithoutRowInput = {
    where: ReferenceTableCellScalarWhereInput
    data: XOR<ReferenceTableCellUpdateManyMutationInput, ReferenceTableCellUncheckedUpdateManyWithoutRowInput>
  }

  export type ReferenceTableUpsertWithoutRowsInput = {
    update: XOR<ReferenceTableUpdateWithoutRowsInput, ReferenceTableUncheckedUpdateWithoutRowsInput>
    create: XOR<ReferenceTableCreateWithoutRowsInput, ReferenceTableUncheckedCreateWithoutRowsInput>
    where?: ReferenceTableWhereInput
  }

  export type ReferenceTableUpdateToOneWithWhereWithoutRowsInput = {
    where?: ReferenceTableWhereInput
    data: XOR<ReferenceTableUpdateWithoutRowsInput, ReferenceTableUncheckedUpdateWithoutRowsInput>
  }

  export type ReferenceTableUpdateWithoutRowsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    columns?: ReferenceTableColumnUpdateManyWithoutTableNestedInput
  }

  export type ReferenceTableUncheckedUpdateWithoutRowsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    columns?: ReferenceTableColumnUncheckedUpdateManyWithoutTableNestedInput
  }

  export type ReferenceTableColumnCreateWithoutCellsInput = {
    columnIndex: number
    header: string
    span?: number | null
    alignment?: string | null
    table: ReferenceTableCreateNestedOneWithoutColumnsInput
  }

  export type ReferenceTableColumnUncheckedCreateWithoutCellsInput = {
    id?: number
    tableSlug: string
    columnIndex: number
    header: string
    span?: number | null
    alignment?: string | null
  }

  export type ReferenceTableColumnCreateOrConnectWithoutCellsInput = {
    where: ReferenceTableColumnWhereUniqueInput
    create: XOR<ReferenceTableColumnCreateWithoutCellsInput, ReferenceTableColumnUncheckedCreateWithoutCellsInput>
  }

  export type ReferenceTableRowCreateWithoutCellsInput = {
    rowIndex: number
    label?: string | null
    table: ReferenceTableCreateNestedOneWithoutRowsInput
  }

  export type ReferenceTableRowUncheckedCreateWithoutCellsInput = {
    id?: number
    tableSlug: string
    rowIndex: number
    label?: string | null
  }

  export type ReferenceTableRowCreateOrConnectWithoutCellsInput = {
    where: ReferenceTableRowWhereUniqueInput
    create: XOR<ReferenceTableRowCreateWithoutCellsInput, ReferenceTableRowUncheckedCreateWithoutCellsInput>
  }

  export type ReferenceTableColumnUpsertWithoutCellsInput = {
    update: XOR<ReferenceTableColumnUpdateWithoutCellsInput, ReferenceTableColumnUncheckedUpdateWithoutCellsInput>
    create: XOR<ReferenceTableColumnCreateWithoutCellsInput, ReferenceTableColumnUncheckedCreateWithoutCellsInput>
    where?: ReferenceTableColumnWhereInput
  }

  export type ReferenceTableColumnUpdateToOneWithWhereWithoutCellsInput = {
    where?: ReferenceTableColumnWhereInput
    data: XOR<ReferenceTableColumnUpdateWithoutCellsInput, ReferenceTableColumnUncheckedUpdateWithoutCellsInput>
  }

  export type ReferenceTableColumnUpdateWithoutCellsInput = {
    columnIndex?: IntFieldUpdateOperationsInput | number
    header?: StringFieldUpdateOperationsInput | string
    span?: NullableIntFieldUpdateOperationsInput | number | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
    table?: ReferenceTableUpdateOneRequiredWithoutColumnsNestedInput
  }

  export type ReferenceTableColumnUncheckedUpdateWithoutCellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableSlug?: StringFieldUpdateOperationsInput | string
    columnIndex?: IntFieldUpdateOperationsInput | number
    header?: StringFieldUpdateOperationsInput | string
    span?: NullableIntFieldUpdateOperationsInput | number | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceTableRowUpsertWithoutCellsInput = {
    update: XOR<ReferenceTableRowUpdateWithoutCellsInput, ReferenceTableRowUncheckedUpdateWithoutCellsInput>
    create: XOR<ReferenceTableRowCreateWithoutCellsInput, ReferenceTableRowUncheckedCreateWithoutCellsInput>
    where?: ReferenceTableRowWhereInput
  }

  export type ReferenceTableRowUpdateToOneWithWhereWithoutCellsInput = {
    where?: ReferenceTableRowWhereInput
    data: XOR<ReferenceTableRowUpdateWithoutCellsInput, ReferenceTableRowUncheckedUpdateWithoutCellsInput>
  }

  export type ReferenceTableRowUpdateWithoutCellsInput = {
    rowIndex?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    table?: ReferenceTableUpdateOneRequiredWithoutRowsNestedInput
  }

  export type ReferenceTableRowUncheckedUpdateWithoutCellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableSlug?: StringFieldUpdateOperationsInput | string
    rowIndex?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCharacterAttributeCreateWithoutCharacterInput = {
    attributeId: number
    value: number
  }

  export type UserCharacterAttributeUncheckedCreateWithoutCharacterInput = {
    id?: number
    attributeId: number
    value: number
  }

  export type UserCharacterAttributeCreateOrConnectWithoutCharacterInput = {
    where: UserCharacterAttributeWhereUniqueInput
    create: XOR<UserCharacterAttributeCreateWithoutCharacterInput, UserCharacterAttributeUncheckedCreateWithoutCharacterInput>
  }

  export type UserCharacterAttributeCreateManyCharacterInputEnvelope = {
    data: UserCharacterAttributeCreateManyCharacterInput | UserCharacterAttributeCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type RaceCreateWithoutUserCharacterInput = {
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    abilityAdjustments?: RaceAbilityAdjustmentCreateNestedManyWithoutRaceInput
    languages?: RaceLanguageMapCreateNestedManyWithoutRaceInput
    sources?: RaceSourceMapCreateNestedManyWithoutRaceInput
    traits?: RaceTraitMapCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutUserCharacterInput = {
    id?: number
    name: string
    editionId?: number | null
    isVisible?: boolean
    description?: string | null
    sizeId?: number
    speed?: number
    favoredClassId?: number
    abilityAdjustments?: RaceAbilityAdjustmentUncheckedCreateNestedManyWithoutRaceInput
    languages?: RaceLanguageMapUncheckedCreateNestedManyWithoutRaceInput
    sources?: RaceSourceMapUncheckedCreateNestedManyWithoutRaceInput
    traits?: RaceTraitMapUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutUserCharacterInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutUserCharacterInput, RaceUncheckedCreateWithoutUserCharacterInput>
  }

  export type UserCreateWithoutCharactersInput = {
    username: string
    email: string
    password: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredEditionId?: number | null
  }

  export type UserUncheckedCreateWithoutCharactersInput = {
    id?: number
    username: string
    email: string
    password: string
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    preferredEditionId?: number | null
  }

  export type UserCreateOrConnectWithoutCharactersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
  }

  export type UserCharacterAttributeUpsertWithWhereUniqueWithoutCharacterInput = {
    where: UserCharacterAttributeWhereUniqueInput
    update: XOR<UserCharacterAttributeUpdateWithoutCharacterInput, UserCharacterAttributeUncheckedUpdateWithoutCharacterInput>
    create: XOR<UserCharacterAttributeCreateWithoutCharacterInput, UserCharacterAttributeUncheckedCreateWithoutCharacterInput>
  }

  export type UserCharacterAttributeUpdateWithWhereUniqueWithoutCharacterInput = {
    where: UserCharacterAttributeWhereUniqueInput
    data: XOR<UserCharacterAttributeUpdateWithoutCharacterInput, UserCharacterAttributeUncheckedUpdateWithoutCharacterInput>
  }

  export type UserCharacterAttributeUpdateManyWithWhereWithoutCharacterInput = {
    where: UserCharacterAttributeScalarWhereInput
    data: XOR<UserCharacterAttributeUpdateManyMutationInput, UserCharacterAttributeUncheckedUpdateManyWithoutCharacterInput>
  }

  export type UserCharacterAttributeScalarWhereInput = {
    AND?: UserCharacterAttributeScalarWhereInput | UserCharacterAttributeScalarWhereInput[]
    OR?: UserCharacterAttributeScalarWhereInput[]
    NOT?: UserCharacterAttributeScalarWhereInput | UserCharacterAttributeScalarWhereInput[]
    id?: IntFilter<"UserCharacterAttribute"> | number
    characterId?: IntFilter<"UserCharacterAttribute"> | number
    attributeId?: IntFilter<"UserCharacterAttribute"> | number
    value?: IntFilter<"UserCharacterAttribute"> | number
  }

  export type RaceUpsertWithoutUserCharacterInput = {
    update: XOR<RaceUpdateWithoutUserCharacterInput, RaceUncheckedUpdateWithoutUserCharacterInput>
    create: XOR<RaceCreateWithoutUserCharacterInput, RaceUncheckedCreateWithoutUserCharacterInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutUserCharacterInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutUserCharacterInput, RaceUncheckedUpdateWithoutUserCharacterInput>
  }

  export type RaceUpdateWithoutUserCharacterInput = {
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    abilityAdjustments?: RaceAbilityAdjustmentUpdateManyWithoutRaceNestedInput
    languages?: RaceLanguageMapUpdateManyWithoutRaceNestedInput
    sources?: RaceSourceMapUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitMapUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutUserCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    editionId?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    favoredClassId?: IntFieldUpdateOperationsInput | number
    abilityAdjustments?: RaceAbilityAdjustmentUncheckedUpdateManyWithoutRaceNestedInput
    languages?: RaceLanguageMapUncheckedUpdateManyWithoutRaceNestedInput
    sources?: RaceSourceMapUncheckedUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitMapUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type UserUpsertWithoutCharactersInput = {
    update: XOR<UserUpdateWithoutCharactersInput, UserUncheckedUpdateWithoutCharactersInput>
    create: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCharactersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCharactersInput, UserUncheckedUpdateWithoutCharactersInput>
  }

  export type UserUpdateWithoutCharactersInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredEditionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateWithoutCharactersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredEditionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCharacterCreateWithoutAttributesInput = {
    name: string
    alignmentId: number
    age?: number | null
    height?: number | null
    weight?: number | null
    eyes?: string | null
    hair?: string | null
    gender?: string | null
    notes?: string | null
    race: RaceCreateNestedOneWithoutUserCharacterInput
    user: UserCreateNestedOneWithoutCharactersInput
  }

  export type UserCharacterUncheckedCreateWithoutAttributesInput = {
    id?: number
    userId: number
    name: string
    raceId: number
    alignmentId: number
    age?: number | null
    height?: number | null
    weight?: number | null
    eyes?: string | null
    hair?: string | null
    gender?: string | null
    notes?: string | null
  }

  export type UserCharacterCreateOrConnectWithoutAttributesInput = {
    where: UserCharacterWhereUniqueInput
    create: XOR<UserCharacterCreateWithoutAttributesInput, UserCharacterUncheckedCreateWithoutAttributesInput>
  }

  export type UserCharacterUpsertWithoutAttributesInput = {
    update: XOR<UserCharacterUpdateWithoutAttributesInput, UserCharacterUncheckedUpdateWithoutAttributesInput>
    create: XOR<UserCharacterCreateWithoutAttributesInput, UserCharacterUncheckedCreateWithoutAttributesInput>
    where?: UserCharacterWhereInput
  }

  export type UserCharacterUpdateToOneWithWhereWithoutAttributesInput = {
    where?: UserCharacterWhereInput
    data: XOR<UserCharacterUpdateWithoutAttributesInput, UserCharacterUncheckedUpdateWithoutAttributesInput>
  }

  export type UserCharacterUpdateWithoutAttributesInput = {
    name?: StringFieldUpdateOperationsInput | string
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneRequiredWithoutUserCharacterNestedInput
    user?: UserUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type UserCharacterUncheckedUpdateWithoutAttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCharacterCreateWithoutUserInput = {
    name: string
    alignmentId: number
    age?: number | null
    height?: number | null
    weight?: number | null
    eyes?: string | null
    hair?: string | null
    gender?: string | null
    notes?: string | null
    attributes?: UserCharacterAttributeCreateNestedManyWithoutCharacterInput
    race: RaceCreateNestedOneWithoutUserCharacterInput
  }

  export type UserCharacterUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    raceId: number
    alignmentId: number
    age?: number | null
    height?: number | null
    weight?: number | null
    eyes?: string | null
    hair?: string | null
    gender?: string | null
    notes?: string | null
    attributes?: UserCharacterAttributeUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type UserCharacterCreateOrConnectWithoutUserInput = {
    where: UserCharacterWhereUniqueInput
    create: XOR<UserCharacterCreateWithoutUserInput, UserCharacterUncheckedCreateWithoutUserInput>
  }

  export type UserCharacterCreateManyUserInputEnvelope = {
    data: UserCharacterCreateManyUserInput | UserCharacterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCharacterUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCharacterWhereUniqueInput
    update: XOR<UserCharacterUpdateWithoutUserInput, UserCharacterUncheckedUpdateWithoutUserInput>
    create: XOR<UserCharacterCreateWithoutUserInput, UserCharacterUncheckedCreateWithoutUserInput>
  }

  export type UserCharacterUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCharacterWhereUniqueInput
    data: XOR<UserCharacterUpdateWithoutUserInput, UserCharacterUncheckedUpdateWithoutUserInput>
  }

  export type UserCharacterUpdateManyWithWhereWithoutUserInput = {
    where: UserCharacterScalarWhereInput
    data: XOR<UserCharacterUpdateManyMutationInput, UserCharacterUncheckedUpdateManyWithoutUserInput>
  }

  export type ClassFeatureCreateManyClassInput = {
    id?: number
    name: string
    description?: string | null
    level?: number | null
  }

  export type ClassLevelAttributeCreateManyClassInput = {
    id?: number
    baseAttackBonus: number
    fortSave: number
    refSave: number
    willSave: number
  }

  export type ClassSpellLevelCreateManyClassInput = {
    id?: number
    spellLevel: number
  }

  export type ClassSkillMapCreateManyClassInput = {
    id?: number
    skillId: number
  }

  export type ClassSourceMapCreateManyClassInput = {
    id?: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type SpellLevelMapCreateManyClassInput = {
    id?: number
    spellId: number
    level: number
    isVisible?: boolean
  }

  export type ClassFeatureUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassFeatureUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassFeatureUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassLevelAttributeUpdateWithoutClassInput = {
    baseAttackBonus?: IntFieldUpdateOperationsInput | number
    fortSave?: IntFieldUpdateOperationsInput | number
    refSave?: IntFieldUpdateOperationsInput | number
    willSave?: IntFieldUpdateOperationsInput | number
  }

  export type ClassLevelAttributeUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseAttackBonus?: IntFieldUpdateOperationsInput | number
    fortSave?: IntFieldUpdateOperationsInput | number
    refSave?: IntFieldUpdateOperationsInput | number
    willSave?: IntFieldUpdateOperationsInput | number
  }

  export type ClassLevelAttributeUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseAttackBonus?: IntFieldUpdateOperationsInput | number
    fortSave?: IntFieldUpdateOperationsInput | number
    refSave?: IntFieldUpdateOperationsInput | number
    willSave?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSpellLevelUpdateWithoutClassInput = {
    spellLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSpellLevelUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSpellLevelUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSkillMapUpdateWithoutClassInput = {
    Skill?: SkillUpdateOneRequiredWithoutClassesNestedInput
  }

  export type ClassSkillMapUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSkillMapUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSourceMapUpdateWithoutClassInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    SourceBook?: SourceBookUpdateOneWithoutClassesNestedInput
  }

  export type ClassSourceMapUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassSourceMapUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellLevelMapUpdateWithoutClassInput = {
    level?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    spell?: SpellUpdateOneRequiredWithoutLevelMappingNestedInput
  }

  export type SpellLevelMapUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellLevelMapUncheckedUpdateManyWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellDescriptorMapCreateManySpellInput = {
    id?: number
    descriptorId: number
  }

  export type SpellLevelMapCreateManySpellInput = {
    id?: number
    classId: number
    level: number
    isVisible?: boolean
  }

  export type SpellSchoolMapCreateManySpellInput = {
    id?: number
    schoolId: number
  }

  export type SpellSourceMapCreateManySpellInput = {
    id?: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type SpellSubschoolMapCreateManySpellInput = {
    id?: number
    schoolId: number
  }

  export type SpellDescriptorMapUpdateWithoutSpellInput = {
    descriptorId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellDescriptorMapUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    descriptorId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellDescriptorMapUncheckedUpdateManyWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    descriptorId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellLevelMapUpdateWithoutSpellInput = {
    level?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassUpdateOneRequiredWithoutSpellLevelsNestedInput
  }

  export type SpellLevelMapUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellLevelMapUncheckedUpdateManyWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellSchoolMapUpdateWithoutSpellInput = {
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellSchoolMapUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellSchoolMapUncheckedUpdateManyWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellSourceMapUpdateWithoutSpellInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    SourceBook?: SourceBookUpdateOneWithoutSpellsNestedInput
  }

  export type SpellSourceMapUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSourceMapUncheckedUpdateManyWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSubschoolMapUpdateWithoutSpellInput = {
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellSubschoolMapUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type SpellSubschoolMapUncheckedUpdateManyWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSkillMapCreateManySkillInput = {
    id?: number
    classId: number
  }

  export type ClassSkillMapUpdateWithoutSkillInput = {
    Class?: ClassUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type ClassSkillMapUncheckedUpdateWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSkillMapUncheckedUpdateManyWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
  }

  export type FeatBenefitMapCreateManyFeatInput = {
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
  }

  export type FeatPrerequisiteMapCreateManyFeatInput = {
    typeId: number
    referenceId?: number | null
    amount?: number | null
    index: number
  }

  export type FeatBenefitMapUpdateWithoutFeatInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type FeatBenefitMapUncheckedUpdateWithoutFeatInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type FeatBenefitMapUncheckedUpdateManyWithoutFeatInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type FeatPrerequisiteMapUpdateWithoutFeatInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type FeatPrerequisiteMapUncheckedUpdateWithoutFeatInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type FeatPrerequisiteMapUncheckedUpdateManyWithoutFeatInput = {
    typeId?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    index?: IntFieldUpdateOperationsInput | number
  }

  export type RaceAbilityAdjustmentCreateManyRaceInput = {
    abilityId: number
    value: number
  }

  export type RaceLanguageMapCreateManyRaceInput = {
    languageId: number
    isAutomatic?: boolean
  }

  export type RaceSourceMapCreateManyRaceInput = {
    id?: number
    bookId: number
    pageNumber?: number | null
    sourceBookId?: number | null
  }

  export type RaceTraitMapCreateManyRaceInput = {
    traitId: string
    value?: string | null
  }

  export type UserCharacterCreateManyRaceInput = {
    id?: number
    userId: number
    name: string
    alignmentId: number
    age?: number | null
    height?: number | null
    weight?: number | null
    eyes?: string | null
    hair?: string | null
    gender?: string | null
    notes?: string | null
  }

  export type RaceAbilityAdjustmentUpdateWithoutRaceInput = {
    abilityId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RaceAbilityAdjustmentUncheckedUpdateWithoutRaceInput = {
    abilityId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RaceAbilityAdjustmentUncheckedUpdateManyWithoutRaceInput = {
    abilityId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RaceLanguageMapUpdateWithoutRaceInput = {
    languageId?: IntFieldUpdateOperationsInput | number
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceLanguageMapUncheckedUpdateWithoutRaceInput = {
    languageId?: IntFieldUpdateOperationsInput | number
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceLanguageMapUncheckedUpdateManyWithoutRaceInput = {
    languageId?: IntFieldUpdateOperationsInput | number
    isAutomatic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceSourceMapUpdateWithoutRaceInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    SourceBook?: SourceBookUpdateOneWithoutRacesNestedInput
  }

  export type RaceSourceMapUncheckedUpdateWithoutRaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RaceSourceMapUncheckedUpdateManyWithoutRaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    sourceBookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RaceTraitMapUpdateWithoutRaceInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    trait?: RaceTraitUpdateOneRequiredWithoutRaceLinksNestedInput
  }

  export type RaceTraitMapUncheckedUpdateWithoutRaceInput = {
    traitId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaceTraitMapUncheckedUpdateManyWithoutRaceInput = {
    traitId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCharacterUpdateWithoutRaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: UserCharacterAttributeUpdateManyWithoutCharacterNestedInput
    user?: UserUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type UserCharacterUncheckedUpdateWithoutRaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: UserCharacterAttributeUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type UserCharacterUncheckedUpdateManyWithoutRaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaceTraitMapCreateManyTraitInput = {
    raceId: number
    value?: string | null
  }

  export type RaceTraitMapUpdateWithoutTraitInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneRequiredWithoutTraitsNestedInput
  }

  export type RaceTraitMapUncheckedUpdateWithoutTraitInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaceTraitMapUncheckedUpdateManyWithoutTraitInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassSourceMapCreateManySourceBookInput = {
    id?: number
    classId: number
    bookId: number
    pageNumber?: number | null
  }

  export type RaceSourceMapCreateManySourceBookInput = {
    id?: number
    raceId: number
    bookId: number
    pageNumber?: number | null
  }

  export type SpellSourceMapCreateManySourceBookInput = {
    id?: number
    spellId: number
    bookId: number
    pageNumber?: number | null
  }

  export type ClassSourceMapUpdateWithoutSourceBookInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    class?: ClassUpdateOneRequiredWithoutSourcesNestedInput
  }

  export type ClassSourceMapUncheckedUpdateWithoutSourceBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassSourceMapUncheckedUpdateManyWithoutSourceBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RaceSourceMapUpdateWithoutSourceBookInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    Race?: RaceUpdateOneRequiredWithoutSourcesNestedInput
  }

  export type RaceSourceMapUncheckedUpdateWithoutSourceBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RaceSourceMapUncheckedUpdateManyWithoutSourceBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSourceMapUpdateWithoutSourceBookInput = {
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    Spell?: SpellUpdateOneRequiredWithoutSourcesNestedInput
  }

  export type SpellSourceMapUncheckedUpdateWithoutSourceBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSourceMapUncheckedUpdateManyWithoutSourceBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferenceTableColumnCreateManyTableInput = {
    id?: number
    columnIndex: number
    header: string
    span?: number | null
    alignment?: string | null
  }

  export type ReferenceTableRowCreateManyTableInput = {
    id?: number
    rowIndex: number
    label?: string | null
  }

  export type ReferenceTableColumnUpdateWithoutTableInput = {
    columnIndex?: IntFieldUpdateOperationsInput | number
    header?: StringFieldUpdateOperationsInput | string
    span?: NullableIntFieldUpdateOperationsInput | number | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
    cells?: ReferenceTableCellUpdateManyWithoutColumnNestedInput
  }

  export type ReferenceTableColumnUncheckedUpdateWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    columnIndex?: IntFieldUpdateOperationsInput | number
    header?: StringFieldUpdateOperationsInput | string
    span?: NullableIntFieldUpdateOperationsInput | number | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
    cells?: ReferenceTableCellUncheckedUpdateManyWithoutColumnNestedInput
  }

  export type ReferenceTableColumnUncheckedUpdateManyWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    columnIndex?: IntFieldUpdateOperationsInput | number
    header?: StringFieldUpdateOperationsInput | string
    span?: NullableIntFieldUpdateOperationsInput | number | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceTableRowUpdateWithoutTableInput = {
    rowIndex?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    cells?: ReferenceTableCellUpdateManyWithoutRowNestedInput
  }

  export type ReferenceTableRowUncheckedUpdateWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    rowIndex?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    cells?: ReferenceTableCellUncheckedUpdateManyWithoutRowNestedInput
  }

  export type ReferenceTableRowUncheckedUpdateManyWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    rowIndex?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferenceTableCellCreateManyColumnInput = {
    id?: number
    rowId: number
    value?: string | null
    colSpan?: number | null
    rowSpan?: number | null
  }

  export type ReferenceTableCellUpdateWithoutColumnInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    colSpan?: NullableIntFieldUpdateOperationsInput | number | null
    rowSpan?: NullableIntFieldUpdateOperationsInput | number | null
    row?: ReferenceTableRowUpdateOneRequiredWithoutCellsNestedInput
  }

  export type ReferenceTableCellUncheckedUpdateWithoutColumnInput = {
    id?: IntFieldUpdateOperationsInput | number
    rowId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    colSpan?: NullableIntFieldUpdateOperationsInput | number | null
    rowSpan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferenceTableCellUncheckedUpdateManyWithoutColumnInput = {
    id?: IntFieldUpdateOperationsInput | number
    rowId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    colSpan?: NullableIntFieldUpdateOperationsInput | number | null
    rowSpan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferenceTableCellCreateManyRowInput = {
    id?: number
    columnId: number
    value?: string | null
    colSpan?: number | null
    rowSpan?: number | null
  }

  export type ReferenceTableCellUpdateWithoutRowInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    colSpan?: NullableIntFieldUpdateOperationsInput | number | null
    rowSpan?: NullableIntFieldUpdateOperationsInput | number | null
    column?: ReferenceTableColumnUpdateOneRequiredWithoutCellsNestedInput
  }

  export type ReferenceTableCellUncheckedUpdateWithoutRowInput = {
    id?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    colSpan?: NullableIntFieldUpdateOperationsInput | number | null
    rowSpan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferenceTableCellUncheckedUpdateManyWithoutRowInput = {
    id?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    colSpan?: NullableIntFieldUpdateOperationsInput | number | null
    rowSpan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCharacterAttributeCreateManyCharacterInput = {
    id?: number
    attributeId: number
    value: number
  }

  export type UserCharacterAttributeUpdateWithoutCharacterInput = {
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type UserCharacterAttributeUncheckedUpdateWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type UserCharacterAttributeUncheckedUpdateManyWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type UserCharacterCreateManyUserInput = {
    id?: number
    name: string
    raceId: number
    alignmentId: number
    age?: number | null
    height?: number | null
    weight?: number | null
    eyes?: string | null
    hair?: string | null
    gender?: string | null
    notes?: string | null
  }

  export type UserCharacterUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: UserCharacterAttributeUpdateManyWithoutCharacterNestedInput
    race?: RaceUpdateOneRequiredWithoutUserCharacterNestedInput
  }

  export type UserCharacterUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: UserCharacterAttributeUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type UserCharacterUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    raceId?: IntFieldUpdateOperationsInput | number
    alignmentId?: IntFieldUpdateOperationsInput | number
    age?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    eyes?: NullableStringFieldUpdateOperationsInput | string | null
    hair?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}